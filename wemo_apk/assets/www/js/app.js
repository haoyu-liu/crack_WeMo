(function () {
define('implementations',{
    'target': 'android',
    'app':'features/app/wemo',
    'appSettings':'features/appSettings/wemo-production',
    'appDependencies':'features/loadExtensions/wemo',
    'alert':'features/alert/notIos',
    'customalert':'features/customalert/notIos',
    'dataInterface':'features/dataInterface/android',
    'demoDevices': 'features/demoDevices/noop',
    'uiInterface':'features/uiInterface/notIos',
    'database':'features/database/sqlite-notIos',
    'cordova':'features/cordova/app',
    'sqlitePlugin': 'features/sqlitePlugin/SQLitePlugin'
});
/**
 * AMD-Feature - A loader plugin for AMD loaders.
 *
 * https://github.com/jensarps/AMD-feature
 *
 * @author Jens Arps - http://jensarps.de/
 * @license MIT or BSD - https://github.com/jensarps/AMD-feature/blob/master/LICENSE
 * @version 1.1.0
 */
define('feature',['implementations'], function (implementations) {

    return {

        load: function (name, req, load, config) {

            var i, m, toLoad,
                featureInfo = implementations[name],
                hasMultipleImpls = Object.prototype.toString.call(featureInfo) == '[object Array]';

            if (config.isBuild && hasMultipleImpls) {
                // In build context, we want all possible
                // implementations included.
                for (i = 0, m = featureInfo.length; i < m; i++) {
                    if (featureInfo[i].implementation) {
                        req([featureInfo[i].implementation], load);
                    }
                }

                // We're done here now.
                return;
            }

            if (hasMultipleImpls) {
                // We have different implementations available,
                // test for the one to use.
                for (i = 0, m = featureInfo.length; i < m; i++) {
                    var current = featureInfo[i];
                    if (current.isAvailable()) {
                        if (typeof current.module != 'undefined') {
                            load(current.module());
                            return;
                        }
                        toLoad = current.implementation;
                        break;
                    }
                }
            } else {
                if (typeof featureInfo.module != 'undefined') {
                    load(featureInfo.module());
                    return;
                }
                toLoad = featureInfo;
            }

            req([toLoad], load);
        }
    };
});
;!function(exports, undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      
      this._conf = conf;
      
      conf.delimiter && (this.delimiter = conf.delimiter);
      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    configure.call(this, conf);
  }

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }
    
    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }
        
        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    
    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else if(typeof tree._listeners === 'function') {
          tree._listeners = [tree._listeners, listener];
        }
        else if (isArray(tree._listeners)) {

          tree._listeners.push(listener);

          if (!tree._listeners.warned) {

            var m = defaultMaxListeners;
            
            if (typeof this._events.maxListeners !== 'undefined') {
              m = this._events.maxListeners;
            }

            if (m > 0 && tree._listeners.length > m) {

              tree._listeners.warned = true;
              console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.',
                            tree._listeners.length);
              console.trace();
            }
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  };

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    this._events || init.call(this);
    this._events.maxListeners = n;
    if (!this._conf) this._conf = {};
    this._conf.maxListeners = n;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    };

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {
    
    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) { return false; }
    }

    // Loop through the *_all* functions and invoke them.
    if (this._all) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        this._all[i].apply(this, args);
      }
    }

    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      
      if (!this._all && 
        !this._events.error && 
        !(this.wildcard && this.listenerTree.error)) {

        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled 'error' event
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }

    var handler;

    if(this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    }
    else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      if (arguments.length === 1) {
        handler.call(this);
      }
      else if (arguments.length > 1)
        switch (arguments.length) {
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            var l = arguments.length;
            var args = new Array(l - 1);
            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
            handler.apply(this, args);
        }
      return true;
    }
    else if (handler) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i < l; i++) {
        this.event = type;
        listeners[i].apply(this, args);
      }
      return (listeners.length > 0) || this._all;
    }
    else {
      return this._all;
    }

  };

  EventEmitter.prototype.on = function(type, listener) {
    
    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if(this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else if(typeof this._events[type] === 'function') {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }
    else if (isArray(this._events[type])) {
      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (!this._events[type].warned) {

        var m = defaultMaxListeners;
        
        if (typeof this._events.maxListeners !== 'undefined') {
          m = this._events.maxListeners;
        }

        if (m > 0 && this._events[type].length > m) {

          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          console.trace();
        }
      }
    }
    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {

    if(!this._all) {
      this._all = [];
    }

    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          return this;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1)
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          return this;
        }
      }
    } else {
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else {
      if (!this._events[type]) return this;
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if(this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (typeof define === 'function' && define.amd) {
    define('eventemitter',[],function() {
      return EventEmitter;
    });
  } else {
    exports.EventEmitter2 = EventEmitter; 
  }

}(typeof process !== 'undefined' && typeof process.title !== 'undefined' && typeof exports !== 'undefined' ? exports : window);

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash underscore exports="amd,commonjs,global,node" -o ./dist/lodash.underscore.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Used for `Array` method references.
   *
   * Normally `Array.prototype` would suffice, however, using an array literal
   * avoids issues in Narwhal.
   */
  var arrayRef = [];

  /** Used for native method references */
  var objectProto = Object.prototype;

  /** Used to restore the original `_` reference in `noConflict` */
  var oldDash = root._;

  /** Used to resolve the internal [[Class]] of values */
  var toString = objectProto.toString;

  /** Used to detect if a method is native */
  var reNative = RegExp('^' +
    String(toString)
      .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      .replace(/toString| for [^\]]+/g, '.*?') + '$'
  );

  /** Native method shortcuts */
  var ceil = Math.ceil,
      floor = Math.floor,
      hasOwnProperty = objectProto.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
      nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeIsFinite = root.isFinite,
      nativeIsNaN = root.isNaN,
      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeRandom = Math.random;

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps the given value to enable intuitive
   * method chaining.
   *
   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
   * and `unshift`
   *
   * Chaining is supported in custom builds as long as the `value` method is
   * implicitly or explicitly included in the build.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
   * and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
   * `template`, `unescape`, `uniqueId`, and `value`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * provided, otherwise they return unwrapped values.
   *
   * Explicit chaining can be enabled by using the `_.chain` method.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(num) {
   *   return num * num;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    return (value instanceof lodash)
      ? value
      : new lodashWrapper(value);
  }

  /**
   * A fast path for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap in a `lodash` instance.
   * @param {boolean} chainAll A flag to enable chaining for all methods
   * @returns {Object} Returns a `lodash` instance.
   */
  function lodashWrapper(value, chainAll) {
    this.__chain__ = !!chainAll;
    this.__wrapped__ = value;
  }
  // ensure `new lodashWrapper` is an instance of `lodash`
  lodashWrapper.prototype = lodash.prototype;

  /**
   * An object used to flag environments features.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = {};

  (function() {
    var object = { '0': 1, 'length': 1 };

    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
     *
     * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
     * and `splice()` functions that fail to remove the last element, `value[0]`,
     * of array-like objects even though the `length` property is set to `0`.
     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
     * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
  }(1));

  /**
   * By default, the template delimiters used by Lo-Dash are similar to those in
   * embedded Ruby (ERB). Change the following template settings to use alternative
   * delimiters.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  lodash.templateSettings = {

    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'escape': /<%-([\s\S]+?)%>/g,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'evaluate': /<%([\s\S]+?)%>/g,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'interpolate': reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type string
     */
    'variable': ''
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.bind` that creates the bound function and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new bound function.
   */
  function baseBind(bindData) {
    var func = bindData[0],
        partialArgs = bindData[2],
        thisArg = bindData[4];

    function bound() {
      // `Function#bind` spec
      // http://es5.github.io/#x15.3.4.5
      if (partialArgs) {
        // avoid `arguments` object deoptimizations by using `slice` instead
        // of `Array.prototype.slice.call` and not assigning `arguments` to a
        // variable as a ternary expression
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      // mimic the constructor's `return` behavior
      // http://es5.github.io/#x13.2.2
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `func`
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisArg, args || arguments);
    }
    return bound;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(prototype, properties) {
    return isObject(prototype) ? nativeCreate(prototype) : {};
  }
  // fallback for browsers without `Object.create`
  if (!nativeCreate) {
    baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || root.Object();
      };
    }());
  }

  /**
   * The base implementation of `_.createCallback` without support for creating
   * "_.pluck" or "_.where" style callbacks.
   *
   * @private
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   */
  function baseCreateCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    // exit early for no `thisArg` or already bound by `Function#bind`
    if (typeof thisArg == 'undefined' || !('prototype' in func)) {
      return func;
    }
    switch (argCount) {
      case 1: return function(value) {
        return func.call(thisArg, value);
      };
      case 2: return function(a, b) {
        return func.call(thisArg, a, b);
      };
      case 3: return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(thisArg, accumulator, value, index, collection);
      };
    }
    return bind(func, thisArg);
  }

  /**
   * The base implementation of `createWrapper` that creates the wrapper and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new function.
   */
  function baseCreateWrapper(bindData) {
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        key = func;

    function bound() {
      var thisBinding = isBind ? thisArg : this;
      if (partialArgs) {
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      if (partialRightArgs || isCurry) {
        args || (args = slice(arguments));
        if (partialRightArgs) {
          push.apply(args, partialRightArgs);
        }
        if (isCurry && args.length < arity) {
          bitmask |= 16 & ~32;
          return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
        }
      }
      args || (args = arguments);
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (this instanceof bound) {
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    return bound;
  }

  /**
   * The base implementation of `_.difference` that accepts a single array
   * of values to exclude.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {Array} [values] The array of values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   */
  function baseDifference(array, values) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (indexOf(values, value) < 0) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.flatten` without support for callback
   * shorthands or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
   * @param {number} [fromIndex=0] The index to start from.
   * @returns {Array} Returns a new flattened array.
   */
  function baseFlatten(array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value && typeof value == 'object' && typeof value.length == 'number'
          && (isArray(value) || isArguments(value))) {
        // recursively flatten arrays (susceptible to call stack limits)
        if (!isShallow) {
          value = baseFlatten(value, isShallow, isStrict);
        }
        var valIndex = -1,
            valLength = value.length,
            resIndex = result.length;

        result.length += valLength;
        while (++valIndex < valLength) {
          result[resIndex++] = value[valIndex];
        }
      } else if (!isStrict) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isEqual`, without support for `thisArg` binding,
   * that allows partial "_.where" style comparisons.
   *
   * @private
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `a` objects.
   * @param {Array} [stackB=[]] Tracks traversed `b` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(a, b, stackA, stackB) {
    if (a === b) {
      return a !== 0 || (1 / a == 1 / b);
    }
    var type = typeof a,
        otherType = typeof b;

    if (a === a &&
        !(a && objectTypes[type]) &&
        !(b && objectTypes[otherType])) {
      return false;
    }
    if (a == null || b == null) {
      return a === b;
    }
    var className = toString.call(a),
        otherClass = toString.call(b);

    if (className != otherClass) {
      return false;
    }
    switch (className) {
      case boolClass:
      case dateClass:
        return +a == +b;

      case numberClass:
        return a != +a
          ? b != +b
          : (a == 0 ? (1 / a == 1 / b) : a == +b);

      case regexpClass:
      case stringClass:
        return a == String(b);
    }
    var isArr = className == arrayClass;
    if (!isArr) {
      var aWrapped = a instanceof lodash,
          bWrapped = b instanceof lodash;

      if (aWrapped || bWrapped) {
        return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, stackA, stackB);
      }
      if (className != objectClass) {
        return false;
      }
      var ctorA = a.constructor,
          ctorB = b.constructor;

      if (ctorA != ctorB &&
            !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
            ('constructor' in a && 'constructor' in b)
          ) {
        return false;
      }
    }
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == a) {
        return stackB[length] == b;
      }
    }
    var result = true,
        size = 0;

    stackA.push(a);
    stackB.push(b);

    if (isArr) {
      size = b.length;
      result = size == a.length;

      if (result) {
        while (size--) {
          if (!(result = baseIsEqual(a[size], b[size], stackA, stackB))) {
            break;
          }
        }
      }
    }
    else {
      forIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          size++;
          return !(result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, stackA, stackB)) && indicatorObject;
        }
      });

      if (result) {
        forIn(a, function(value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            return !(result = --size > -1) && indicatorObject;
          }
        });
      }
    }
    stackA.pop();
    stackB.pop();
    return result;
  }

  /**
   * The base implementation of `_.random` without argument juggling or support
   * for returning floating-point numbers.
   *
   * @private
   * @param {number} min The minimum possible value.
   * @param {number} max The maximum possible value.
   * @returns {number} Returns a random number.
   */
  function baseRandom(min, max) {
    return min + floor(nativeRandom() * (max - min + 1));
  }

  /**
   * The base implementation of `_.uniq` without support for callback shorthands
   * or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function} [callback] The function called per iteration.
   * @returns {Array} Returns a duplicate-value-free array.
   */
  function baseUniq(array, isSorted, callback) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [],
        seen = callback ? [] : result;

    while (++index < length) {
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      if (isSorted
            ? !index || seen[seen.length - 1] !== computed
            : indexOf(seen, computed) < 0
          ) {
        if (callback) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates a function that aggregates a collection, creating an object composed
   * of keys generated from the results of running each element of the collection
   * through a callback. The given `setter` function sets the keys and values
   * of the composed object.
   *
   * @private
   * @param {Function} setter The setter function.
   * @returns {Function} Returns the new aggregator function.
   */
  function createAggregator(setter) {
    return function(collection, callback, thisArg) {
      var result = {};
      callback = createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          setter(result, value, callback(value, index, collection), collection);
        }
      } else {
        forOwn(collection, function(value, key, collection) {
          setter(result, value, callback(value, key, collection), collection);
        });
      }
      return result;
    };
  }

  /**
   * Creates a function that, when called, either curries or invokes `func`
   * with an optional `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of method flags to compose.
   *  The bitmask may be composed of the following flags:
   *  1 - `_.bind`
   *  2 - `_.bindKey`
   *  4 - `_.curry`
   *  8 - `_.curry` (bound)
   *  16 - `_.partial`
   *  32 - `_.partialRight`
   * @param {Array} [partialArgs] An array of arguments to prepend to those
   *  provided to the new function.
   * @param {Array} [partialRightArgs] An array of arguments to append to those
   *  provided to the new function.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new function.
   */
  function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        isPartial = bitmask & 16,
        isPartialRight = bitmask & 32;

    if (!isBindKey && !isFunction(func)) {
      throw new TypeError;
    }
    if (isPartial && !partialArgs.length) {
      bitmask &= ~16;
      isPartial = partialArgs = false;
    }
    if (isPartialRight && !partialRightArgs.length) {
      bitmask &= ~32;
      isPartialRight = partialRightArgs = false;
    }
    // fast path for `_.bind`
    var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
    return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
  }

  /**
   * Used by `escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(match) {
    return htmlEscapes[match];
  }

  /**
   * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
   * customized, this method returns the custom method, otherwise it returns
   * the `baseIndexOf` function.
   *
   * @private
   * @returns {Function} Returns the "indexOf" function.
   */
  function getIndexOf() {
    var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
    return result;
  }

  /**
   * Checks if `value` is a native function.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
   */
  function isNative(value) {
    return typeof value == 'function' && reNative.test(value);
  }

  /**
   * Used by `unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} match The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(match) {
    return htmlUnescapes[match];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
      toString.call(value) == argsClass || false;
  }
  // fallback for browsers that can't detect `arguments` objects by [[Class]]
  if (!isArguments(arguments)) {
    isArguments = function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
    };
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = nativeIsArray || function(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
      toString.call(value) == arrayClass || false;
  };

  /**
   * A fallback implementation of `Object.keys` which produces an array of the
   * given object's own enumerable property names.
   *
   * @private
   * @type Function
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   */
  var shimKeys = function(object) {
    var index, iterable = object, result = [];
    if (!iterable) return result;
    if (!(objectTypes[typeof object])) return result;
      for (index in iterable) {
        if (hasOwnProperty.call(iterable, index)) {
          result.push(index);
        }
      }
    return result
  };

  /**
   * Creates an array composed of the own enumerable property names of an object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    if (!isObject(object)) {
      return [];
    }
    return nativeKeys(object);
  };

  /**
   * Used to convert characters to HTML entities:
   *
   * Though the `>` character is escaped for symmetry, characters like `>` and `/`
   * don't require escaping in HTML and have no special meaning unless they're part
   * of a tag or an unquoted attribute value.
   * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
   */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;'
  };

  /** Used to convert HTML entities to characters */
  var htmlUnescapes = invert(htmlEscapes);

  /** Used to match HTML entities and HTML characters */
  var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
      reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources will overwrite property assignments of previous
   * sources. If a callback is provided it will be executed to produce the
   * assigned values. The callback is bound to `thisArg` and invoked with two
   * arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @type Function
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
   * // => { 'name': 'fred', 'employer': 'slate' }
   *
   * var defaults = _.partialRight(_.assign, function(a, b) {
   *   return typeof a == 'undefined' ? b : a;
   * });
   *
   * var object = { 'name': 'barney' };
   * defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  function assign(object) {
    if (!object) {
      return object;
    }
    for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {
      var iterable = arguments[argsIndex];
      if (iterable) {
        for (var key in iterable) {
          object[key] = iterable[key];
        }
      }
    }
    return object;
  }

  /**
   * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
   * be cloned, otherwise they will be assigned by reference. If a callback
   * is provided it will be executed to produce the cloned values. If the
   * callback returns `undefined` cloning will be handled by the method instead.
   * The callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep=false] Specify a deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the cloned value.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * var shallow = _.clone(characters);
   * shallow[0] === characters[0];
   * // => true
   *
   * var deep = _.clone(characters, true);
   * deep[0] === characters[0];
   * // => false
   *
   * _.mixin({
   *   'clone': _.partialRight(_.clone, function(value) {
   *     return _.isElement(value) ? value.cloneNode(false) : undefined;
   *   })
   * });
   *
   * var clone = _.clone(document.body);
   * clone.childNodes.length;
   * // => 0
   */
  function clone(value) {
    return isObject(value)
      ? (isArray(value) ? slice(value) : assign({}, value))
      : value;
  }

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties that resolve to `undefined`. Once a
   * property is set, additional defaults of the same property will be ignored.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param- {Object} [guard] Allows working with `_.reduce` without using its
   *  `key` and `object` arguments as sources.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var object = { 'name': 'barney' };
   * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  function defaults(object) {
    if (!object) {
      return object;
    }
    for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {
      var iterable = arguments[argsIndex];
      if (iterable) {
        for (var key in iterable) {
          if (typeof object[key] == 'undefined') {
            object[key] = iterable[key];
          }
        }
      }
    }
    return object;
  }

  /**
   * Iterates over own and inherited enumerable properties of an object,
   * executing the callback for each property. The callback is bound to `thisArg`
   * and invoked with three arguments; (value, key, object). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * Shape.prototype.move = function(x, y) {
   *   this.x += x;
   *   this.y += y;
   * };
   *
   * _.forIn(new Shape, function(value, key) {
   *   console.log(key);
   * });
   * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
   */
  var forIn = function(collection, callback) {
    var index, iterable = collection, result = iterable;
    if (!iterable) return result;
    if (!objectTypes[typeof iterable]) return result;
      for (index in iterable) {
        if (callback(iterable[index], index, collection) === indicatorObject) return result;
      }
    return result
  };

  /**
   * Iterates over own enumerable properties of an object, executing the callback
   * for each property. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
   *   console.log(key);
   * });
   * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
   */
  var forOwn = function(collection, callback) {
    var index, iterable = collection, result = iterable;
    if (!iterable) return result;
    if (!objectTypes[typeof iterable]) return result;
      for (index in iterable) {
        if (hasOwnProperty.call(iterable, index)) {
          if (callback(iterable[index], index, collection) === indicatorObject) return result;
        }
      }
    return result
  };

  /**
   * Creates a sorted array of property names of all enumerable properties,
   * own and inherited, of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function(value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if the specified property name exists as a direct property of `object`,
   * instead of an inherited property.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @param {string} key The name of the property to check.
   * @returns {boolean} Returns `true` if key is a direct property, else `false`.
   * @example
   *
   * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
   * // => true
   */
  function has(object, key) {
    return object ? hasOwnProperty.call(object, key) : false;
  }

  /**
   * Creates an object composed of the inverted keys and values of the given object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to invert.
   * @returns {Object} Returns the created inverted object.
   * @example
   *
   * _.invert({ 'first': 'fred', 'second': 'barney' });
   * // => { 'fred': 'first', 'barney': 'second' }
   */
  function invert(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index];
      result[object[key]] = key;
    }
    return result;
  }

  /**
   * Checks if `value` is a boolean value.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
   * @example
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false ||
      value && typeof value == 'object' && toString.call(value) == boolClass || false;
  }

  /**
   * Checks if `value` is a date.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // => true
   */
  function isDate(value) {
    return value && typeof value == 'object' && toString.call(value) == dateClass || false;
  }

  /**
   * Checks if `value` is a DOM element.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
   * @example
   *
   * _.isElement(document.body);
   * // => true
   */
  function isElement(value) {
    return value && value.nodeType === 1 || false;
  }

  /**
   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
   * length of `0` and objects with no own enumerable properties are considered
   * "empty".
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Array|Object|string} value The value to inspect.
   * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({});
   * // => true
   *
   * _.isEmpty('');
   * // => true
   */
  function isEmpty(value) {
    if (!value) {
      return true;
    }
    if (isArray(value) || isString(value)) {
      return !value.length;
    }
    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent to each other. If a callback is provided it will be executed
   * to compare values. If the callback returns `undefined` comparisons will
   * be handled by the method instead. The callback is bound to `thisArg` and
   * invoked with two arguments; (a, b).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * var copy = { 'name': 'fred' };
   *
   * object == copy;
   * // => false
   *
   * _.isEqual(object, copy);
   * // => true
   *
   * var words = ['hello', 'goodbye'];
   * var otherWords = ['hi', 'goodbye'];
   *
   * _.isEqual(words, otherWords, function(a, b) {
   *   var reGreet = /^(?:hello|hi)$/i,
   *       aGreet = _.isString(a) && reGreet.test(a),
   *       bGreet = _.isString(b) && reGreet.test(b);
   *
   *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
   * });
   * // => true
   */
  function isEqual(a, b) {
    return baseIsEqual(a, b);
  }

  /**
   * Checks if `value` is, or can be coerced to, a finite number.
   *
   * Note: This is not the same as native `isFinite` which will return true for
   * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
   * @example
   *
   * _.isFinite(-101);
   * // => true
   *
   * _.isFinite('10');
   * // => true
   *
   * _.isFinite(true);
   * // => false
   *
   * _.isFinite('');
   * // => false
   *
   * _.isFinite(Infinity);
   * // => false
   */
  function isFinite(value) {
    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value == 'function' && toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.io/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return !!(value && objectTypes[typeof value]);
  }

  /**
   * Checks if `value` is `NaN`.
   *
   * Note: This is not the same as native `isNaN` which will return `true` for
   * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN(value) {
    // `NaN` as a primitive is the only value that is not equal to itself
    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
    return isNumber(value) && value != +value;
  }

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(undefined);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is a number.
   *
   * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(8.4 * 5);
   * // => true
   */
  function isNumber(value) {
    return typeof value == 'number' ||
      value && typeof value == 'object' && toString.call(value) == numberClass || false;
  }

  /**
   * Checks if `value` is a regular expression.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
   * @example
   *
   * _.isRegExp(/fred/);
   * // => true
   */
  function isRegExp(value) {
    return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('fred');
   * // => true
   */
  function isString(value) {
    return typeof value == 'string' ||
      value && typeof value == 'object' && toString.call(value) == stringClass || false;
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   */
  function isUndefined(value) {
    return typeof value == 'undefined';
  }

  /**
   * Creates a shallow clone of `object` excluding the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If a callback is provided it will be executed for each
   * property of `object` omitting the properties the callback returns truey
   * for. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|...string|string[]} [callback] The properties to omit or the
   *  function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object without the omitted properties.
   * @example
   *
   * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
   * // => { 'name': 'fred' }
   *
   * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
   *   return typeof value == 'number';
   * });
   * // => { 'name': 'fred' }
   */
  function omit(object) {
    var props = [];
    forIn(object, function(value, key) {
      props.push(key);
    });
    props = baseDifference(props, baseFlatten(arguments, true, false, 1));

    var index = -1,
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index];
      result[key] = object[key];
    }
    return result;
  }

  /**
   * Creates a two dimensional array of an object's key-value pairs,
   * i.e. `[[key1, value1], [key2, value2]]`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns new array of key-value pairs.
   * @example
   *
   * _.pairs({ 'barney': 36, 'fred': 40 });
   * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
   */
  function pairs(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

    while (++index < length) {
      var key = props[index];
      result[index] = [key, object[key]];
    }
    return result;
  }

  /**
   * Creates a shallow clone of `object` composed of the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If a callback is provided it will be executed for each
   * property of `object` picking the properties the callback returns truey
   * for. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|...string|string[]} [callback] The function called per
   *  iteration or property names to pick, specified as individual property
   *  names or arrays of property names.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object composed of the picked properties.
   * @example
   *
   * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
   * // => { 'name': 'fred' }
   *
   * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
   *   return key.charAt(0) != '_';
   * });
   * // => { 'name': 'fred' }
   */
  function pick(object) {
    var index = -1,
        props = baseFlatten(arguments, true, false, 1),
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index];
      if (key in object) {
        result[key] = object[key];
      }
    }
    return result;
  }

  /**
   * Creates an array composed of the own enumerable property values of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property values.
   * @example
   *
   * _.values({ 'one': 1, 'two': 2, 'three': 3 });
   * // => [1, 2, 3] (property order is not guaranteed across environments)
   */
  function values(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

    while (++index < length) {
      result[index] = object[props[index]];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if a given value is present in a collection using strict equality
   * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
   * offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @alias include
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {*} target The value to check for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
   * @example
   *
   * _.contains([1, 2, 3], 1);
   * // => true
   *
   * _.contains([1, 2, 3], 1, 2);
   * // => false
   *
   * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
   * // => true
   *
   * _.contains('pebbles', 'eb');
   * // => true
   */
  function contains(collection, target) {
    var indexOf = getIndexOf(),
        length = collection ? collection.length : 0,
        result = false;
    if (length && typeof length == 'number') {
      result = indexOf(collection, target) > -1;
    } else {
      forOwn(collection, function(value) {
        return (result = value === target) && indicatorObject;
      });
    }
    return result;
  }

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` through the callback. The corresponding value
   * of each key is the number of times the key was returned by the callback.
   * The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // => { '4': 1, '6': 2 }
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // => { '4': 1, '6': 2 }
   *
   * _.countBy(['one', 'two', 'three'], 'length');
   * // => { '3': 2, '5': 1 }
   */
  var countBy = createAggregator(function(result, value, key) {
    (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
  });

  /**
   * Checks if the given callback returns truey value for **all** elements of
   * a collection. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias all
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if all elements passed the callback check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes']);
   * // => false
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.every(characters, 'age');
   * // => true
   *
   * // using "_.where" callback shorthand
   * _.every(characters, { 'age': 36 });
   * // => false
   */
  function every(collection, callback, thisArg) {
    var result = true;
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == 'number') {
      while (++index < length) {
        if (!(result = !!callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        return !(result = !!callback(value, index, collection)) && indicatorObject;
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning an array of all elements
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [2, 4, 6]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.filter(characters, 'blocked');
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   *
   * // using "_.where" callback shorthand
   * _.filter(characters, { 'age': 36 });
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == 'number') {
      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          result.push(value);
        }
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result.push(value);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning the first element that
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias detect, findWhere
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36, 'blocked': false },
   *   { 'name': 'fred',    'age': 40, 'blocked': true },
   *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
   * ];
   *
   * _.find(characters, function(chr) {
   *   return chr.age < 40;
   * });
   * // => { 'name': 'barney', 'age': 36, 'blocked': false }
   *
   * // using "_.where" callback shorthand
   * _.find(characters, { 'age': 1 });
   * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
   *
   * // using "_.pluck" callback shorthand
   * _.find(characters, 'blocked');
   * // => { 'name': 'fred', 'age': 40, 'blocked': true }
   */
  function find(collection, callback, thisArg) {
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == 'number') {
      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          return value;
        }
      }
    } else {
      var result;
      forOwn(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return indicatorObject;
        }
      });
      return result;
    }
  }

  /**
   * Examines each element in a `collection`, returning the first that
   * has the given properties. When checking `properties`, this method
   * performs a deep comparison between values to determine if they are
   * equivalent to each other.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Object} properties The object of property values to filter by.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var food = [
   *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
   *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
   *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }
   * ];
   *
   * _.findWhere(food, { 'type': 'vegetable' });
   * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
   */
  function findWhere(object, properties) {
    return where(object, properties, true);
  }

  /**
   * Iterates over elements of a collection, executing the callback for each
   * element. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * Note: As with other "Collections" methods, objects with a `length` property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
   * // => logs each number and returns '1,2,3'
   *
   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
   * // => logs each number and returns the object (property order is not guaranteed across environments)
   */
  function forEach(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0;

    callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
    if (typeof length == 'number') {
      while (++index < length) {
        if (callback(collection[index], index, collection) === indicatorObject) {
          break;
        }
      }
    } else {
      forOwn(collection, callback);
    }
  }

  /**
   * This method is like `_.forEach` except that it iterates over elements
   * of a `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @alias eachRight
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
   * // => logs each number from right to left and returns '3,2,1'
   */
  function forEachRight(collection, callback) {
    var length = collection ? collection.length : 0;
    if (typeof length == 'number') {
      while (length--) {
        if (callback(collection[length], length, collection) === false) {
          break;
        }
      }
    } else {
      var props = keys(collection);
      length = props.length;
      forOwn(collection, function(value, key, collection) {
        key = props ? props[--length] : --length;
        return callback(collection[key], key, collection) === false && indicatorObject;
      });
    }
  }

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of a collection through the callback. The corresponding value
   * of each key is an array of the elements responsible for generating the key.
   * The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // => { '4': [4.2], '6': [6.1, 6.4] }
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // => { '4': [4.2], '6': [6.1, 6.4] }
   *
   * // using "_.pluck" callback shorthand
   * _.groupBy(['one', 'two', 'three'], 'length');
   * // => { '3': ['one', 'two'], '5': ['three'] }
   */
  var groupBy = createAggregator(function(result, value, key) {
    (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
  });

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of the collection through the given callback. The corresponding
   * value of each key is the last element responsible for generating the key.
   * The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * var keys = [
   *   { 'dir': 'left', 'code': 97 },
   *   { 'dir': 'right', 'code': 100 }
   * ];
   *
   * _.indexBy(keys, 'dir');
   * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
   *
   * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
   * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
   *
   * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
   * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
   */
  var indexBy = createAggregator(function(result, value, key) {
    result[key] = value;
  });

  /**
   * Invokes the method named by `methodName` on each element in the `collection`
   * returning an array of the results of each invoked method. Additional arguments
   * will be provided to each invoked method. If `methodName` is a function it
   * will be invoked for, and `this` bound to, each element in the `collection`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|string} methodName The name of the method to invoke or
   *  the function invoked per iteration.
   * @param {...*} [arg] Arguments to invoke the method with.
   * @returns {Array} Returns a new array of the results of each invoked method.
   * @example
   *
   * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
   * // => [[1, 5, 7], [1, 2, 3]]
   *
   * _.invoke([123, 456], String.prototype.split, '');
   * // => [['1', '2', '3'], ['4', '5', '6']]
   */
  function invoke(collection, methodName) {
    var args = slice(arguments, 2),
        index = -1,
        isFunc = typeof methodName == 'function',
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    forEach(collection, function(value) {
      result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
    });
    return result;
  }

  /**
   * Creates an array of values by running each element in the collection
   * through the callback. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // => [3, 6, 9]
   *
   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
   * // => [3, 6, 9] (property order is not guaranteed across environments)
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(characters, 'name');
   * // => ['barney', 'fred']
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0;

    callback = createCallback(callback, thisArg, 3);
    if (typeof length == 'number') {
      var result = Array(length);
      while (++index < length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      result = [];
      forOwn(collection, function(value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * Retrieves the maximum value of a collection. If the collection is empty or
   * falsey `-Infinity` is returned. If a callback is provided it will be executed
   * for each value in the collection to generate the criterion by which the value
   * is ranked. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * _.max(characters, function(chr) { return chr.age; });
   * // => { 'name': 'fred', 'age': 40 };
   *
   * // using "_.pluck" callback shorthand
   * _.max(characters, 'age');
   * // => { 'name': 'fred', 'age': 40 };
   */
  function max(collection, callback, thisArg) {
    var computed = -Infinity,
        result = computed;

    // allows working with functions like `_.map` without using
    // their `index` argument as a callback
    if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
      callback = null;
    }
    var index = -1,
        length = collection ? collection.length : 0;

    if (callback == null && typeof length == 'number') {
      while (++index < length) {
        var value = collection[index];
        if (value > result) {
          result = value;
        }
      }
    } else {
      callback = createCallback(callback, thisArg, 3);

      forEach(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current > computed) {
          computed = current;
          result = value;
        }
      });
    }
    return result;
  }

  /**
   * Retrieves the minimum value of a collection. If the collection is empty or
   * falsey `Infinity` is returned. If a callback is provided it will be executed
   * for each value in the collection to generate the criterion by which the value
   * is ranked. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * _.min(characters, function(chr) { return chr.age; });
   * // => { 'name': 'barney', 'age': 36 };
   *
   * // using "_.pluck" callback shorthand
   * _.min(characters, 'age');
   * // => { 'name': 'barney', 'age': 36 };
   */
  function min(collection, callback, thisArg) {
    var computed = Infinity,
        result = computed;

    // allows working with functions like `_.map` without using
    // their `index` argument as a callback
    if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
      callback = null;
    }
    var index = -1,
        length = collection ? collection.length : 0;

    if (callback == null && typeof length == 'number') {
      while (++index < length) {
        var value = collection[index];
        if (value < result) {
          result = value;
        }
      }
    } else {
      callback = createCallback(callback, thisArg, 3);

      forEach(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current < computed) {
          computed = current;
          result = value;
        }
      });
    }
    return result;
  }

  /**
   * Retrieves the value of a specified property from all elements in the collection.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {string} property The name of the property to pluck.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * _.pluck(characters, 'name');
   * // => ['barney', 'fred']
   */
  var pluck = map;

  /**
   * Reduces a collection to a value which is the accumulated result of running
   * each element in the collection through the callback, where each successive
   * callback execution consumes the return value of the previous execution. If
   * `accumulator` is not provided the first element of the collection will be
   * used as the initial `accumulator` value. The callback is bound to `thisArg`
   * and invoked with four arguments; (accumulator, value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias foldl, inject
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [accumulator] Initial value of the accumulator.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the accumulated value.
   * @example
   *
   * var sum = _.reduce([1, 2, 3], function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
   *   result[key] = num * 3;
   *   return result;
   * }, {});
   * // => { 'a': 3, 'b': 6, 'c': 9 }
   */
  function reduce(collection, callback, accumulator, thisArg) {
    if (!collection) return accumulator;
    var noaccum = arguments.length < 3;
    callback = createCallback(callback, thisArg, 4);

    var index = -1,
        length = collection.length;

    if (typeof length == 'number') {
      if (noaccum) {
        accumulator = collection[++index];
      }
      while (++index < length) {
        accumulator = callback(accumulator, collection[index], index, collection);
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection)
      });
    }
    return accumulator;
  }

  /**
   * This method is like `_.reduce` except that it iterates over elements
   * of a `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @alias foldr
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [accumulator] Initial value of the accumulator.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the accumulated value.
   * @example
   *
   * var list = [[0, 1], [2, 3], [4, 5]];
   * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
   * // => [4, 5, 2, 3, 0, 1]
   */
  function reduceRight(collection, callback, accumulator, thisArg) {
    var noaccum = arguments.length < 3;
    callback = createCallback(callback, thisArg, 4);
    forEachRight(collection, function(value, index, collection) {
      accumulator = noaccum
        ? (noaccum = false, value)
        : callback(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The opposite of `_.filter` this method returns the elements of a
   * collection that the callback does **not** return truey for.
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that failed the callback check.
   * @example
   *
   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [1, 3, 5]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.reject(characters, 'blocked');
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   *
   * // using "_.where" callback shorthand
   * _.reject(characters, { 'age': 36 });
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   */
  function reject(collection, callback, thisArg) {
    callback = createCallback(callback, thisArg, 3);
    return filter(collection, function(value, index, collection) {
      return !callback(value, index, collection);
    });
  }

  /**
   * Retrieves a random element or `n` random elements from a collection.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to sample.
   * @param {number} [n] The number of elements to sample.
   * @param- {Object} [guard] Allows working with functions like `_.map`
   *  without using their `index` arguments as `n`.
   * @returns {Array} Returns the random sample(s) of `collection`.
   * @example
   *
   * _.sample([1, 2, 3, 4]);
   * // => 2
   *
   * _.sample([1, 2, 3, 4], 2);
   * // => [3, 1]
   */
  function sample(collection, n, guard) {
    if (collection && typeof collection.length != 'number') {
      collection = values(collection);
    }
    if (n == null || guard) {
      return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
    }
    var result = shuffle(collection);
    result.length = nativeMin(nativeMax(0, n), result.length);
    return result;
  }

  /**
   * Creates an array of shuffled values, using a version of the Fisher-Yates
   * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to shuffle.
   * @returns {Array} Returns a new shuffled collection.
   * @example
   *
   * _.shuffle([1, 2, 3, 4, 5, 6]);
   * // => [4, 1, 6, 3, 5, 2]
   */
  function shuffle(collection) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    forEach(collection, function(value) {
      var rand = baseRandom(0, ++index);
      result[index] = result[rand];
      result[rand] = value;
    });
    return result;
  }

  /**
   * Gets the size of the `collection` by returning `collection.length` for arrays
   * and array-like objects or the number of own enumerable properties for objects.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns `collection.length` or number of own enumerable properties.
   * @example
   *
   * _.size([1, 2]);
   * // => 2
   *
   * _.size({ 'one': 1, 'two': 2, 'three': 3 });
   * // => 3
   *
   * _.size('pebbles');
   * // => 7
   */
  function size(collection) {
    var length = collection ? collection.length : 0;
    return typeof length == 'number' ? length : keys(collection).length;
  }

  /**
   * Checks if the callback returns a truey value for **any** element of a
   * collection. The function returns as soon as it finds a passing value and
   * does not iterate over the entire collection. The callback is bound to
   * `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias any
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if any element passed the callback check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.some(characters, 'blocked');
   * // => true
   *
   * // using "_.where" callback shorthand
   * _.some(characters, { 'age': 1 });
   * // => false
   */
  function some(collection, callback, thisArg) {
    var result;
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == 'number') {
      while (++index < length) {
        if ((result = callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        return (result = callback(value, index, collection)) && indicatorObject;
      });
    }
    return !!result;
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection through the callback. This method
   * performs a stable sort, that is, it will preserve the original sort order
   * of equal elements. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an array of property names is provided for `callback` the collection
   * will be sorted by each property value.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Array|Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of sorted elements.
   * @example
   *
   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
   * // => [3, 1, 2]
   *
   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
   * // => [3, 1, 2]
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36 },
   *   { 'name': 'fred',    'age': 40 },
   *   { 'name': 'barney',  'age': 26 },
   *   { 'name': 'fred',    'age': 30 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(_.sortBy(characters, 'age'), _.values);
   * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
   *
   * // sorting by multiple properties
   * _.map(_.sortBy(characters, ['name', 'age']), _.values);
   * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
   */
  function sortBy(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    callback = createCallback(callback, thisArg, 3);
    forEach(collection, function(value, key, collection) {
      result[++index] = {
        'criteria': [callback(value, key, collection)],
        'index': index,
        'value': value
      };
    });

    length = result.length;
    result.sort(compareAscending);
    while (length--) {
      result[length] = result[length].value;
    }
    return result;
  }

  /**
   * Converts the `collection` to an array.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to convert.
   * @returns {Array} Returns the new converted array.
   * @example
   *
   * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
   * // => [2, 3, 4]
   */
  function toArray(collection) {
    if (isArray(collection)) {
      return slice(collection);
    }
    if (collection && typeof collection.length == 'number') {
      return map(collection);
    }
    return values(collection);
  }

  /**
   * Performs a deep comparison of each element in a `collection` to the given
   * `properties` object, returning an array of all elements that have equivalent
   * property values.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Object} props The object of property values to filter by.
   * @returns {Array} Returns a new array of elements that have the given properties.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
   *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
   * ];
   *
   * _.where(characters, { 'age': 36 });
   * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
   *
   * _.where(characters, { 'pets': ['dino'] });
   * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
   */
  function where(collection, properties, first) {
    return (first && isEmpty(properties))
      ? undefined
      : (first ? find : filter)(collection, properties);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are all falsey.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to compact.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates an array excluding all values of the provided arrays using strict
   * equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {...Array} [values] The arrays of values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
   * // => [1, 3, 4]
   */
  function difference(array) {
    return baseDifference(array, baseFlatten(arguments, true, true, 1));
  }

  /**
   * Gets the first element or first `n` elements of an array. If a callback
   * is provided elements at the beginning of the array are returned as long
   * as the callback returns truey. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias head, take
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback] The function called
   *  per element or the number of elements to return. If a property name or
   *  object is provided it will be used to create a "_.pluck" or "_.where"
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the first element(s) of `array`.
   * @example
   *
   * _.first([1, 2, 3]);
   * // => 1
   *
   * _.first([1, 2, 3], 2);
   * // => [1, 2]
   *
   * _.first([1, 2, 3], function(num) {
   *   return num < 3;
   * });
   * // => [1, 2]
   *
   * var characters = [
   *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
   *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
   *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.first(characters, 'blocked');
   * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
   *
   * // using "_.where" callback shorthand
   * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
   * // => ['barney', 'fred']
   */
  function first(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != 'number' && callback != null) {
      var index = -1;
      callback = createCallback(callback, thisArg, 3);
      while (++index < length && callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = callback;
      if (n == null || thisArg) {
        return array ? array[0] : undefined;
      }
    }
    return slice(array, 0, nativeMin(nativeMax(0, n), length));
  }

  /**
   * Flattens a nested array (the nesting can be to any depth). If `isShallow`
   * is truey, the array will only be flattened a single level. If a callback
   * is provided each element of the array is passed through the callback before
   * flattening. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // => [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // => [1, 2, 3, [[4]]];
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
   *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.flatten(characters, 'pets');
   * // => ['hoppy', 'baby puss', 'dino']
   */
  function flatten(array, isShallow) {
    return baseFlatten(array, isShallow);
  }

  /**
   * Gets the index at which the first occurrence of `value` is found using
   * strict equality for comparisons, i.e. `===`. If the array is already sorted
   * providing `true` for `fromIndex` will run a faster binary search.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {boolean|number} [fromIndex=0] The index to search from or `true`
   *  to perform a binary search on a sorted array.
   * @returns {number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 1
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 4
   *
   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
   * // => 2
   */
  function indexOf(array, value, fromIndex) {
    if (typeof fromIndex == 'number') {
      var length = array ? array.length : 0;
      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
    } else if (fromIndex) {
      var index = sortedIndex(array, value);
      return array[index] === value ? index : -1;
    }
    return baseIndexOf(array, value, fromIndex);
  }

  /**
   * Gets all but the last element or last `n` elements of an array. If a
   * callback is provided elements at the end of the array are excluded from
   * the result as long as the callback returns truey. The callback is bound
   * to `thisArg` and invoked with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback=1] The function called
   *  per element or the number of elements to exclude. If a property name or
   *  object is provided it will be used to create a "_.pluck" or "_.where"
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a slice of `array`.
   * @example
   *
   * _.initial([1, 2, 3]);
   * // => [1, 2]
   *
   * _.initial([1, 2, 3], 2);
   * // => [1]
   *
   * _.initial([1, 2, 3], function(num) {
   *   return num > 1;
   * });
   * // => [1]
   *
   * var characters = [
   *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
   *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
   *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.initial(characters, 'blocked');
   * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
   *
   * // using "_.where" callback shorthand
   * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
   * // => ['barney', 'fred']
   */
  function initial(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != 'number' && callback != null) {
      var index = length;
      callback = createCallback(callback, thisArg, 3);
      while (index-- && callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = (callback == null || thisArg) ? 1 : callback || n;
    }
    return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
  }

  /**
   * Creates an array of unique values present in all provided arrays using
   * strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {...Array} [array] The arrays to inspect.
   * @returns {Array} Returns an array of shared values.
   * @example
   *
   * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
   * // => [1, 2]
   */
  function intersection() {
    var args = [],
        argsIndex = -1,
        argsLength = arguments.length;

    while (++argsIndex < argsLength) {
      var value = arguments[argsIndex];
       if (isArray(value) || isArguments(value)) {
         args.push(value);
       }
    }
    var array = args[0],
        index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    outer:
    while (++index < length) {
      value = array[index];
      if (indexOf(result, value) < 0) {
        var argsIndex = argsLength;
        while (--argsIndex) {
          if (indexOf(args[argsIndex], value) < 0) {
            continue outer;
          }
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the last element or last `n` elements of an array. If a callback is
   * provided elements at the end of the array are returned as long as the
   * callback returns truey. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback] The function called
   *  per element or the number of elements to return. If a property name or
   *  object is provided it will be used to create a "_.pluck" or "_.where"
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the last element(s) of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   *
   * _.last([1, 2, 3], 2);
   * // => [2, 3]
   *
   * _.last([1, 2, 3], function(num) {
   *   return num > 1;
   * });
   * // => [2, 3]
   *
   * var characters = [
   *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
   *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
   *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.pluck(_.last(characters, 'blocked'), 'name');
   * // => ['fred', 'pebbles']
   *
   * // using "_.where" callback shorthand
   * _.last(characters, { 'employer': 'na' });
   * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
   */
  function last(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != 'number' && callback != null) {
      var index = length;
      callback = createCallback(callback, thisArg, 3);
      while (index-- && callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = callback;
      if (n == null || thisArg) {
        return array ? array[length - 1] : undefined;
      }
    }
    return slice(array, nativeMax(0, length - n));
  }

  /**
   * Gets the index at which the last occurrence of `value` is found using strict
   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
   * as the offset from the end of the collection.
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=array.length-1] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 4
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 1
   */
  function lastIndexOf(array, value, fromIndex) {
    var index = array ? array.length : 0;
    if (typeof fromIndex == 'number') {
      index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
    }
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to but not including `end`. If `start` is less than `stop` a
   * zero-length range is created unless a negative `step` is specified.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {number} [start=0] The start of the range.
   * @param {number} end The end of the range.
   * @param {number} [step=1] The value to increment or decrement by.
   * @returns {Array} Returns a new range array.
   * @example
   *
   * _.range(4);
   * // => [0, 1, 2, 3]
   *
   * _.range(1, 5);
   * // => [1, 2, 3, 4]
   *
   * _.range(0, 20, 5);
   * // => [0, 5, 10, 15]
   *
   * _.range(0, -4, -1);
   * // => [0, -1, -2, -3]
   *
   * _.range(1, 4, 0);
   * // => [1, 1, 1]
   *
   * _.range(0);
   * // => []
   */
  function range(start, end, step) {
    start = +start || 0;
    step =  (+step || 1);

    if (end == null) {
      end = start;
      start = 0;
    }
    // use `Array(length)` so engines like Chakra and V8 avoid slower modes
    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
    var index = -1,
        length = nativeMax(0, ceil((end - start) / step)),
        result = Array(length);

    while (++index < length) {
      result[index] = start;
      start += step;
    }
    return result;
  }

  /**
   * The opposite of `_.initial` this method gets all but the first element or
   * first `n` elements of an array. If a callback function is provided elements
   * at the beginning of the array are excluded from the result as long as the
   * callback returns truey. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias drop, tail
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback=1] The function called
   *  per element or the number of elements to exclude. If a property name or
   *  object is provided it will be used to create a "_.pluck" or "_.where"
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a slice of `array`.
   * @example
   *
   * _.rest([1, 2, 3]);
   * // => [2, 3]
   *
   * _.rest([1, 2, 3], 2);
   * // => [3]
   *
   * _.rest([1, 2, 3], function(num) {
   *   return num < 3;
   * });
   * // => [3]
   *
   * var characters = [
   *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
   *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
   *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.pluck(_.rest(characters, 'blocked'), 'name');
   * // => ['fred', 'pebbles']
   *
   * // using "_.where" callback shorthand
   * _.rest(characters, { 'employer': 'slate' });
   * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
   */
  function rest(array, callback, thisArg) {
    if (typeof callback != 'number' && callback != null) {
      var n = 0,
          index = -1,
          length = array ? array.length : 0;

      callback = createCallback(callback, thisArg, 3);
      while (++index < length && callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
    }
    return slice(array, n);
  }

  /**
   * Uses a binary search to determine the smallest index at which a value
   * should be inserted into a given sorted array in order to maintain the sort
   * order of the array. If a callback is provided it will be executed for
   * `value` and each element of `array` to compute their sort ranking. The
   * callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to inspect.
   * @param {*} value The value to evaluate.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {number} Returns the index at which `value` should be inserted
   *  into `array`.
   * @example
   *
   * _.sortedIndex([20, 30, 50], 40);
   * // => 2
   *
   * // using "_.pluck" callback shorthand
   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
   * // => 2
   *
   * var dict = {
   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
   * };
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return dict.wordToNumber[word];
   * });
   * // => 2
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return this.wordToNumber[word];
   * }, dict);
   * // => 2
   */
  function sortedIndex(array, value, callback, thisArg) {
    var low = 0,
        high = array ? array.length : low;

    // explicitly reference `identity` for better inlining in Firefox
    callback = callback ? createCallback(callback, thisArg, 1) : identity;
    value = callback(value);

    while (low < high) {
      var mid = (low + high) >>> 1;
      (callback(array[mid]) < value)
        ? low = mid + 1
        : high = mid;
    }
    return low;
  }

  /**
   * Creates an array of unique values, in order, of the provided arrays using
   * strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {...Array} [array] The arrays to inspect.
   * @returns {Array} Returns an array of combined values.
   * @example
   *
   * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
   * // => [1, 2, 3, 5, 4]
   */
  function union() {
    return baseUniq(baseFlatten(arguments, true, true));
  }

  /**
   * Creates a duplicate-value-free version of an array using strict equality
   * for comparisons, i.e. `===`. If the array is sorted, providing
   * `true` for `isSorted` will use a faster algorithm. If a callback is provided
   * each element of `array` is passed through the callback before uniqueness
   * is computed. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias unique
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a duplicate-value-free array.
   * @example
   *
   * _.uniq([1, 2, 1, 3, 1]);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 1, 2, 2, 3], true);
   * // => [1, 2, 3]
   *
   * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
   * // => ['A', 'b', 'C']
   *
   * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
   * // => [1, 2.5, 3]
   *
   * // using "_.pluck" callback shorthand
   * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  function uniq(array, isSorted, callback, thisArg) {
    // juggle arguments
    if (typeof isSorted != 'boolean' && isSorted != null) {
      thisArg = callback;
      callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
      isSorted = false;
    }
    if (callback != null) {
      callback = createCallback(callback, thisArg, 3);
    }
    return baseUniq(array, isSorted, callback);
  }

  /**
   * Creates an array excluding all provided values using strict equality for
   * comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to filter.
   * @param {...*} [value] The values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
   * // => [2, 3, 4]
   */
  function without(array) {
    return baseDifference(array, slice(arguments, 1));
  }

  /**
   * Creates an array of grouped elements, the first of which contains the first
   * elements of the given arrays, the second of which contains the second
   * elements of the given arrays, and so on.
   *
   * @static
   * @memberOf _
   * @alias unzip
   * @category Arrays
   * @param {...Array} [array] Arrays to process.
   * @returns {Array} Returns a new array of grouped elements.
   * @example
   *
   * _.zip(['fred', 'barney'], [30, 40], [true, false]);
   * // => [['fred', 30, true], ['barney', 40, false]]
   */
  function zip() {
    var index = -1,
        length = max(pluck(arguments, 'length')),
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = pluck(arguments, index);
    }
    return result;
  }

  /**
   * Creates an object composed from arrays of `keys` and `values`. Provide
   * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
   * or two arrays, one of `keys` and one of corresponding `values`.
   *
   * @static
   * @memberOf _
   * @alias object
   * @category Arrays
   * @param {Array} keys The array of keys.
   * @param {Array} [values=[]] The array of values.
   * @returns {Object} Returns an object composed of the given keys and
   *  corresponding values.
   * @example
   *
   * _.zipObject(['fred', 'barney'], [30, 40]);
   * // => { 'fred': 30, 'barney': 40 }
   */
  function zipObject(keys, values) {
    var index = -1,
        length = keys ? keys.length : 0,
        result = {};

    if (!values && length && !isArray(keys[0])) {
      values = [];
    }
    while (++index < length) {
      var key = keys[index];
      if (values) {
        result[key] = values[index];
      } else if (key) {
        result[key[0]] = key[1];
      }
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that executes `func`, with  the `this` binding and
   * arguments of the created function, only after being called `n` times.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {number} n The number of times the function must be called before
   *  `func` is executed.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var saves = ['profile', 'settings'];
   *
   * var done = _.after(saves.length, function() {
   *   console.log('Done saving!');
   * });
   *
   * _.forEach(saves, function(type) {
   *   asyncSave({ 'type': type, 'complete': done });
   * });
   * // => logs 'Done saving!', after all saves have completed
   */
  function after(n, func) {
    if (!isFunction(func)) {
      throw new TypeError;
    }
    return function() {
      if (--n < 1) {
        return func.apply(this, arguments);
      }
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * provided to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'fred' }, 'hi');
   * func();
   * // => 'hi fred'
   */
  function bind(func, thisArg) {
    return arguments.length > 2
      ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
      : createWrapper(func, 1, null, null, thisArg);
  }

  /**
   * Binds methods of an object to the object itself, overwriting the existing
   * method. Method names may be specified as individual arguments or as arrays
   * of method names. If no method names are provided all the function properties
   * of `object` will be bound.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object to bind and assign the bound methods to.
   * @param {...string} [methodName] The object method names to
   *  bind, specified as individual method names or arrays of method names.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var view = {
   *   'label': 'docs',
   *   'onClick': function() { console.log('clicked ' + this.label); }
   * };
   *
   * _.bindAll(view);
   * jQuery('#docs').on('click', view.onClick);
   * // => logs 'clicked docs', when the button is clicked
   */
  function bindAll(object) {
    var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
        index = -1,
        length = funcs.length;

    while (++index < length) {
      var key = funcs[index];
      object[key] = createWrapper(object[key], 1, null, null, object);
    }
    return object;
  }

  /**
   * Creates a function that is the composition of the provided functions,
   * where each function consumes the return value of the function that follows.
   * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
   * Each function is executed with the `this` binding of the composed function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {...Function} [func] Functions to compose.
   * @returns {Function} Returns the new composed function.
   * @example
   *
   * var realNameMap = {
   *   'pebbles': 'penelope'
   * };
   *
   * var format = function(name) {
   *   name = realNameMap[name.toLowerCase()] || name;
   *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
   * };
   *
   * var greet = function(formatted) {
   *   return 'Hiya ' + formatted + '!';
   * };
   *
   * var welcome = _.compose(greet, format);
   * welcome('pebbles');
   * // => 'Hiya Penelope!'
   */
  function compose() {
    var funcs = arguments,
        length = funcs.length;

    while (length--) {
      if (!isFunction(funcs[length])) {
        throw new TypeError;
      }
    }
    return function() {
      var args = arguments,
          length = funcs.length;

      while (length--) {
        args = [funcs[length].apply(this, args)];
      }
      return args[0];
    };
  }

  /**
   * Creates a function that will delay the execution of `func` until after
   * `wait` milliseconds have elapsed since the last time it was invoked.
   * Provide an options object to indicate that `func` should be invoked on
   * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
   * to the debounced function will return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the debounced function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to debounce.
   * @param {number} wait The number of milliseconds to delay.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
   * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // avoid costly calculations while the window size is in flux
   * var lazyLayout = _.debounce(calculateLayout, 150);
   * jQuery(window).on('resize', lazyLayout);
   *
   * // execute `sendMail` when the click event is fired, debouncing subsequent calls
   * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * });
   *
   * // ensure `batchLog` is executed once after 1 second of debounced calls
   * var source = new EventSource('/stream');
   * source.addEventListener('message', _.debounce(batchLog, 250, {
   *   'maxWait': 1000
   * }, false);
   */
  function debounce(func, wait, options) {
    var args,
        maxTimeoutId,
        result,
        stamp,
        thisArg,
        timeoutId,
        trailingCall,
        lastCalled = 0,
        maxWait = false,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError;
    }
    wait = nativeMax(0, wait) || 0;
    if (options === true) {
      var leading = true;
      trailing = false;
    } else if (isObject(options)) {
      leading = options.leading;
      maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
      trailing = 'trailing' in options ? options.trailing : trailing;
    }
    var delayed = function() {
      var remaining = wait - (now() - stamp);
      if (remaining <= 0) {
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        var isCalled = trailingCall;
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      } else {
        timeoutId = setTimeout(delayed, remaining);
      }
    };

    var maxDelayed = function() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (trailing || (maxWait !== wait)) {
        lastCalled = now();
        result = func.apply(thisArg, args);
        if (!timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
      }
    };

    return function() {
      args = arguments;
      stamp = now();
      thisArg = this;
      trailingCall = trailing && (timeoutId || !leading);

      if (maxWait === false) {
        var leadingCall = leading && !timeoutId;
      } else {
        if (!maxTimeoutId && !leading) {
          lastCalled = stamp;
        }
        var remaining = maxWait - (stamp - lastCalled),
            isCalled = remaining <= 0;

        if (isCalled) {
          if (maxTimeoutId) {
            maxTimeoutId = clearTimeout(maxTimeoutId);
          }
          lastCalled = stamp;
          result = func.apply(thisArg, args);
        }
        else if (!maxTimeoutId) {
          maxTimeoutId = setTimeout(maxDelayed, remaining);
        }
      }
      if (isCalled && timeoutId) {
        timeoutId = clearTimeout(timeoutId);
      }
      else if (!timeoutId && wait !== maxWait) {
        timeoutId = setTimeout(delayed, wait);
      }
      if (leadingCall) {
        isCalled = true;
        result = func.apply(thisArg, args);
      }
      if (isCalled && !timeoutId && !maxTimeoutId) {
        args = thisArg = null;
      }
      return result;
    };
  }

  /**
   * Defers executing the `func` function until the current call stack has cleared.
   * Additional arguments will be provided to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to defer.
   * @param {...*} [arg] Arguments to invoke the function with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.defer(function(text) { console.log(text); }, 'deferred');
   * // logs 'deferred' after one or more milliseconds
   */
  function defer(func) {
    if (!isFunction(func)) {
      throw new TypeError;
    }
    var args = slice(arguments, 1);
    return setTimeout(function() { func.apply(undefined, args); }, 1);
  }

  /**
   * Executes the `func` function after `wait` milliseconds. Additional arguments
   * will be provided to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay execution.
   * @param {...*} [arg] Arguments to invoke the function with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.delay(function(text) { console.log(text); }, 1000, 'later');
   * // => logs 'later' after one second
   */
  function delay(func, wait) {
    if (!isFunction(func)) {
      throw new TypeError;
    }
    var args = slice(arguments, 2);
    return setTimeout(function() { func.apply(undefined, args); }, wait);
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided it will be used to determine the cache key for storing the result
   * based on the arguments provided to the memoized function. By default, the
   * first argument provided to the memoized function is used as the cache key.
   * The `func` is executed with the `this` binding of the memoized function.
   * The result cache is exposed as the `cache` property on the memoized function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] A function used to resolve the cache key.
   * @returns {Function} Returns the new memoizing function.
   * @example
   *
   * var fibonacci = _.memoize(function(n) {
   *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
   * });
   *
   * fibonacci(9)
   * // => 34
   *
   * var data = {
   *   'fred': { 'name': 'fred', 'age': 40 },
   *   'pebbles': { 'name': 'pebbles', 'age': 1 }
   * };
   *
   * // modifying the result cache
   * var get = _.memoize(function(name) { return data[name]; }, _.identity);
   * get('pebbles');
   * // => { 'name': 'pebbles', 'age': 1 }
   *
   * get.cache.pebbles.name = 'penelope';
   * get('pebbles');
   * // => { 'name': 'penelope', 'age': 1 }
   */
  function memoize(func, resolver) {
    var cache = {};
    return function() {
      var key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
      return hasOwnProperty.call(cache, key)
        ? cache[key]
        : (cache[key] = func.apply(this, arguments));
    };
  }

  /**
   * Creates a function that is restricted to execute `func` once. Repeat calls to
   * the function will return the value of the first call. The `func` is executed
   * with the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // `initialize` executes `createApplication` once
   */
  function once(func) {
    var ran,
        result;

    if (!isFunction(func)) {
      throw new TypeError;
    }
    return function() {
      if (ran) {
        return result;
      }
      ran = true;
      result = func.apply(this, arguments);

      // clear the `func` variable so the function may be garbage collected
      func = null;
      return result;
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with any additional
   * `partial` arguments prepended to those provided to the new function. This
   * method is similar to `_.bind` except it does **not** alter the `this` binding.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to partially apply arguments to.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new partially applied function.
   * @example
   *
   * var greet = function(greeting, name) { return greeting + ' ' + name; };
   * var hi = _.partial(greet, 'hi');
   * hi('fred');
   * // => 'hi fred'
   */
  function partial(func) {
    return createWrapper(func, 16, slice(arguments, 1));
  }

  /**
   * Creates a function that, when executed, will only call the `func` function
   * at most once per every `wait` milliseconds. Provide an options object to
   * indicate that `func` should be invoked on the leading and/or trailing edge
   * of the `wait` timeout. Subsequent calls to the throttled function will
   * return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the throttled function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to throttle.
   * @param {number} wait The number of milliseconds to throttle executions to.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // avoid excessively updating the position while scrolling
   * var throttled = _.throttle(updatePosition, 100);
   * jQuery(window).on('scroll', throttled);
   *
   * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
   * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
   *   'trailing': false
   * }));
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError;
    }
    if (options === false) {
      leading = false;
    } else if (isObject(options)) {
      leading = 'leading' in options ? options.leading : leading;
      trailing = 'trailing' in options ? options.trailing : trailing;
    }
    options = {};
    options.leading = leading;
    options.maxWait = wait;
    options.trailing = trailing;

    return debounce(func, wait, options);
  }

  /**
   * Creates a function that provides `value` to the wrapper function as its
   * first argument. Additional arguments provided to the function are appended
   * to those provided to the wrapper function. The wrapper is executed with
   * the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {*} value The value to wrap.
   * @param {Function} wrapper The wrapper function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var p = _.wrap(_.escape, function(func, text) {
   *   return '<p>' + func(text) + '</p>';
   * });
   *
   * p('Fred, Wilma, & Pebbles');
   * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
   */
  function wrap(value, wrapper) {
    return createWrapper(wrapper, 16, [value]);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Produces a callback bound to an optional `thisArg`. If `func` is a property
   * name the created callback will return the property value for a given element.
   * If `func` is an object the created callback will return `true` for elements
   * that contain the equivalent object properties, otherwise it will return `false`.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // wrap to create custom callback shorthands
   * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
   *   return !match ? func(callback, thisArg) : function(object) {
   *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
   *   };
   * });
   *
   * _.filter(characters, 'age__gt38');
   * // => [{ 'name': 'fred', 'age': 40 }]
   */
  function createCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (func == null || type == 'function') {
      return baseCreateCallback(func, thisArg, argCount);
    }
    // handle "_.pluck" style callback shorthands
    if (type != 'object') {
      return property(func);
    }
    var props = keys(func);
    return function(object) {
      var length = props.length,
          result = false;

      while (length--) {
        if (!(result = object[props[length]] === func[props[length]])) {
          break;
        }
      }
      return result;
    };
  }

  /**
   * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
   * corresponding HTML entities.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} string The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('Fred, Wilma, & Pebbles');
   * // => 'Fred, Wilma, &amp; Pebbles'
   */
  function escape(string) {
    return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
  }

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Adds function properties of a source object to the destination object.
   * If `object` is a function methods will be added to its prototype as well.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Function|Object} [object=lodash] object The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
   * @example
   *
   * function capitalize(string) {
   *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
   * }
   *
   * _.mixin({ 'capitalize': capitalize });
   * _.capitalize('fred');
   * // => 'Fred'
   *
   * _('fred').capitalize().value();
   * // => 'Fred'
   *
   * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
   * _('fred').capitalize();
   * // => 'Fred'
   */
  function mixin(object) {
    forEach(functions(object), function(methodName) {
      var func = lodash[methodName] = object[methodName];

      lodash.prototype[methodName] = function() {
        var args = [this.__wrapped__];
        push.apply(args, arguments);

        var result = func.apply(lodash, args);
        return this.__chain__
          ? new lodashWrapper(result, true)
          : result;
      };
    });
  }

  /**
   * Reverts the '_' variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    root._ = oldDash;
    return this;
  }

  /**
   * A no-operation function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {
    // no operation performed
  }

  /**
   * Gets the number of milliseconds that have elapsed since the Unix epoch
   * (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var stamp = _.now();
   * _.defer(function() { console.log(_.now() - stamp); });
   * // => logs the number of milliseconds it took for the deferred function to be called
   */
  var now = isNative(now = Date.now) && now || function() {
    return new Date().getTime();
  };

  /**
   * Creates a "_.pluck" style function, which returns the `key` value of a
   * given object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} key The name of the property to retrieve.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var characters = [
   *   { 'name': 'fred',   'age': 40 },
   *   { 'name': 'barney', 'age': 36 }
   * ];
   *
   * var getName = _.property('name');
   *
   * _.map(characters, getName);
   * // => ['barney', 'fred']
   *
   * _.sortBy(characters, getName);
   * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
   */
  function property(key) {
    return function(object) {
      return object[key];
    };
  }

  /**
   * Produces a random number between `min` and `max` (inclusive). If only one
   * argument is provided a number between `0` and the given number will be
   * returned. If `floating` is truey or either `min` or `max` are floats a
   * floating-point number will be returned instead of an integer.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {number} [min=0] The minimum possible value.
   * @param {number} [max=1] The maximum possible value.
   * @param {boolean} [floating=false] Specify returning a floating-point number.
   * @returns {number} Returns a random number.
   * @example
   *
   * _.random(0, 5);
   * // => an integer between 0 and 5
   *
   * _.random(5);
   * // => also an integer between 0 and 5
   *
   * _.random(5, true);
   * // => a floating-point number between 0 and 5
   *
   * _.random(1.2, 5.2);
   * // => a floating-point number between 1.2 and 5.2
   */
  function random(min, max) {
    if (min == null && max == null) {
      max = 1;
    }
    min = +min || 0;
    if (max == null) {
      max = min;
      min = 0;
    } else {
      max = +max || 0;
    }
    return min + floor(nativeRandom() * (max - min + 1));
  }

  /**
   * Resolves the value of property `key` on `object`. If `key` is a function
   * it will be invoked with the `this` binding of `object` and its result returned,
   * else the property value is returned. If `object` is falsey then `undefined`
   * is returned.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} object The object to inspect.
   * @param {string} key The name of the property to resolve.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = {
   *   'cheese': 'crumpets',
   *   'stuff': function() {
   *     return 'nonsense';
   *   }
   * };
   *
   * _.result(object, 'cheese');
   * // => 'crumpets'
   *
   * _.result(object, 'stuff');
   * // => 'nonsense'
   */
  function result(object, key) {
    if (object) {
      var value = object[key];
      return isFunction(value) ? object[key]() : value;
    }
  }

  /**
   * A micro-templating method that handles arbitrary delimiters, preserves
   * whitespace, and correctly escapes quotes within interpolated code.
   *
   * Note: In the development build, `_.template` utilizes sourceURLs for easier
   * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
   *
   * For more information on precompiling templates see:
   * http://lodash.com/custom-builds
   *
   * For more information on Chrome extension sandboxes see:
   * http://developer.chrome.com/stable/extensions/sandboxingEval.html
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} text The template text.
   * @param {Object} data The data object used to populate the text.
   * @param {Object} [options] The options object.
   * @param {RegExp} [options.escape] The "escape" delimiter.
   * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
   * @param {Object} [options.imports] An object to import into the template as local variables.
   * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
   * @param {string} [sourceURL] The sourceURL of the template's compiled source.
   * @param {string} [variable] The data object variable name.
   * @returns {Function|string} Returns a compiled function when no `data` object
   *  is given, else it returns the interpolated text.
   * @example
   *
   * // using the "interpolate" delimiter to create a compiled template
   * var compiled = _.template('hello <%= name %>');
   * compiled({ 'name': 'fred' });
   * // => 'hello fred'
   *
   * // using the "escape" delimiter to escape HTML in data property values
   * _.template('<b><%- value %></b>', { 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // using the "evaluate" delimiter to generate HTML
   * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
   * _.template(list, { 'people': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
   * _.template('hello ${ name }', { 'name': 'pebbles' });
   * // => 'hello pebbles'
   *
   * // using the internal `print` function in "evaluate" delimiters
   * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
   * // => 'hello barney!'
   *
   * // using a custom template delimiters
   * _.templateSettings = {
   *   'interpolate': /{{([\s\S]+?)}}/g
   * };
   *
   * _.template('hello {{ name }}!', { 'name': 'mustache' });
   * // => 'hello mustache!'
   *
   * // using the `imports` option to import jQuery
   * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
   * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // using the `sourceURL` option to specify a custom sourceURL for the template
   * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
   *
   * // using the `variable` option to ensure a with-statement isn't used in the compiled template
   * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   *   var __t, __p = '', __e = _.escape;
   *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
   *   return __p;
   * }
   *
   * // using the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and a stack trace
   * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */
  function template(text, data, options) {
    var _ = lodash,
        settings = _.templateSettings;

    text = String(text || '');
    options = defaults({}, options, settings);

    var index = 0,
        source = "__p += '",
        variable = options.variable;

    var reDelimiters = RegExp(
      (options.escape || reNoMatch).source + '|' +
      (options.interpolate || reNoMatch).source + '|' +
      (options.evaluate || reNoMatch).source + '|$'
    , 'g');

    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {
      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      if (escapeValue) {
        source += "' +\n_.escape(" + escapeValue + ") +\n'";
      }
      if (evaluateValue) {
        source += "';\n" + evaluateValue + ";\n__p += '";
      }
      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }
      index = offset + match.length;
      return match;
    });

    source += "';\n";
    if (!variable) {
      variable = 'obj';
      source = 'with (' + variable + ' || {}) {\n' + source + '\n}\n';
    }
    source = 'function(' + variable + ') {\n' +
      "var __t, __p = '', __j = Array.prototype.join;\n" +
      "function print() { __p += __j.call(arguments, '') }\n" +
      source +
      'return __p\n}';

    try {
      var result = Function('_', 'return ' + source)(_);
    } catch(e) {
      e.source = source;
      throw e;
    }
    if (data) {
      return result(data);
    }
    result.source = source;
    return result;
  }

  /**
   * Executes the callback `n` times, returning an array of the results
   * of each callback execution. The callback is bound to `thisArg` and invoked
   * with one argument; (index).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {number} n The number of times to execute the callback.
   * @param {Function} callback The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns an array of the results of each `callback` execution.
   * @example
   *
   * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
   * // => [3, 6, 4]
   *
   * _.times(3, function(n) { mage.castSpell(n); });
   * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
   *
   * _.times(3, function(n) { this.cast(n); }, mage);
   * // => also calls `mage.castSpell(n)` three times
   */
  function times(n, callback, thisArg) {
    n = (n = +n) > -1 ? n : 0;
    var index = -1,
        result = Array(n);

    callback = baseCreateCallback(callback, thisArg, 1);
    while (++index < n) {
      result[index] = callback(index);
    }
    return result;
  }

  /**
   * The inverse of `_.escape` this method converts the HTML entities
   * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
   * corresponding characters.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} string The string to unescape.
   * @returns {string} Returns the unescaped string.
   * @example
   *
   * _.unescape('Fred, Barney &amp; Pebbles');
   * // => 'Fred, Barney & Pebbles'
   */
  function unescape(string) {
    return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
  }

  /**
   * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} [prefix] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object that wraps the given value with explicit
   * method chaining enabled.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36 },
   *   { 'name': 'fred',    'age': 40 },
   *   { 'name': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _.chain(characters)
   *     .sortBy('age')
   *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
   *     .first()
   *     .value();
   * // => 'pebbles is 1'
   */
  function chain(value) {
    value = new lodashWrapper(value);
    value.__chain__ = true;
    return value;
  }

  /**
   * Invokes `interceptor` with the `value` as the first argument and then
   * returns `value`. The purpose of this method is to "tap into" a method
   * chain in order to perform operations on intermediate results within
   * the chain.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns `value`.
   * @example
   *
   * _([1, 2, 3, 4])
   *  .tap(function(array) { array.pop(); })
   *  .reverse()
   *  .value();
   * // => [3, 2, 1]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * Enables explicit method chaining on the wrapper object.
   *
   * @name chain
   * @memberOf _
   * @category Chaining
   * @returns {*} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // without explicit chaining
   * _(characters).first();
   * // => { 'name': 'barney', 'age': 36 }
   *
   * // with explicit chaining
   * _(characters).chain()
   *   .first()
   *   .pick('age')
   *   .value();
   * // => { 'age': 36 }
   */
  function wrapperChain() {
    this.__chain__ = true;
    return this;
  }

  /**
   * Extracts the wrapped value.
   *
   * @name valueOf
   * @memberOf _
   * @alias value
   * @category Chaining
   * @returns {*} Returns the wrapped value.
   * @example
   *
   * _([1, 2, 3]).valueOf();
   * // => [1, 2, 3]
   */
  function wrapperValueOf() {
    return this.__wrapped__;
  }

  /*--------------------------------------------------------------------------*/

  // add functions that return wrapped values when chaining
  lodash.after = after;
  lodash.bind = bind;
  lodash.bindAll = bindAll;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.compose = compose;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.difference = difference;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.functions = functions;
  lodash.groupBy = groupBy;
  lodash.indexBy = indexBy;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.invert = invert;
  lodash.invoke = invoke;
  lodash.keys = keys;
  lodash.map = map;
  lodash.max = max;
  lodash.memoize = memoize;
  lodash.min = min;
  lodash.omit = omit;
  lodash.once = once;
  lodash.pairs = pairs;
  lodash.partial = partial;
  lodash.pick = pick;
  lodash.pluck = pluck;
  lodash.range = range;
  lodash.reject = reject;
  lodash.rest = rest;
  lodash.shuffle = shuffle;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.throttle = throttle;
  lodash.times = times;
  lodash.toArray = toArray;
  lodash.union = union;
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.where = where;
  lodash.without = without;
  lodash.wrap = wrap;
  lodash.zip = zip;

  // add aliases
  lodash.collect = map;
  lodash.drop = rest;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.object = zipObject;
  lodash.select = filter;
  lodash.tail = rest;
  lodash.unique = uniq;

  /*--------------------------------------------------------------------------*/

  // add functions that return unwrapped values when chaining
  lodash.clone = clone;
  lodash.contains = contains;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.has = has;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isElement = isElement;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.lastIndexOf = lastIndexOf;
  lodash.mixin = mixin;
  lodash.noConflict = noConflict;
  lodash.random = random;
  lodash.reduce = reduce;
  lodash.reduceRight = reduceRight;
  lodash.result = result;
  lodash.size = size;
  lodash.some = some;
  lodash.sortedIndex = sortedIndex;
  lodash.template = template;
  lodash.unescape = unescape;
  lodash.uniqueId = uniqueId;

  // add aliases
  lodash.all = every;
  lodash.any = some;
  lodash.detect = find;
  lodash.findWhere = findWhere;
  lodash.foldl = reduce;
  lodash.foldr = reduceRight;
  lodash.include = contains;
  lodash.inject = reduce;

  /*--------------------------------------------------------------------------*/

  // add functions capable of returning wrapped and unwrapped values when chaining
  lodash.first = first;
  lodash.last = last;
  lodash.sample = sample;

  // add aliases
  lodash.take = first;
  lodash.head = first;

  /*--------------------------------------------------------------------------*/

  // add functions to `lodash.prototype`
  mixin(lodash);

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = '2.4.1';

  // add "Chaining" functions to the wrapper
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.value = wrapperValueOf;

    // add `Array` mutator functions to the wrapper
    forEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__;
        func.apply(value, arguments);

        // avoid array-like object bugs with `Array#shift` and `Array#splice`
        // in Firefox < 10 and IE < 9
        if (!support.spliceObjects && value.length === 0) {
          delete value[0];
        }
        return this;
      };
    });

    // add `Array` accessor functions to the wrapper
    forEach(['concat', 'join', 'slice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            result = func.apply(value, arguments);

        if (this.__chain__) {
          result = new lodashWrapper(result);
          result.__chain__ = true;
        }
        return result;
      };
    });

  /*--------------------------------------------------------------------------*/

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define('underscore',[],function() {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = lodash)._ = lodash;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = lodash;
    }
  }
  else {
    // in a browser or Rhino
    root._ = lodash;
  }
}.call(this));

define('aura/ext/mediator',['eventemitter','underscore'], function() {
    'use strict';

    return {
        name: 'mediator',

        require: {
            paths: {
                eventemitter: '../components/eventemitter2/lib/eventemitter2',
                underscore: '../components/underscore/underscore'
            },
            shim: {
                underscore: {
                    exports: '_'
                }
            }
        },
        initialize: function(app) {
            var EventEmitter = require('eventemitter');
            var _ = require('underscore');

            app.config.mediator = _.defaults(app.config.mediator || {}, {
                wildcard: true,
                delimiter: '.',
                newListener: true,
                maxListeners: 0
            });

            var mediator = new EventEmitter(app.config.mediator);
            mediator.setMaxListeners(50);

            app.core.mediator = mediator;

            /** michael forbes - add an app wide event emitter tied to window **/
            if (window.app) {
                window.app.events = new EventEmitter(app.config.mediator);
            } else {
                window.app = {
                    events: new EventEmitter(app.config.mediator)
                };
            }

            /** michael forbes - add a new app wide event emitter tied to window for events outside of sandboxes. simpler root for easier comparison **/
            if (!window.appEvents) {
                window.appEvents = new EventEmitter(app.config.mediator);
            }

            app.sandbox.on = function(name, listener, context) {

                /** michael forbes - belkin - sandbox events **/
                if (this.ref && !name.match(/global\./)) {
                    name += '.' + this.ref;
                }

                if (!_.isFunction(listener) || !_.isString(name)) {
                    throw new Error('Invalid arguments passed to sandbox.on');
                }
                context = context || this;
                var callback = function() {
                    var args = Array.prototype.slice.call(arguments);
                    try {
                        listener.apply(context, args);
                    } catch (e) {
                      console.error(e);
                    }
                };

                this._events = this._events || [];
                this._events.push({
                    name: name,
                    listener: listener,
                    callback: callback
                });

                mediator.on(name, callback);
            };

            app.sandbox.off = function(name, listener) {

                /** michael forbes - belkin - sandbox events **/
                if (this.ref && !name.match(/global\./)) {
                    name += '.' + this.ref;
                }

                if (!this._events) {
                    return;
                }
                this._events = _.reject(this._events, function(evt) {
                    var ret = (evt.name === name && evt.listener === listener);
                    if (ret) {
                        mediator.off(name, evt.callback);
                    }
                    return ret;
                });
            };

            app.sandbox.emit = function() {
                var eventData = Array.prototype.slice.call(arguments);

                if (app.config.logEvents) {
                    eventData.unshift('Event emitted');
                    app.logger.log.apply(app.logger, eventData);
                }
                /** michael forbes - belkin - make mediator only emit to its own sandbox, instead of all sandboxes unless 'global' namespace is used **/
                if (typeof eventData[0] === 'string') {
                    if (this.ref && !eventData[0].match(/global\./)) {
                        eventData[0] += '.' + this.ref;
                    }
                }

                mediator.emit.apply(mediator, eventData);
            };

            app.sandbox.stopListening = function() {
                if (!this._events) {
                    return;
                }
                _.each(this._events, function(evt) {
                    mediator.off(evt.name, evt.callback);
                });
            };

            var eventName = ['aura', 'sandbox', 'stop'].join(app.config.mediator.delimiter);
            app.core.mediator.on(eventName, function(sandbox) {
                sandbox.stopListening();
            });
        }
    };
});

define('aura/ext/widgets',[], function() {

    'use strict';


    return function(app) {

        var core = app.core;
        var _ = app.core.util._;
        core.Widgets = core.Widgets || {};

        var ownProp = function(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
        };




        function loadI18N(options) {
            var dfd = core.data.deferred();
            app.core.util.storage.removeItem(options.i18n);

            function requireDefault() {
                require([options.i18nFallback], function(i18n) {
                    DEBUG && console.log('WIDGETS:i18n:got fallback language:widget=' + options.name + ':file=' + options.i18nFallback);
                    app.core.util.storage.setItem(options.i18n, i18n);
                    dfd.resolve();
                });
            }

            if (options.ref.match(/\/\//)) {
                dfd.reject();
            } else if (app.core.util.storage.getItem(options.i18n)) {
                dfd.resolve();
            } else {
                //need to load i18n based on set language
                DEBUG && console.log('WIDGETS:i18n:getting language:widget=' + options.name + ':file=' + options.i18n);
                require([options.i18n], function(i18n) {

                    if (i18n.length === 0) {
                        DEBUG && console.log('WIDGETS:i18n:getting fallback language:widget=' + options.name + ':file=' + options.i18n);
                        requireDefault();
                    } else {
                        app.core.util.storage.setItem(options.i18n, i18n);
                        DEBUG && console.log('WIDGETS:i18n:got language, resolving:widget=' + options.name + ':file=' + options.i18n);
                        dfd.resolve();
                    }

                }, function() {
                    //if that fails, we use the fallback language
                    DEBUG && console.log('WIDGETS:i18n:getting fallback language:widget=' + options.name + ':file=' + options.i18n);
                    requireDefault();
                });


            }

            return dfd.promise();
        }

        /**
         * Widgets registry
         * @type {Object}
         */
        var registeredWidgets = {};

        /**
         * The base Widget constructor...
         *
         * @param {Object} options the options to init the widget...
         */
        function Widget(options) {
            this.options = _.defaults(options || {}, this.options || {});
            this._ref = options._ref;
            this.$el = core.dom.find(options.el);

            this.initialize.call(this, this.options);
            return this;
        }

        Widget.prototype.initialize = function() {};

        /**
         * A small helper function to render markup
         *
         * @param  {String} markup the markup to render in the widget's root el
         * @return {Widget} the Widget instance to allow methods chaining...
         */
        Widget.prototype.html = function(markup) {
            var el = this.$el;
            el.html(markup);
            this.sandbox.start(el);
            return this;
        };

        // Stolen from Backbone 0.9.9 !
        // Helper function to correctly set up the prototype chain, for subclasses.
        // Similar to `goog.inherits`, but uses a hash of prototype properties and
        // class properties to be extended.
        var extend = function(protoProps, staticProps) {
            var parent = this;
            var child;
            if (protoProps && ownProp(protoProps, 'constructor')) {
                child = protoProps.constructor;
            } else {
                child = function() {
                    parent.apply(this, arguments);
                };
            }
            core.util.extend(child, parent, staticProps);
            var Surrogate = function() {
                this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            if (protoProps) {
                core.util.extend(child.prototype, protoProps);
            }
            child.__super__ = parent.prototype;
            return child;
        };

        Widget.extend = extend;

        /**
         * Widget loader.
         * @param  {String} name    The name of the Widget to load
         * @param  {Object} options The options to pass to the new widget instance.
         * @return {Promise}        A Promise that resolves to the loaded widget instance.
         */
        Widget.load = function(name, options) {

            // TODO: Make it more simple / or break it down
            // in several functions...
            // it's too big !
            //
            app.logger.log("Start loading widget:", name);
            var dfd = core.data.deferred(),
                ref = options.ref,
                widget,
                WidgetConstructor;



            dfd.fail(function(err) {
                app.logger.error("Error loading widget:", name, err);
            });


            // Apply requirejs map / package configuration before the actual loading.
            //  console.log(options.require)
            require.config(options.require);

            // Here, we require the widget's package definition
            // console.log(options.fullUrl)


            /** michael forbes, belkin - add i18n **/

            loadI18N(options).then(function(i18n) {

                i18n = app.core.util.storage.getItem(options.i18n).data;

                DEBUG && console.log('WIDGETS:i18n:returning from load method:data=' + i18n);

                require([options.ref], function(widgetDefinition) {

                    DEBUG && console.log('WIDGETS:i18n:require succeeded');

                    if (!widgetDefinition) {

                        return dfd.reject("widget " + options.ref + " Definition is empty !");
                    }

                    try {

                        // Ok, the widget has already been loaded once, we should already have it in the registry
                        if (registeredWidgets[ref]) {
                            WidgetConstructor = registeredWidgets[ref];
                        } else {

                            if (widgetDefinition.type) {
                                // If `type` is defined, we use a constructor provided by an extension ? ex. Backbone.
                                WidgetConstructor = core.Widgets[widgetDefinition.type];
                            } else {
                                // Otherwise, we use the stock Widget constructor.
                                WidgetConstructor = Widget;
                            }

                            if (!WidgetConstructor) {
                                throw new Error("Can't find widget of type '" + widgetDefinition.type + "', did you forget to include the extension that provides it ?");
                            }

                            if (core.util._.isObject(widgetDefinition)) {
                                WidgetConstructor = registeredWidgets[ref] = WidgetConstructor.extend(widgetDefinition);
                            }
                        }

                        var sandbox = app.createSandbox();

                        /** michael forbes - belkin, add extended options **/
                        _.extend(sandbox, options.extendedOptions);

                        /** michael forbes - belkin, add i18n **/
                        if (app.device) {
                            sandbox.device = app.device;
                        }

                        sandbox.i18n.addResourceBundle(app.core.i18n.lng(), options.name, JSON.parse(i18n));
                        DEBUG && console.log('WIDGETS:i18n:added resource bundle');
                        sandbox.i18n.translate = function(template, name) {

                            Handlebars.registerHelper('i18n', function(i18n_key) {
                                var result;
                                if (i18n_key.match(/:/)) {
                                    var split = i18n_key.split(':');
                                    if (split[0] === 'app') {
                                        i18n_key = 'translation:' + split[1];
                                    }
                                    result = sandbox.i18n.t(i18n_key);
                                } else {
                                    result = sandbox.i18n.t(name + ':' + i18n_key);
                                }
                                return new Handlebars.SafeString(result);
                            });



                            var $html = $(template()); //wrap it in jquery, so we can treat it as a document fragment and do cool stuff to it.


                            return $html;
                        };
                        sandbox.logger.setName("Widget '" + name + "'(" + sandbox.logger.name + ')');


                        options._ref = core.util._.uniqueId(ref + '+');

                        // Here we inject the sandbox in the widget's prototype...
                        var ext = {
                            sandbox: sandbox
                        };
                        /** michael forbes, belkin - add default widget name **/
                        ext.name = options.name;
                        sandbox.name = options.name;
                        sandbox.view = options.view;

                        // If the Widget is just defined as a function, we use it as its `initialize` method.
                        if (typeof widgetDefinition === 'function') {
                            ext.initialize = widgetDefinition;
                        }

                        WidgetConstructor = WidgetConstructor.extend(ext);


                        var newWidget = new WidgetConstructor(options);
                        var initialized = core.data.when(newWidget);

                        initialized.then(function(ret) {
                            dfd.resolve(ret);
                        });
                        initialized.fail(function(err) {
                            dfd.reject(err);
                        });

                        app.logger.log("Widget loaded:", name, newWidget);
                        return initialized;
                    } catch (err) {
                        app.logger.error(err.message);
                        dfd.reject(err);
                    }
                }, function(err) {
                    console.error('ERROR', err)
                    dfd.reject(err);
                });
            });

            return dfd.promise();
        };

        /**
         * Parses the widget's options from its element's data attributes.
         *
         * @param  {String|DomNode} el the element
         * @return {Object}         An object that contains the widget's options
         */
        function parseWidgetOptions(el, namespace) {
            var options = {
                    el: el,
                    require: {}
                },
                widgetName, widgetSource;
            var data = core.dom.data(el);

            // Here we go through all the data attributes of the element to build the options object
            core.util.each(data, function(k, v) {
                k = k.replace(new RegExp("^" + namespace), "");
                k = k.charAt(0).toLowerCase() + k.slice(1);

                if (k !== "widget") {
                    options[k] = v;
                } else {
                    var ref = v.split("@");

                    widgetName = core.util.decamelize(ref[0]);
                    widgetSource = ref[1] || "default";
                }
            });

            /** michael forbes - add built widgets path, parse widget name for init view **/
            var widgetNameSplit = widgetName.split('/');
            var widgetView;
            var requireContext = require.s.contexts._;
            var widgetsPath = app.config.widgets.sources[widgetSource] || "widgets";
            var builtWidgetsPath = widgetsPath.replace(/..\//, '');

            if (widgetNameSplit.length > 1) {
                widgetName = widgetNameSplit[0];
                widgetNameSplit.shift();
                widgetView = widgetNameSplit.join('/');
            }



            // Register the widget a s requirejs package...
            // TODO: packages are not supported by almond, should we find another way to do //this ?
            options.ref = builtWidgetsPath + "/" + widgetName + '/main';
            options.baseUrl = widgetsPath + "/" + widgetName;
            options.fullUrl = 'widgets/' + widgetName + '/main.js';
            options.require = options.require || {};
            options.require.packages = options.require.packages || [];
            options.require.packages.push({
                name: options.ref,
                location: widgetsPath + "/" + widgetName
            });
            options.name = widgetName;
            options.view = widgetView;
            /** michael forbes - belkin - add i18n **/
            options.i18n = 'text!' + options.baseUrl + '/locales/' + app.core.i18n.lng() + '/translation.json';
            options.i18nFallback = 'text!' + options.baseUrl + '/locales/' + app.core.i18n.options.fallbackLng + '/translation.json';
            return options;
        }


        /**
         * Returns a list of widget.
         * If the first argument is a String, it is considered as a DomNode reference
         * We then parse its content to find aura-widgets inside of it.
         *
         * @param  {Array|String} widgets a list of widgets or a reference to a root dom node
         * @return {Array}        a list of widget with their options
         */

        function hasClass(el, selector) {
            var className = " " + selector + " ";

            if ((" " + el.className + " ").replace(/[\n\t]/g, " ").indexOf(className) > -1) {
                return true;
            }


            return false;
        }
        Widget.parseList = function(widgets) {
            if (Array.isArray(widgets)) {
                return widgets;
            }
            var list = [];

            if (widgets && core.dom.find(widgets)) {
                var appNamespace = app.config.namespace;
                var selector = ["[data-aura-widget]"];
                if (appNamespace) {
                    selector.push("[data-" + appNamespace + "-widget]");
                }
                selector = selector.join(",");

                core.dom.find(selector, widgets || 'body').each(function() {
                    var ns = "aura";

                    if (appNamespace && this.getAttribute('data-' + appNamespace + '-widget')) {
                        ns = appNamespace;
                    }


                    /** michael forbes - add a 'started' attribute so we can call start more than once on an element. wemo needs this
                     * in order to add devices to the list in more than one shot.
                     */
                    if (!this.getAttribute('data-' + ns + '-started')) {
                        this.setAttribute('data-' + ns + '-started', 'true');
                        var options = parseWidgetOptions(this, ns);
                        list.push({
                            name: options.name,
                            options: options
                        });
                    }
                });
            }

            return list;
        };

        /**
         * Actual start method for a list of widgets.
         *
         * @param  {Array|String} widgets cf. `Widget.parseList`
         * @param {Object} options to add to the widget  - added by michael forbes - belkin
         * @return {Promise} a promise that resolves to a list of started widgets.
         */
        Widget.startAll = function(widgets, options) {

            var widgetsList = Widget.parseList(widgets);

            var list = [];
            core.util.each(widgetsList, function(i, w) {
                w.options.extendedOptions = options; //added to pass options to extend new sandbox object

                list.push(Widget.load(w.name, w.options));
            });

            return core.data.when.apply(undefined, list);
        };

        /** michael forbes - belkin - starting a new sandbox was putting this into an infitinite loop **/
        function stopThem(children) {
            _.each(children, function(child) {
                if (!child.stopped) {
                    child.stopped = true;
                    child.stop();

                }
            })
        }

        return {
            name: 'widgets',

            //  require: { paths: { text: 'components/requirejs-text/text' } },

            initialize: function(app) {

                // Widgets 'classes' registry...
                app.core.Widgets.Base = Widget;

                // Any idea for a better name ?
                app.core.registerWidgetType = function(type, def) {
                    if (app.core.Widgets[type]) {
                        throw new Error("Widget type " + type + " already defined");
                    }
                    app.core.Widgets[type] = Widget.extend(def);
                };

                app.core.start = Widget.startAll;

                /** michael forbes - add options  **/

                app.sandbox.start = function(list, options) {

                    options = options || {};

                    var event = ['aura', 'sandbox', 'start'].join(app.config.mediator.delimiter);

                    app.core.mediator.emit(event, this);
                    //  stopThem(this._children);
                    //_.invoke(this._children || [], 'stop');
                    var self = this;

                    Widget.startAll(list, options).then(function() {
                        var widgets = Array.prototype.slice.call(arguments);

                        var children = [];
                        _.each(widgets, function(w) {
                            w.sandbox._widget = w;
                            w.sandbox._parent = self;

                            children.push(w.sandbox);
                        });
                        self._children = children;
                        /** michael forbes - belkin - add event for finish loading widgets **/
                        app.core.mediator.emit('widget', children);
                        self.emit('widget', children, options);
                    });

                    return this;
                };

                app.sandbox.stop = function() {
                    var event = ['aura', 'sandbox', 'stop'].join(app.config.mediator.delimiter);
                    stopThem(this._children);
                    //  _.invoke(this._children, 'stop');
                    app.core.mediator.emit(event, this);
                    this.stopped = true;
                    delete app.sandboxes[this.ref];
                    return this;
                };
            },

            afterAppStart: function(app) {
                // Auto start widgets when the app is loaded.
                if (app.startOptions.widgets) {
                    app.core.start(app.startOptions.widgets);
                }
            }

        };
    };
});
define('aura/ext/debug',[], function() {
  'use strict';

  return {
    name: 'debug',

    initialize: function(app) {
      if (typeof window.attachDebugger === 'function') {
          window.attachDebugger(app);
      }
    }
  };
});

/*

 Copyright (C) 2011 by Yehuda Katz

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 */

// lib/handlebars/browser-prefix.js
var Handlebars = {};

(function(Handlebars, undefined) {
    ;
// lib/handlebars/base.js

    Handlebars.VERSION = "1.0.0-rc.4";
    Handlebars.COMPILER_REVISION = 3;

    Handlebars.REVISION_CHANGES = {
        1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
        2: '== 1.0.0-rc.3',
        3: '>= 1.0.0-rc.4'
    };

    Handlebars.helpers  = {};
    Handlebars.partials = {};

    var toString = Object.prototype.toString,
        functionType = '[object Function]',
        objectType = '[object Object]';

    Handlebars.registerHelper = function(name, fn, inverse) {
        if (toString.call(name) === objectType) {
            if (inverse || fn) { throw new Handlebars.Exception('Arg not supported with multiple helpers'); }
            Handlebars.Utils.extend(this.helpers, name);
        } else {
            if (inverse) { fn.not = inverse; }
            this.helpers[name] = fn;
        }
    };

    Handlebars.registerPartial = function(name, str) {
        if (toString.call(name) === objectType) {
            Handlebars.Utils.extend(this.partials,  name);
        } else {
            this.partials[name] = str;
        }
    };

    Handlebars.registerHelper('helperMissing', function(arg) {
        if(arguments.length === 2) {
            return undefined;
        } else {
            throw new Error("Could not find property '" + arg + "'");
        }
    });

    Handlebars.registerHelper('blockHelperMissing', function(context, options) {
        var inverse = options.inverse || function() {}, fn = options.fn;

        var type = toString.call(context);

        if(type === functionType) { context = context.call(this); }

        if(context === true) {
            return fn(this);
        } else if(context === false || context == null) {
            return inverse(this);
        } else if(type === "[object Array]") {
            if(context.length > 0) {
                return Handlebars.helpers.each(context, options);
            } else {
                return inverse(this);
            }
        } else {
            return fn(context);
        }
    });

    Handlebars.K = function() {};

    Handlebars.createFrame = Object.create || function(object) {
        Handlebars.K.prototype = object;
        var obj = new Handlebars.K();
        Handlebars.K.prototype = null;
        return obj;
    };

    Handlebars.logger = {
        DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3,

        methodMap: {0: 'debug', 1: 'info', 2: 'warn', 3: 'error'},

        // can be overridden in the host environment
        log: function(level, obj) {
            if (Handlebars.logger.level <= level) {
                var method = Handlebars.logger.methodMap[level];
                if (typeof console !== 'undefined' && console[method]) {
                    console[method].call(console, obj);
                }
            }
        }
    };

    Handlebars.log = function(level, obj) { Handlebars.logger.log(level, obj); };

    Handlebars.registerHelper('each', function(context, options) {
        var fn = options.fn, inverse = options.inverse;
        var i = 0, ret = "", data;

        if (options.data) {
            data = Handlebars.createFrame(options.data);
        }

        if(context && typeof context === 'object') {
            if(context instanceof Array){
                for(var j = context.length; i<j; i++) {
                    if (data) { data.index = i; }
                    ret = ret + fn(context[i], { data: data });
                }
            } else {
                for(var key in context) {
                    if(context.hasOwnProperty(key)) {
                        if(data) { data.key = key; }
                        ret = ret + fn(context[key], {data: data});
                        i++;
                    }
                }
            }
        }

        if(i === 0){
            ret = inverse(this);
        }

        return ret;
    });

    Handlebars.registerHelper('if', function(conditional, options) {
        var type = toString.call(conditional);
        if(type === functionType) { conditional = conditional.call(this); }

        if(!conditional || Handlebars.Utils.isEmpty(conditional)) {
            return options.inverse(this);
        } else {
            return options.fn(this);
        }
    });

    Handlebars.registerHelper('unless', function(conditional, options) {
        return Handlebars.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn});
    });

    Handlebars.registerHelper('with', function(context, options) {
        if (!Handlebars.Utils.isEmpty(context)) return options.fn(context);
    });

    Handlebars.registerHelper('log', function(context, options) {
        var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
        Handlebars.log(level, context);
    });
    ;
// lib/handlebars/compiler/parser.js
    /* Jison generated parser */
    var handlebars = (function(){
        var parser = {trace: function trace() { },
            yy: {},
            symbols_: {"error":2,"root":3,"program":4,"EOF":5,"simpleInverse":6,"statements":7,"statement":8,"openInverse":9,"closeBlock":10,"openBlock":11,"mustache":12,"partial":13,"CONTENT":14,"COMMENT":15,"OPEN_BLOCK":16,"inMustache":17,"CLOSE":18,"OPEN_INVERSE":19,"OPEN_ENDBLOCK":20,"path":21,"OPEN":22,"OPEN_UNESCAPED":23,"OPEN_PARTIAL":24,"partialName":25,"params":26,"hash":27,"dataName":28,"param":29,"STRING":30,"INTEGER":31,"BOOLEAN":32,"hashSegments":33,"hashSegment":34,"ID":35,"EQUALS":36,"PARTIAL_NAME":37,"DATA":38,"pathSegments":39,"SEP":40,"$accept":0,"$end":1},
            terminals_: {2:"error",5:"EOF",14:"CONTENT",15:"COMMENT",16:"OPEN_BLOCK",18:"CLOSE",19:"OPEN_INVERSE",20:"OPEN_ENDBLOCK",22:"OPEN",23:"OPEN_UNESCAPED",24:"OPEN_PARTIAL",30:"STRING",31:"INTEGER",32:"BOOLEAN",35:"ID",36:"EQUALS",37:"PARTIAL_NAME",38:"DATA",40:"SEP"},
            productions_: [0,[3,2],[4,2],[4,3],[4,2],[4,1],[4,1],[4,0],[7,1],[7,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,3],[13,4],[6,2],[17,3],[17,2],[17,2],[17,1],[17,1],[26,2],[26,1],[29,1],[29,1],[29,1],[29,1],[29,1],[27,1],[33,2],[33,1],[34,3],[34,3],[34,3],[34,3],[34,3],[25,1],[28,2],[21,1],[39,3],[39,1]],
            performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1: return $$[$0-1];
                        break;
                    case 2: this.$ = new yy.ProgramNode([], $$[$0]);
                        break;
                    case 3: this.$ = new yy.ProgramNode($$[$0-2], $$[$0]);
                        break;
                    case 4: this.$ = new yy.ProgramNode($$[$0-1], []);
                        break;
                    case 5: this.$ = new yy.ProgramNode($$[$0]);
                        break;
                    case 6: this.$ = new yy.ProgramNode([], []);
                        break;
                    case 7: this.$ = new yy.ProgramNode([]);
                        break;
                    case 8: this.$ = [$$[$0]];
                        break;
                    case 9: $$[$0-1].push($$[$0]); this.$ = $$[$0-1];
                        break;
                    case 10: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1].inverse, $$[$0-1], $$[$0]);
                        break;
                    case 11: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0-1].inverse, $$[$0]);
                        break;
                    case 12: this.$ = $$[$0];
                        break;
                    case 13: this.$ = $$[$0];
                        break;
                    case 14: this.$ = new yy.ContentNode($$[$0]);
                        break;
                    case 15: this.$ = new yy.CommentNode($$[$0]);
                        break;
                    case 16: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]);
                        break;
                    case 17: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]);
                        break;
                    case 18: this.$ = $$[$0-1];
                        break;
                    case 19: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]);
                        break;
                    case 20: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1], true);
                        break;
                    case 21: this.$ = new yy.PartialNode($$[$0-1]);
                        break;
                    case 22: this.$ = new yy.PartialNode($$[$0-2], $$[$0-1]);
                        break;
                    case 23:
                        break;
                    case 24: this.$ = [[$$[$0-2]].concat($$[$0-1]), $$[$0]];
                        break;
                    case 25: this.$ = [[$$[$0-1]].concat($$[$0]), null];
                        break;
                    case 26: this.$ = [[$$[$0-1]], $$[$0]];
                        break;
                    case 27: this.$ = [[$$[$0]], null];
                        break;
                    case 28: this.$ = [[$$[$0]], null];
                        break;
                    case 29: $$[$0-1].push($$[$0]); this.$ = $$[$0-1];
                        break;
                    case 30: this.$ = [$$[$0]];
                        break;
                    case 31: this.$ = $$[$0];
                        break;
                    case 32: this.$ = new yy.StringNode($$[$0]);
                        break;
                    case 33: this.$ = new yy.IntegerNode($$[$0]);
                        break;
                    case 34: this.$ = new yy.BooleanNode($$[$0]);
                        break;
                    case 35: this.$ = $$[$0];
                        break;
                    case 36: this.$ = new yy.HashNode($$[$0]);
                        break;
                    case 37: $$[$0-1].push($$[$0]); this.$ = $$[$0-1];
                        break;
                    case 38: this.$ = [$$[$0]];
                        break;
                    case 39: this.$ = [$$[$0-2], $$[$0]];
                        break;
                    case 40: this.$ = [$$[$0-2], new yy.StringNode($$[$0])];
                        break;
                    case 41: this.$ = [$$[$0-2], new yy.IntegerNode($$[$0])];
                        break;
                    case 42: this.$ = [$$[$0-2], new yy.BooleanNode($$[$0])];
                        break;
                    case 43: this.$ = [$$[$0-2], $$[$0]];
                        break;
                    case 44: this.$ = new yy.PartialNameNode($$[$0]);
                        break;
                    case 45: this.$ = new yy.DataNode($$[$0]);
                        break;
                    case 46: this.$ = new yy.IdNode($$[$0]);
                        break;
                    case 47: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2];
                        break;
                    case 48: this.$ = [{part: $$[$0]}];
                        break;
                }
            },
            table: [{3:1,4:2,5:[2,7],6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],22:[1,14],23:[1,15],24:[1,16]},{1:[3]},{5:[1,17]},{5:[2,6],7:18,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,6],22:[1,14],23:[1,15],24:[1,16]},{5:[2,5],6:20,8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,5],22:[1,14],23:[1,15],24:[1,16]},{17:23,18:[1,22],21:24,28:25,35:[1,28],38:[1,27],39:26},{5:[2,8],14:[2,8],15:[2,8],16:[2,8],19:[2,8],20:[2,8],22:[2,8],23:[2,8],24:[2,8]},{4:29,6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,7],22:[1,14],23:[1,15],24:[1,16]},{4:30,6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,7],22:[1,14],23:[1,15],24:[1,16]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],24:[2,12]},{5:[2,13],14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],24:[2,13]},{5:[2,14],14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],24:[2,14]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],24:[2,15]},{17:31,21:24,28:25,35:[1,28],38:[1,27],39:26},{17:32,21:24,28:25,35:[1,28],38:[1,27],39:26},{17:33,21:24,28:25,35:[1,28],38:[1,27],39:26},{25:34,37:[1,35]},{1:[2,1]},{5:[2,2],8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,2],22:[1,14],23:[1,15],24:[1,16]},{17:23,21:24,28:25,35:[1,28],38:[1,27],39:26},{5:[2,4],7:36,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,4],22:[1,14],23:[1,15],24:[1,16]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],24:[2,9]},{5:[2,23],14:[2,23],15:[2,23],16:[2,23],19:[2,23],20:[2,23],22:[2,23],23:[2,23],24:[2,23]},{18:[1,37]},{18:[2,27],21:42,26:38,27:39,28:46,29:40,30:[1,43],31:[1,44],32:[1,45],33:41,34:47,35:[1,48],38:[1,27],39:26},{18:[2,28]},{18:[2,46],30:[2,46],31:[2,46],32:[2,46],35:[2,46],38:[2,46],40:[1,49]},{21:50,35:[1,28],39:26},{18:[2,48],30:[2,48],31:[2,48],32:[2,48],35:[2,48],38:[2,48],40:[2,48]},{10:51,20:[1,52]},{10:53,20:[1,52]},{18:[1,54]},{18:[1,55]},{18:[1,56]},{18:[1,57],21:58,35:[1,28],39:26},{18:[2,44],35:[2,44]},{5:[2,3],8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,3],22:[1,14],23:[1,15],24:[1,16]},{14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],24:[2,17]},{18:[2,25],21:42,27:59,28:46,29:60,30:[1,43],31:[1,44],32:[1,45],33:41,34:47,35:[1,48],38:[1,27],39:26},{18:[2,26]},{18:[2,30],30:[2,30],31:[2,30],32:[2,30],35:[2,30],38:[2,30]},{18:[2,36],34:61,35:[1,62]},{18:[2,31],30:[2,31],31:[2,31],32:[2,31],35:[2,31],38:[2,31]},{18:[2,32],30:[2,32],31:[2,32],32:[2,32],35:[2,32],38:[2,32]},{18:[2,33],30:[2,33],31:[2,33],32:[2,33],35:[2,33],38:[2,33]},{18:[2,34],30:[2,34],31:[2,34],32:[2,34],35:[2,34],38:[2,34]},{18:[2,35],30:[2,35],31:[2,35],32:[2,35],35:[2,35],38:[2,35]},{18:[2,38],35:[2,38]},{18:[2,48],30:[2,48],31:[2,48],32:[2,48],35:[2,48],36:[1,63],38:[2,48],40:[2,48]},{35:[1,64]},{18:[2,45],30:[2,45],31:[2,45],32:[2,45],35:[2,45],38:[2,45]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],24:[2,10]},{21:65,35:[1,28],39:26},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],24:[2,11]},{14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],24:[2,16]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],24:[2,19]},{5:[2,20],14:[2,20],15:[2,20],16:[2,20],19:[2,20],20:[2,20],22:[2,20],23:[2,20],24:[2,20]},{5:[2,21],14:[2,21],15:[2,21],16:[2,21],19:[2,21],20:[2,21],22:[2,21],23:[2,21],24:[2,21]},{18:[1,66]},{18:[2,24]},{18:[2,29],30:[2,29],31:[2,29],32:[2,29],35:[2,29],38:[2,29]},{18:[2,37],35:[2,37]},{36:[1,63]},{21:67,28:71,30:[1,68],31:[1,69],32:[1,70],35:[1,28],38:[1,27],39:26},{18:[2,47],30:[2,47],31:[2,47],32:[2,47],35:[2,47],38:[2,47],40:[2,47]},{18:[1,72]},{5:[2,22],14:[2,22],15:[2,22],16:[2,22],19:[2,22],20:[2,22],22:[2,22],23:[2,22],24:[2,22]},{18:[2,39],35:[2,39]},{18:[2,40],35:[2,40]},{18:[2,41],35:[2,41]},{18:[2,42],35:[2,42]},{18:[2,43],35:[2,43]},{5:[2,18],14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],24:[2,18]}],
            defaultActions: {17:[2,1],25:[2,28],39:[2,26],59:[2,24]},
            parseError: function parseError(str, hash) {
                throw new Error(str);
            },
            parse: function parse(input) {
                var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                this.yy.parser = this;
                if (typeof this.lexer.yylloc == "undefined")
                    this.lexer.yylloc = {};
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                var ranges = this.lexer.options && this.lexer.options.ranges;
                if (typeof this.yy.parseError === "function")
                    this.parseError = this.yy.parseError;
                function popStack(n) {
                    stack.length = stack.length - 2 * n;
                    vstack.length = vstack.length - n;
                    lstack.length = lstack.length - n;
                }
                function lex() {
                    var token;
                    token = self.lexer.lex() || 1;
                    if (typeof token !== "number") {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == "undefined") {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === "undefined" || !action.length || !action[0]) {
                        var errStr = "";
                        if (!recovering) {
                            expected = [];
                            for (p in table[state])
                                if (this.terminals_[p] && p > 2) {
                                    expected.push("'" + this.terminals_[p] + "'");
                                }
                            if (this.lexer.showPosition) {
                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                            } else {
                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                            }
                            this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
                        }
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0)
                                    recovering--;
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            }
        };
        /* Jison generated lexer */
        var lexer = (function(){
            var lexer = ({EOF:1,
                parseError:function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },
                setInput:function (input) {
                    this._input = input;
                    this._more = this._less = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
                    if (this.options.ranges) this.yylloc.range = [0,0];
                    this.offset = 0;
                    return this;
                },
                input:function () {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) this.yylloc.range[1]++;

                    this._input = this._input.slice(1);
                    return ch;
                },
                unput:function (ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);

                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length-1);
                    this.matched = this.matched.substr(0, this.matched.length-1);

                    if (lines.length-1) this.yylineno -= lines.length-1;
                    var r = this.yylloc.range;

                    this.yylloc = {first_line: this.yylloc.first_line,
                        last_line: this.yylineno+1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ?
                            (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
                            this.yylloc.first_column - len
                    };

                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    return this;
                },
                more:function () {
                    this._more = true;
                    return this;
                },
                less:function (n) {
                    this.unput(this.match.slice(n));
                },
                pastInput:function () {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
                },
                upcomingInput:function () {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20-next.length);
                    }
                    return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
                },
                showPosition:function () {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c+"^";
                },
                next:function () {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) this.done = true;

                    var token,
                        match,
                        tempMatch,
                        index,
                        col,
                        lines;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i=0;i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (!this.options.flex) break;
                        }
                    }
                    if (match) {
                        lines = match[0].match(/(?:\r\n?|\n).*/g);
                        if (lines) this.yylineno += lines.length;
                        this.yylloc = {first_line: this.yylloc.last_line,
                            last_line: this.yylineno+1,
                            first_column: this.yylloc.last_column,
                            last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
                        this.yytext += match[0];
                        this.match += match[0];
                        this.matches = match;
                        this.yyleng = this.yytext.length;
                        if (this.options.ranges) {
                            this.yylloc.range = [this.offset, this.offset += this.yyleng];
                        }
                        this._more = false;
                        this._input = this._input.slice(match[0].length);
                        this.matched += match[0];
                        token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
                        if (this.done && this._input) this.done = false;
                        if (token) return token;
                        else return;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                            {text: "", token: null, line: this.yylineno});
                    }
                },
                lex:function lex() {
                    var r = this.next();
                    if (typeof r !== 'undefined') {
                        return r;
                    } else {
                        return this.lex();
                    }
                },
                begin:function begin(condition) {
                    this.conditionStack.push(condition);
                },
                popState:function popState() {
                    return this.conditionStack.pop();
                },
                _currentRules:function _currentRules() {
                    return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
                },
                topState:function () {
                    return this.conditionStack[this.conditionStack.length-2];
                },
                pushState:function begin(condition) {
                    this.begin(condition);
                }});
            lexer.options = {};
            lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

                var YYSTATE=YY_START
                switch($avoiding_name_collisions) {
                    case 0: yy_.yytext = "\\"; return 14;
                        break;
                    case 1:
                        if(yy_.yytext.slice(-1) !== "\\") this.begin("mu");
                        if(yy_.yytext.slice(-1) === "\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1), this.begin("emu");
                        if(yy_.yytext) return 14;

                        break;
                    case 2: return 14;
                        break;
                    case 3:
                        if(yy_.yytext.slice(-1) !== "\\") this.popState();
                        if(yy_.yytext.slice(-1) === "\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1);
                        return 14;

                        break;
                    case 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng-4); this.popState(); return 15;
                        break;
                    case 5: this.begin("par"); return 24;
                        break;
                    case 6: return 16;
                        break;
                    case 7: return 20;
                        break;
                    case 8: return 19;
                        break;
                    case 9: return 19;
                        break;
                    case 10: return 23;
                        break;
                    case 11: return 23;
                        break;
                    case 12: this.popState(); this.begin('com');
                        break;
                    case 13: yy_.yytext = yy_.yytext.substr(3,yy_.yyleng-5); this.popState(); return 15;
                        break;
                    case 14: return 22;
                        break;
                    case 15: return 36;
                        break;
                    case 16: return 35;
                        break;
                    case 17: return 35;
                        break;
                    case 18: return 40;
                        break;
                    case 19: /*ignore whitespace*/
                        break;
                    case 20: this.popState(); return 18;
                        break;
                    case 21: this.popState(); return 18;
                        break;
                    case 22: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\"/g,'"'); return 30;
                        break;
                    case 23: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\'/g,"'"); return 30;
                        break;
                    case 24: return 38;
                        break;
                    case 25: return 32;
                        break;
                    case 26: return 32;
                        break;
                    case 27: return 31;
                        break;
                    case 28: return 35;
                        break;
                    case 29: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng-2); return 35;
                        break;
                    case 30: return 'INVALID';
                        break;
                    case 31: /*ignore whitespace*/
                        break;
                    case 32: this.popState(); return 37;
                        break;
                    case 33: return 5;
                        break;
                }
            };
            lexer.rules = [/^(?:\\\\(?=(\{\{)))/,/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|$)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\{\{>)/,/^(?:\{\{#)/,/^(?:\{\{\/)/,/^(?:\{\{\^)/,/^(?:\{\{\s*else\b)/,/^(?:\{\{\{)/,/^(?:\{\{&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{)/,/^(?:=)/,/^(?:\.(?=[}\/ ]))/,/^(?:\.\.)/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}\}\})/,/^(?:\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=[}\s]))/,/^(?:false(?=[}\s]))/,/^(?:-?[0-9]+(?=[}\s]))/,/^(?:[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.]))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:\s+)/,/^(?:[a-zA-Z0-9_$\-\/\.]+)/,/^(?:$)/];
            lexer.conditions = {"mu":{"rules":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,33],"inclusive":false},"emu":{"rules":[3],"inclusive":false},"com":{"rules":[4],"inclusive":false},"par":{"rules":[31,32],"inclusive":false},"INITIAL":{"rules":[0,1,2,33],"inclusive":true}};
            return lexer;})()
        parser.lexer = lexer;
        function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
        return new Parser;
    })();;
// lib/handlebars/compiler/base.js

    Handlebars.Parser = handlebars;

    Handlebars.parse = function(input) {

        // Just return if an already-compile AST was passed in.
        if(input.constructor === Handlebars.AST.ProgramNode) { return input; }

        Handlebars.Parser.yy = Handlebars.AST;
        return Handlebars.Parser.parse(input);
    };
    ;
// lib/handlebars/compiler/ast.js
    Handlebars.AST = {};

    Handlebars.AST.ProgramNode = function(statements, inverse) {
        this.type = "program";
        this.statements = statements;
        if(inverse) { this.inverse = new Handlebars.AST.ProgramNode(inverse); }
    };

    Handlebars.AST.MustacheNode = function(rawParams, hash, unescaped) {
        this.type = "mustache";
        this.escaped = !unescaped;
        this.hash = hash;

        var id = this.id = rawParams[0];
        var params = this.params = rawParams.slice(1);

        // a mustache is an eligible helper if:
        // * its id is simple (a single part, not `this` or `..`)
        var eligibleHelper = this.eligibleHelper = id.isSimple;

        // a mustache is definitely a helper if:
        // * it is an eligible helper, and
        // * it has at least one parameter or hash segment
        this.isHelper = eligibleHelper && (params.length || hash);

        // if a mustache is an eligible helper but not a definite
        // helper, it is ambiguous, and will be resolved in a later
        // pass or at runtime.
    };

    Handlebars.AST.PartialNode = function(partialName, context) {
        this.type         = "partial";
        this.partialName  = partialName;
        this.context      = context;
    };

    Handlebars.AST.BlockNode = function(mustache, program, inverse, close) {
        var verifyMatch = function(open, close) {
            if(open.original !== close.original) {
                throw new Handlebars.Exception(open.original + " doesn't match " + close.original);
            }
        };

        verifyMatch(mustache.id, close);
        this.type = "block";
        this.mustache = mustache;
        this.program  = program;
        this.inverse  = inverse;

        if (this.inverse && !this.program) {
            this.isInverse = true;
        }
    };

    Handlebars.AST.ContentNode = function(string) {
        this.type = "content";
        this.string = string;
    };

    Handlebars.AST.HashNode = function(pairs) {
        this.type = "hash";
        this.pairs = pairs;
    };

    Handlebars.AST.IdNode = function(parts) {
        this.type = "ID";

        var original = "",
            dig = [],
            depth = 0;

        for(var i=0,l=parts.length; i<l; i++) {
            var part = parts[i].part;
            original += (parts[i].separator || '') + part;

            if (part === ".." || part === "." || part === "this") {
                if (dig.length > 0) { throw new Handlebars.Exception("Invalid path: " + original); }
                else if (part === "..") { depth++; }
                else { this.isScoped = true; }
            }
            else { dig.push(part); }
        }

        this.original = original;
        this.parts    = dig;
        this.string   = dig.join('.');
        this.depth    = depth;

        // an ID is simple if it only has one part, and that part is not
        // `..` or `this`.
        this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

        this.stringModeValue = this.string;
    };

    Handlebars.AST.PartialNameNode = function(name) {
        this.type = "PARTIAL_NAME";
        this.name = name;
    };

    Handlebars.AST.DataNode = function(id) {
        this.type = "DATA";
        this.id = id;
    };

    Handlebars.AST.StringNode = function(string) {
        this.type = "STRING";
        this.original =
            this.string =
                this.stringModeValue = string;
    };

    Handlebars.AST.IntegerNode = function(integer) {
        this.type = "INTEGER";
        this.original =
            this.integer = integer;
        this.stringModeValue = Number(integer);
    };

    Handlebars.AST.BooleanNode = function(bool) {
        this.type = "BOOLEAN";
        this.bool = bool;
        this.stringModeValue = bool === "true";
    };

    Handlebars.AST.CommentNode = function(comment) {
        this.type = "comment";
        this.comment = comment;
    };
    ;
// lib/handlebars/utils.js

    var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

    Handlebars.Exception = function(message) {
        var tmp = Error.prototype.constructor.apply(this, arguments);

        // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
        for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]];
        }
    };
    Handlebars.Exception.prototype = new Error();

// Build out our basic SafeString type
    Handlebars.SafeString = function(string) {
        this.string = string;
    };
    Handlebars.SafeString.prototype.toString = function() {
        return this.string.toString();
    };

    var escape = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    };

    var badChars = /[&<>"'`]/g;
    var possible = /[&<>"'`]/;

    var escapeChar = function(chr) {
        return escape[chr] || "&amp;";
    };

    Handlebars.Utils = {
        extend: function(obj, value) {
            for(var key in value) {
                if(value.hasOwnProperty(key)) {
                    obj[key] = value[key];
                }
            }
        },

        escapeExpression: function(string) {
            // don't escape SafeStrings, since they're already safe
            if (string instanceof Handlebars.SafeString) {
                return string.toString();
            } else if (string == null || string === false) {
                return "";
            }

            // Force a string conversion as this will be done by the append regardless and
            // the regex test will do this transparently behind the scenes, causing issues if
            // an object's to string has escaped characters in it.
            string = string.toString();

            if(!possible.test(string)) { return string; }
            return string.replace(badChars, escapeChar);
        },

        isEmpty: function(value) {
            if (!value && value !== 0) {
                return true;
            } else if(toString.call(value) === "[object Array]" && value.length === 0) {
                return true;
            } else {
                return false;
            }
        }
    };
    ;
// lib/handlebars/compiler/compiler.js

    /*jshint eqnull:true*/
    var Compiler = Handlebars.Compiler = function() {};
    var JavaScriptCompiler = Handlebars.JavaScriptCompiler = function() {};

// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

    Compiler.prototype = {
        compiler: Compiler,

        disassemble: function() {
            var opcodes = this.opcodes, opcode, out = [], params, param;

            for (var i=0, l=opcodes.length; i<l; i++) {
                opcode = opcodes[i];

                if (opcode.opcode === 'DECLARE') {
                    out.push("DECLARE " + opcode.name + "=" + opcode.value);
                } else {
                    params = [];
                    for (var j=0; j<opcode.args.length; j++) {
                        param = opcode.args[j];
                        if (typeof param === "string") {
                            param = "\"" + param.replace("\n", "\\n") + "\"";
                        }
                        params.push(param);
                    }
                    out.push(opcode.opcode + " " + params.join(" "));
                }
            }

            return out.join("\n");
        },
        equals: function(other) {
            var len = this.opcodes.length;
            if (other.opcodes.length !== len) {
                return false;
            }

            for (var i = 0; i < len; i++) {
                var opcode = this.opcodes[i],
                    otherOpcode = other.opcodes[i];
                if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
                    return false;
                }
                for (var j = 0; j < opcode.args.length; j++) {
                    if (opcode.args[j] !== otherOpcode.args[j]) {
                        return false;
                    }
                }
            }

            len = this.children.length;
            if (other.children.length !== len) {
                return false;
            }
            for (i = 0; i < len; i++) {
                if (!this.children[i].equals(other.children[i])) {
                    return false;
                }
            }

            return true;
        },

        guid: 0,

        compile: function(program, options) {
            this.children = [];
            this.depths = {list: []};
            this.options = options;

            // These changes will propagate to the other compiler components
            var knownHelpers = this.options.knownHelpers;
            this.options.knownHelpers = {
                'helperMissing': true,
                'blockHelperMissing': true,
                'each': true,
                'if': true,
                'unless': true,
                'with': true,
                'log': true
            };
            if (knownHelpers) {
                for (var name in knownHelpers) {
                    this.options.knownHelpers[name] = knownHelpers[name];
                }
            }

            return this.program(program);
        },

        accept: function(node) {
            return this[node.type](node);
        },

        program: function(program) {
            var statements = program.statements, statement;
            this.opcodes = [];

            for(var i=0, l=statements.length; i<l; i++) {
                statement = statements[i];
                this[statement.type](statement);
            }
            this.isSimple = l === 1;

            this.depths.list = this.depths.list.sort(function(a, b) {
                return a - b;
            });

            return this;
        },

        compileProgram: function(program) {
            var result = new this.compiler().compile(program, this.options);
            var guid = this.guid++, depth;

            this.usePartial = this.usePartial || result.usePartial;

            this.children[guid] = result;

            for(var i=0, l=result.depths.list.length; i<l; i++) {
                depth = result.depths.list[i];

                if(depth < 2) { continue; }
                else { this.addDepth(depth - 1); }
            }

            return guid;
        },

        block: function(block) {
            var mustache = block.mustache,
                program = block.program,
                inverse = block.inverse;

            if (program) {
                program = this.compileProgram(program);
            }

            if (inverse) {
                inverse = this.compileProgram(inverse);
            }

            var type = this.classifyMustache(mustache);

            if (type === "helper") {
                this.helperMustache(mustache, program, inverse);
            } else if (type === "simple") {
                this.simpleMustache(mustache);

                // now that the simple mustache is resolved, we need to
                // evaluate it by executing `blockHelperMissing`
                this.opcode('pushProgram', program);
                this.opcode('pushProgram', inverse);
                this.opcode('emptyHash');
                this.opcode('blockValue');
            } else {
                this.ambiguousMustache(mustache, program, inverse);

                // now that the simple mustache is resolved, we need to
                // evaluate it by executing `blockHelperMissing`
                this.opcode('pushProgram', program);
                this.opcode('pushProgram', inverse);
                this.opcode('emptyHash');
                this.opcode('ambiguousBlockValue');
            }

            this.opcode('append');
        },

        hash: function(hash) {
            var pairs = hash.pairs, pair, val;

            this.opcode('pushHash');

            for(var i=0, l=pairs.length; i<l; i++) {
                pair = pairs[i];
                val  = pair[1];

                if (this.options.stringParams) {
                    if(val.depth) {
                        this.addDepth(val.depth);
                    }
                    this.opcode('getContext', val.depth || 0);
                    this.opcode('pushStringParam', val.stringModeValue, val.type);
                } else {
                    this.accept(val);
                }

                this.opcode('assignToHash', pair[0]);
            }
            this.opcode('popHash');
        },

        partial: function(partial) {
            var partialName = partial.partialName;
            this.usePartial = true;

            if(partial.context) {
                this.ID(partial.context);
            } else {
                this.opcode('push', 'depth0');
            }

            this.opcode('invokePartial', partialName.name);
            this.opcode('append');
        },

        content: function(content) {
            this.opcode('appendContent', content.string);
        },

        mustache: function(mustache) {
            var options = this.options;
            var type = this.classifyMustache(mustache);

            if (type === "simple") {
                this.simpleMustache(mustache);
            } else if (type === "helper") {
                this.helperMustache(mustache);
            } else {
                this.ambiguousMustache(mustache);
            }

            if(mustache.escaped && !options.noEscape) {
                this.opcode('appendEscaped');
            } else {
                this.opcode('append');
            }
        },

        ambiguousMustache: function(mustache, program, inverse) {
            var id = mustache.id,
                name = id.parts[0],
                isBlock = program != null || inverse != null;

            this.opcode('getContext', id.depth);

            this.opcode('pushProgram', program);
            this.opcode('pushProgram', inverse);

            this.opcode('invokeAmbiguous', name, isBlock);
        },

        simpleMustache: function(mustache) {
            var id = mustache.id;

            if (id.type === 'DATA') {
                this.DATA(id);
            } else if (id.parts.length) {
                this.ID(id);
            } else {
                // Simplified ID for `this`
                this.addDepth(id.depth);
                this.opcode('getContext', id.depth);
                this.opcode('pushContext');
            }

            this.opcode('resolvePossibleLambda');
        },

        helperMustache: function(mustache, program, inverse) {
            var params = this.setupFullMustacheParams(mustache, program, inverse),
                name = mustache.id.parts[0];

            if (this.options.knownHelpers[name]) {
                this.opcode('invokeKnownHelper', params.length, name);
            } else if (this.options.knownHelpersOnly) {
                throw new Error("You specified knownHelpersOnly, but used the unknown helper " + name);
            } else {
                this.opcode('invokeHelper', params.length, name);
            }
        },

        ID: function(id) {
            this.addDepth(id.depth);
            this.opcode('getContext', id.depth);

            var name = id.parts[0];
            if (!name) {
                this.opcode('pushContext');
            } else {
                this.opcode('lookupOnContext', id.parts[0]);
            }

            for(var i=1, l=id.parts.length; i<l; i++) {
                this.opcode('lookup', id.parts[i]);
            }
        },

        DATA: function(data) {
            this.options.data = true;
            if (data.id.isScoped || data.id.depth) {
                throw new Handlebars.Exception('Scoped data references are not supported: ' + data.original);
            }

            this.opcode('lookupData');
            var parts = data.id.parts;
            for(var i=0, l=parts.length; i<l; i++) {
                this.opcode('lookup', parts[i]);
            }
        },

        STRING: function(string) {
            this.opcode('pushString', string.string);
        },

        INTEGER: function(integer) {
            this.opcode('pushLiteral', integer.integer);
        },

        BOOLEAN: function(bool) {
            this.opcode('pushLiteral', bool.bool);
        },

        comment: function() {},

        // HELPERS
        opcode: function(name) {
            this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });
        },

        declare: function(name, value) {
            this.opcodes.push({ opcode: 'DECLARE', name: name, value: value });
        },

        addDepth: function(depth) {
            if(isNaN(depth)) { throw new Error("EWOT"); }
            if(depth === 0) { return; }

            if(!this.depths[depth]) {
                this.depths[depth] = true;
                this.depths.list.push(depth);
            }
        },

        classifyMustache: function(mustache) {
            var isHelper   = mustache.isHelper;
            var isEligible = mustache.eligibleHelper;
            var options    = this.options;

            // if ambiguous, we can possibly resolve the ambiguity now
            if (isEligible && !isHelper) {
                var name = mustache.id.parts[0];

                if (options.knownHelpers[name]) {
                    isHelper = true;
                } else if (options.knownHelpersOnly) {
                    isEligible = false;
                }
            }

            if (isHelper) { return "helper"; }
            else if (isEligible) { return "ambiguous"; }
            else { return "simple"; }
        },

        pushParams: function(params) {
            var i = params.length, param;

            while(i--) {
                param = params[i];

                if(this.options.stringParams) {
                    if(param.depth) {
                        this.addDepth(param.depth);
                    }

                    this.opcode('getContext', param.depth || 0);
                    this.opcode('pushStringParam', param.stringModeValue, param.type);
                } else {
                    this[param.type](param);
                }
            }
        },

        setupMustacheParams: function(mustache) {
            var params = mustache.params;
            this.pushParams(params);

            if(mustache.hash) {
                this.hash(mustache.hash);
            } else {
                this.opcode('emptyHash');
            }

            return params;
        },

        // this will replace setupMustacheParams when we're done
        setupFullMustacheParams: function(mustache, program, inverse) {
            var params = mustache.params;
            this.pushParams(params);

            this.opcode('pushProgram', program);
            this.opcode('pushProgram', inverse);

            if(mustache.hash) {
                this.hash(mustache.hash);
            } else {
                this.opcode('emptyHash');
            }

            return params;
        }
    };

    var Literal = function(value) {
        this.value = value;
    };

    JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function(parent, name /* , type*/) {
            if (/^[0-9]+$/.test(name)) {
                return parent + "[" + name + "]";
            } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                return parent + "." + name;
            }
            else {
                return parent + "['" + name + "']";
            }
        },

        appendToBuffer: function(string) {
            if (this.environment.isSimple) {
                return "return " + string + ";";
            } else {
                return {
                    appendToBuffer: true,
                    content: string,
                    toString: function() { return "buffer += " + string + ";"; }
                };
            }
        },

        initializeBuffer: function() {
            return this.quotedString("");
        },

        namespace: "Handlebars",
        // END PUBLIC API

        compile: function(environment, options, context, asObject) {
            this.environment = environment;
            this.options = options || {};

            Handlebars.log(Handlebars.logger.DEBUG, this.environment.disassemble() + "\n\n");

            this.name = this.environment.name;
            this.isChild = !!context;
            this.context = context || {
                programs: [],
                environments: [],
                aliases: { }
            };

            this.preamble();

            this.stackSlot = 0;
            this.stackVars = [];
            this.registers = { list: [] };
            this.compileStack = [];
            this.inlineStack = [];

            this.compileChildren(environment, options);

            var opcodes = environment.opcodes, opcode;

            this.i = 0;

            for(l=opcodes.length; this.i<l; this.i++) {
                opcode = opcodes[this.i];

                if(opcode.opcode === 'DECLARE') {
                    this[opcode.name] = opcode.value;
                } else {
                    this[opcode.opcode].apply(this, opcode.args);
                }
            }

            return this.createFunctionContext(asObject);
        },

        nextOpcode: function() {
            var opcodes = this.environment.opcodes;
            return opcodes[this.i + 1];
        },

        eat: function() {
            this.i = this.i + 1;
        },

        preamble: function() {
            var out = [];

            if (!this.isChild) {
                var namespace = this.namespace;
                var copies = "helpers = helpers || " + namespace + ".helpers;";
                if (this.environment.usePartial) { copies = copies + " partials = partials || " + namespace + ".partials;"; }
                if (this.options.data) { copies = copies + " data = data || {};"; }
                out.push(copies);
            } else {
                out.push('');
            }

            if (!this.environment.isSimple) {
                out.push(", buffer = " + this.initializeBuffer());
            } else {
                out.push("");
            }

            // track the last context pushed into place to allow skipping the
            // getContext opcode when it would be a noop
            this.lastContext = 0;
            this.source = out;
        },

        createFunctionContext: function(asObject) {
            var locals = this.stackVars.concat(this.registers.list);

            if(locals.length > 0) {
                this.source[1] = this.source[1] + ", " + locals.join(", ");
            }

            // Generate minimizer alias mappings
            if (!this.isChild) {
                for (var alias in this.context.aliases) {
                    if (this.context.aliases.hasOwnProperty(alias)) {
                        this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];
                    }
                }
            }

            if (this.source[1]) {
                this.source[1] = "var " + this.source[1].substring(2) + ";";
            }

            // Merge children
            if (!this.isChild) {
                this.source[1] += '\n' + this.context.programs.join('\n') + '\n';
            }

            if (!this.environment.isSimple) {
                this.source.push("return buffer;");
            }

            var params = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"];

            for(var i=0, l=this.environment.depths.list.length; i<l; i++) {
                params.push("depth" + this.environment.depths.list[i]);
            }

            // Perform a second pass over the output to merge content when possible
            var source = this.mergeSource();

            if (!this.isChild) {
                var revision = Handlebars.COMPILER_REVISION,
                    versions = Handlebars.REVISION_CHANGES[revision];
                source = "this.compilerInfo = ["+revision+",'"+versions+"'];\n"+source;
            }

            if (asObject) {
                params.push(source);

                return Function.apply(this, params);
            } else {
                var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\n  ' + source + '}';
                Handlebars.log(Handlebars.logger.DEBUG, functionSource + "\n\n");
                return functionSource;
            }
        },
        mergeSource: function() {
            // WARN: We are not handling the case where buffer is still populated as the source should
            // not have buffer append operations as their final action.
            var source = '',
                buffer;
            for (var i = 0, len = this.source.length; i < len; i++) {
                var line = this.source[i];
                if (line.appendToBuffer) {
                    if (buffer) {
                        buffer = buffer + '\n    + ' + line.content;
                    } else {
                        buffer = line.content;
                    }
                } else {
                    if (buffer) {
                        source += 'buffer += ' + buffer + ';\n  ';
                        buffer = undefined;
                    }
                    source += line + '\n  ';
                }
            }
            return source;
        },

        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function() {
            this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

            var params = ["depth0"];
            this.setupParams(0, params);

            this.replaceStack(function(current) {
                params.splice(1, 0, current);
                return "blockHelperMissing.call(" + params.join(", ") + ")";
            });
        },

        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function() {
            this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

            var params = ["depth0"];
            this.setupParams(0, params);

            var current = this.topStack();
            params.splice(1, 0, current);

            // Use the options value generated from the invocation
            params[params.length-1] = 'options';

            this.source.push("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
        },

        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function(content) {
            this.source.push(this.appendToBuffer(this.quotedString(content)));
        },

        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function() {
            // Force anything that is inlined onto the stack so we don't have duplication
            // when we examine local
            this.flushInline();
            var local = this.popStack();
            this.source.push("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
            if (this.environment.isSimple) {
                this.source.push("else { " + this.appendToBuffer("''") + " }");
            }
        },

        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function() {
            this.context.aliases.escapeExpression = 'this.escapeExpression';

            this.source.push(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
        },

        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function(depth) {
            if(this.lastContext !== depth) {
                this.lastContext = depth;
            }
        },

        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function(name) {
            this.push(this.nameLookup('depth' + this.lastContext, name, 'context'));
        },

        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function() {
            this.pushStackLiteral('depth' + this.lastContext);
        },

        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function() {
            this.context.aliases.functionType = '"function"';

            this.replaceStack(function(current) {
                return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
            });
        },

        // [lookup]
        //
        // On stack, before: value, ...
        // On stack, after: value[name], ...
        //
        // Replace the value on the stack with the result of looking
        // up `name` on `value`
        lookup: function(name) {
            this.replaceStack(function(current) {
                return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, 'context');
            });
        },

        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data[id], ...
        //
        // Push the result of looking up `id` on the current data
        lookupData: function(id) {
            this.push('data');
        },

        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function(string, type) {
            this.pushStackLiteral('depth' + this.lastContext);

            this.pushString(type);

            if (typeof string === 'string') {
                this.pushString(string);
            } else {
                this.pushStackLiteral(string);
            }
        },

        emptyHash: function() {
            this.pushStackLiteral('{}');

            if (this.options.stringParams) {
                this.register('hashTypes', '{}');
                this.register('hashContexts', '{}');
            }
        },
        pushHash: function() {
            this.hash = {values: [], types: [], contexts: []};
        },
        popHash: function() {
            var hash = this.hash;
            this.hash = undefined;

            if (this.options.stringParams) {
                this.register('hashContexts', '{' + hash.contexts.join(',') + '}');
                this.register('hashTypes', '{' + hash.types.join(',') + '}');
            }
            this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
        },

        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function(string) {
            this.pushStackLiteral(this.quotedString(string));
        },

        // [push]
        //
        // On stack, before: ...
        // On stack, after: expr, ...
        //
        // Push an expression onto the stack
        push: function(expr) {
            this.inlineStack.push(expr);
            return expr;
        },

        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function(value) {
            this.pushStackLiteral(value);
        },

        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function(guid) {
            if (guid != null) {
                this.pushStackLiteral(this.programExpression(guid));
            } else {
                this.pushStackLiteral(null);
            }
        },

        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function(paramSize, name) {
            this.context.aliases.helperMissing = 'helpers.helperMissing';

            var helper = this.lastHelper = this.setupHelper(paramSize, name, true);

            this.push(helper.name);
            this.replaceStack(function(name) {
                return name + ' ? ' + name + '.call(' +
                    helper.callParams + ") " + ": helperMissing.call(" +
                    helper.helperMissingParams + ")";
            });
        },

        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function(paramSize, name) {
            var helper = this.setupHelper(paramSize, name);
            this.push(helper.name + ".call(" + helper.callParams + ")");
        },

        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function(name, helperCall) {
            this.context.aliases.functionType = '"function"';

            this.pushStackLiteral('{}');    // Hash value
            var helper = this.setupHelper(0, name, helperCall);

            var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

            var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');
            var nextStack = this.nextStack();

            this.source.push('if (' + nextStack + ' = ' + helperName + ') { ' + nextStack + ' = ' + nextStack + '.call(' + helper.callParams + '); }');
            this.source.push('else { ' + nextStack + ' = ' + nonHelper + '; ' + nextStack + ' = typeof ' + nextStack + ' === functionType ? ' + nextStack + '.apply(depth0) : ' + nextStack + '; }');
        },

        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function(name) {
            var params = [this.nameLookup('partials', name, 'partial'), "'" + name + "'", this.popStack(), "helpers", "partials"];

            if (this.options.data) {
                params.push("data");
            }

            this.context.aliases.self = "this";
            this.push("self.invokePartial(" + params.join(", ") + ")");
        },

        // [assignToHash]
        //
        // On stack, before: value, hash, ...
        // On stack, after: hash, ...
        //
        // Pops a value and hash off the stack, assigns `hash[key] = value`
        // and pushes the hash back onto the stack.
        assignToHash: function(key) {
            var value = this.popStack(),
                context,
                type;

            if (this.options.stringParams) {
                type = this.popStack();
                context = this.popStack();
            }

            var hash = this.hash;
            if (context) {
                hash.contexts.push("'" + key + "': " + context);
            }
            if (type) {
                hash.types.push("'" + key + "': " + type);
            }
            hash.values.push("'" + key + "': (" + value + ")");
        },

        // HELPERS

        compiler: JavaScriptCompiler,

        compileChildren: function(environment, options) {
            var children = environment.children, child, compiler;

            for(var i=0, l=children.length; i<l; i++) {
                child = children[i];
                compiler = new this.compiler();

                var index = this.matchExistingProgram(child);

                if (index == null) {
                    this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
                    index = this.context.programs.length;
                    child.index = index;
                    child.name = 'program' + index;
                    this.context.programs[index] = compiler.compile(child, options, this.context);
                    this.context.environments[index] = child;
                } else {
                    child.index = index;
                    child.name = 'program' + index;
                }
            }
        },
        matchExistingProgram: function(child) {
            for (var i = 0, len = this.context.environments.length; i < len; i++) {
                var environment = this.context.environments[i];
                if (environment && environment.equals(child)) {
                    return i;
                }
            }
        },

        programExpression: function(guid) {
            this.context.aliases.self = "this";

            if(guid == null) {
                return "self.noop";
            }

            var child = this.environment.children[guid],
                depths = child.depths.list, depth;

            var programParams = [child.index, child.name, "data"];

            for(var i=0, l = depths.length; i<l; i++) {
                depth = depths[i];

                if(depth === 1) { programParams.push("depth0"); }
                else { programParams.push("depth" + (depth - 1)); }
            }

            return (depths.length === 0 ? "self.program(" : "self.programWithDepth(") + programParams.join(", ") + ")";
        },

        register: function(name, val) {
            this.useRegister(name);
            this.source.push(name + " = " + val + ";");
        },

        useRegister: function(name) {
            if(!this.registers[name]) {
                this.registers[name] = true;
                this.registers.list.push(name);
            }
        },

        pushStackLiteral: function(item) {
            return this.push(new Literal(item));
        },

        pushStack: function(item) {
            this.flushInline();

            var stack = this.incrStack();
            if (item) {
                this.source.push(stack + " = " + item + ";");
            }
            this.compileStack.push(stack);
            return stack;
        },

        replaceStack: function(callback) {
            var prefix = '',
                inline = this.isInline(),
                stack;

            // If we are currently inline then we want to merge the inline statement into the
            // replacement statement via ','
            if (inline) {
                var top = this.popStack(true);

                if (top instanceof Literal) {
                    // Literals do not need to be inlined
                    stack = top.value;
                } else {
                    // Get or create the current stack name for use by the inline
                    var name = this.stackSlot ? this.topStackName() : this.incrStack();

                    prefix = '(' + this.push(name) + ' = ' + top + '),';
                    stack = this.topStack();
                }
            } else {
                stack = this.topStack();
            }

            var item = callback.call(this, stack);

            if (inline) {
                if (this.inlineStack.length || this.compileStack.length) {
                    this.popStack();
                }
                this.push('(' + prefix + item + ')');
            } else {
                // Prevent modification of the context depth variable. Through replaceStack
                if (!/^stack/.test(stack)) {
                    stack = this.nextStack();
                }

                this.source.push(stack + " = (" + prefix + item + ");");
            }
            return stack;
        },

        nextStack: function() {
            return this.pushStack();
        },

        incrStack: function() {
            this.stackSlot++;
            if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
            return this.topStackName();
        },
        topStackName: function() {
            return "stack" + this.stackSlot;
        },
        flushInline: function() {
            var inlineStack = this.inlineStack;
            if (inlineStack.length) {
                this.inlineStack = [];
                for (var i = 0, len = inlineStack.length; i < len; i++) {
                    var entry = inlineStack[i];
                    if (entry instanceof Literal) {
                        this.compileStack.push(entry);
                    } else {
                        this.pushStack(entry);
                    }
                }
            }
        },
        isInline: function() {
            return this.inlineStack.length;
        },

        popStack: function(wrapped) {
            var inline = this.isInline(),
                item = (inline ? this.inlineStack : this.compileStack).pop();

            if (!wrapped && (item instanceof Literal)) {
                return item.value;
            } else {
                if (!inline) {
                    this.stackSlot--;
                }
                return item;
            }
        },

        topStack: function(wrapped) {
            var stack = (this.isInline() ? this.inlineStack : this.compileStack),
                item = stack[stack.length - 1];

            if (!wrapped && (item instanceof Literal)) {
                return item.value;
            } else {
                return item;
            }
        },

        quotedString: function(str) {
            return '"' + str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
                .replace(/\u2029/g, '\\u2029') + '"';
        },

        setupHelper: function(paramSize, name, missingParams) {
            var params = [];
            this.setupParams(paramSize, params, missingParams);
            var foundHelper = this.nameLookup('helpers', name, 'helper');

            return {
                params: params,
                name: foundHelper,
                callParams: ["depth0"].concat(params).join(", "),
                helperMissingParams: missingParams && ["depth0", this.quotedString(name)].concat(params).join(", ")
            };
        },

        // the params and contexts arguments are passed in arrays
        // to fill in
        setupParams: function(paramSize, params, useRegister) {
            var options = [], contexts = [], types = [], param, inverse, program;

            options.push("hash:" + this.popStack());

            inverse = this.popStack();
            program = this.popStack();

            // Avoid setting fn and inverse if neither are set. This allows
            // helpers to do a check for `if (options.fn)`
            if (program || inverse) {
                if (!program) {
                    this.context.aliases.self = "this";
                    program = "self.noop";
                }

                if (!inverse) {
                    this.context.aliases.self = "this";
                    inverse = "self.noop";
                }

                options.push("inverse:" + inverse);
                options.push("fn:" + program);
            }

            for(var i=0; i<paramSize; i++) {
                param = this.popStack();
                params.push(param);

                if(this.options.stringParams) {
                    types.push(this.popStack());
                    contexts.push(this.popStack());
                }
            }

            if (this.options.stringParams) {
                options.push("contexts:[" + contexts.join(",") + "]");
                options.push("types:[" + types.join(",") + "]");
                options.push("hashContexts:hashContexts");
                options.push("hashTypes:hashTypes");
            }

            if(this.options.data) {
                options.push("data:data");
            }

            options = "{" + options.join(",") + "}";
            if (useRegister) {
                this.register('options', options);
                params.push('options');
            } else {
                params.push(options);
            }
            return params.join(", ");
        }
    };

    var reservedWords = (
        "break else new var" +
            " case finally return void" +
            " catch for switch while" +
            " continue function this with" +
            " default if throw" +
            " delete in try" +
            " do instanceof typeof" +
            " abstract enum int short" +
            " boolean export interface static" +
            " byte extends long super" +
            " char final native synchronized" +
            " class float package throws" +
            " const goto private transient" +
            " debugger implements protected volatile" +
            " double import public let yield"
        ).split(" ");

    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

    for(var i=0, l=reservedWords.length; i<l; i++) {
        compilerWords[reservedWords[i]] = true;
    }

    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        if(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name)) {
            return true;
        }
        return false;
    };

    Handlebars.precompile = function(input, options) {
        if (input == null || (typeof input !== 'string' && input.constructor !== Handlebars.AST.ProgramNode)) {
            throw new Handlebars.Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
        }

        options = options || {};
        if (!('data' in options)) {
            options.data = true;
        }
        var ast = Handlebars.parse(input);
        var environment = new Compiler().compile(ast, options);
        return new JavaScriptCompiler().compile(environment, options);
    };

    Handlebars.compile = function(input, options) {
        if (input == null || (typeof input !== 'string' && input.constructor !== Handlebars.AST.ProgramNode)) {
            throw new Handlebars.Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
        }

        options = options || {};
        if (!('data' in options)) {
            options.data = true;
        }
        var compiled;
        function compile() {
            var ast = Handlebars.parse(input);
            var environment = new Compiler().compile(ast, options);
            var templateSpec = new JavaScriptCompiler().compile(environment, options, undefined, true);
            return Handlebars.template(templateSpec);
        }

        // Template is only compiled on first use and cached after that point.
        return function(context, options) {
            if (!compiled) {
                compiled = compile();
            }
            return compiled.call(this, context, options);
        };
    };

    ;
// lib/handlebars/runtime.js

    Handlebars.VM = {
        template: function(templateSpec) {
            // Just add water
            var container = {
                escapeExpression: Handlebars.Utils.escapeExpression,
                invokePartial: Handlebars.VM.invokePartial,
                programs: [],
                program: function(i, fn, data) {
                    var programWrapper = this.programs[i];
                    if(data) {
                        programWrapper = Handlebars.VM.program(i, fn, data);
                    } else if (!programWrapper) {
                        programWrapper = this.programs[i] = Handlebars.VM.program(i, fn);
                    }
                    return programWrapper;
                },
                programWithDepth: Handlebars.VM.programWithDepth,
                noop: Handlebars.VM.noop,
                compilerInfo: null
            };

            return function(context, options) {
                options = options || {};
                var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);

                var compilerInfo = container.compilerInfo || [],
                    compilerRevision = compilerInfo[0] || 1,
                    currentRevision = Handlebars.COMPILER_REVISION;

                if (compilerRevision !== currentRevision) {
                    if (compilerRevision < currentRevision) {
                        var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision],
                            compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
                        throw "Template was precompiled with an older version of Handlebars than the current runtime. "+
                            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").";
                    } else {
                        // Use the embedded version info since the runtime doesn't know about this revision yet
                        throw "Template was precompiled with a newer version of Handlebars than the current runtime. "+
                            "Please update your runtime to a newer version ("+compilerInfo[1]+").";
                    }
                }

                return result;
            };
        },

        programWithDepth: function(i, fn, data /*, $depth */) {
            var args = Array.prototype.slice.call(arguments, 3);

            var program = function(context, options) {
                options = options || {};

                return fn.apply(this, [context, options.data || data].concat(args));
            };
            program.program = i;
            program.depth = args.length;
            return program;
        },
        program: function(i, fn, data) {
            var program = function(context, options) {
                options = options || {};

                return fn(context, options.data || data);
            };
            program.program = i;
            program.depth = 0;
            return program;
        },
        noop: function() { return ""; },
        invokePartial: function(partial, name, context, helpers, partials, data) {
            var options = { helpers: helpers, partials: partials, data: data };

            if(partial === undefined) {
                throw new Handlebars.Exception("The partial " + name + " could not be found");
            } else if(partial instanceof Function) {
                return partial(context, options);
            } else if (!Handlebars.compile) {
                throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
            } else {
                partials[name] = Handlebars.compile(partial, {data: data !== undefined});
                return partials[name](context, options);
            }
        }
    };

    Handlebars.template = Handlebars.VM.template;
    ;

    // AMD Define
    define('handlebars',[],function(){
        return Handlebars;
    });

// lib/handlebars/browser-suffix.js
})(Handlebars);
;
define('i18nprecompile',['handlebars', "underscore"], function ( Handlebars, _ ) {

  function replaceLocaleStrings ( ast, mapping, options ) {
    options = options || {};
    mapping = mapping || {};
    // Base set of things
    if ( ast && ast.type === "program" && ast.statements ) {
      _(ast.statements).forEach(function(statement, i){
        var newString = "<!-- i18n error -->";
        // If it's a translation node
        if ( statement.type == "mustache" && statement.id && statement.id.original == "$" ) {

          if ( statement.params.length && statement.params[0].string ) {
            var key = statement.params[0].string;
            newString = mapping[ key ] || (options.originalKeyFallback ? key : newString);
          }
          ast.statements[i] = new Handlebars.AST.ContentNode(newString);
        }
        // If we need to recurse
        else if ( statement.program ) {
          statement.program = replaceLocaleStrings( statement.program, mapping, options );
        }
      });
      // Also cover the else blocks
      if (ast.inverse) {
        replaceLocaleStrings(ast.inverse, mapping, options);
      }
    }
    return ast;
  }

  return function(string, mapping, options) {
    options = options || {};
    var ast, environment;
    ast = Handlebars.parse(string);
    // avoid replacing locale if mapping is `false`
    if (mapping !== false) {
        ast = replaceLocaleStrings(ast, mapping, options);
    }
    environment = new Handlebars.Compiler().compile(ast, options);
    return new Handlebars.JavaScriptCompiler().compile(environment, options);
  };
});
;
/*
    http://www.JSON.org/json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

(function (window){

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

// Return the window JSON element if it exists;
var JSON = window.JSON || {};

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

define('json2',[],function(){
    return JSON;
});
// otherwise just leave it alone
    
}).call(this, this);
;
/**
 * @license handlebars hbs 0.4.0 - Alex Sexton, but Handlebars has it's own licensing junk
 *
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/require-cs for details on the plugin this was based off of
 */

/* Yes, deliciously evil. */
/*jslint evil: true, strict: false, plusplus: false, regexp: false */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
define: false, process: false, window: false */
define('hbs',[
'handlebars', 'underscore', 'i18nprecompile', 'json2'
], function (
 Handlebars, _, precompile, JSON
) {
  var fs, getXhr,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        fetchText = function () {
            throw new Error('Environment unsupported.');
        },
        buildMap = [],
        filecode = "w+",
        templateExtension = "hbs",
        customNameExtension = "@hbs",
        devStyleDirectory = "/styles/",
        buildStyleDirectory = "/demo-build/styles/",
        helperDirectory = "template/helpers/",
        i18nDirectory = "template/i18n/",
        buildCSSFileName = "screen.build.css";

    if (typeof window !== "undefined" && window.navigator && window.document && !window.navigator.userAgent.match(/Node.js/)) {
        // Browser action
        getXhr = function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else {
                for (i = 0; i < 3; i++) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            if (!xhr) {
                throw new Error("getXhr(): XMLHttpRequest not available");
            }

            return xhr;
        };

        fetchText = function (url, callback) {
            var xhr = getXhr();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function (evt) {
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    callback(xhr.responseText);
                }
            };
            xhr.send(null);
        };

    } else if (typeof process !== "undefined" &&
               process.versions &&
               !!process.versions.node) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');
        fetchText = function ( path, callback ) {
            var body = fs.readFileSync(path, 'utf8') || "";
            // we need to remove BOM stuff from the file content
            body = body.replace(/^\uFEFF/, '');
            callback(body);
        };
    } else if (typeof java !== "undefined" && typeof java.io !== "undefined") {
        fetchText = function(path, callback) {
            var f = new java.io.File(path);
            var is = new java.io.FileReader(f);
            var reader = new java.io.BufferedReader(is);
            var line;
            var text = "";
            while ((line = reader.readLine()) !== null) {
                text += new String(line) + "\n";
            }
            reader.close();
            callback(text);
        };
    }

    var cache = {};
    var fetchOrGetCached = function ( path, callback ){
      if ( cache[path] ){
        callback(cache[path]);
      }
      else {
        fetchText(path, function(data){
          cache[path] = data;
          callback.call(this, data);
        });
      }
    };
    var styleList = [], styleMap = {};

      return {

        get: function () {
            return Handlebars;
        },

        write: function (pluginName, name, write) {

            if ( (name + customNameExtension ) in buildMap) {
                var text = buildMap[name + customNameExtension];
                write.asModule(pluginName + "!" + name, text);
            }
        },

        version: '0.4.0',

        load: function (name, parentRequire, load, config) {
          
            var compiledName = name + customNameExtension,
                disableI18n = (config.hbs && config.hbs.disableI18n),
                partialDeps = [];

            function recursiveNodeSearch( statements, res ) {
              _(statements).forEach(function ( statement ) {
                if ( statement && statement.type && statement.type === 'partial' ) {
                    res.push(statement.id.string);
                }
                if ( statement && statement.program && statement.program.statements ) {
                  recursiveNodeSearch( statement.program.statements, res );
                }
                if ( statement && statement.program && statement.program.inverse && statement.program.inverse.statements ) {
                  recursiveNodeSearch( statement.program.inverse.statements, res );
                }
              });
              return res;
            }

            // TODO :: use the parser to do this!
            function findPartialDeps( nodes ) {
              var res   = [];
              if ( nodes && nodes.statements ) {
                res = recursiveNodeSearch( nodes.statements, [] );
              }
              return _(res).unique();
            }

            // See if the first item is a comment that's json
            function getMetaData( nodes ) {
              var statement, res, test;
              if ( nodes && nodes.statements ) {
                statement = nodes.statements[0];
                if ( statement && statement.type === "comment" ) {
                  try {
                    res = ( statement.comment ).replace(new RegExp('^[\\s]+|[\\s]+$', 'g'), '');
                    test = JSON.parse(res);
                    return res;
                  }
                  catch (e) {
                    return "{}";
                  }
                }
              }
              return "{}";
            }
            function composeParts ( parts ) {
              if ( !parts ) {
                return [];
              }
              var res = [parts[0]],
                  cur = parts[0],
                  i;

              for (i = 1; i < parts.length; ++i) {
                if ( parts.hasOwnProperty(i) ) {
                  cur += "." + parts[i];
                  res.push( cur );
                }
              }
              return res;
            }

            function recursiveVarSearch( statements, res, prefix, helpersres ) {
              prefix = prefix ? prefix+"." : "";

              var  newprefix = "", flag = false;

              // loop through each statement
              _(statements).forEach(function ( statement ) {
                var parts, part, sideways;

                // if it's a mustache block
                if ( statement && statement.type && statement.type === 'mustache' ) {

                  // If it has params, the first part is a helper or something
                  if ( !statement.params || ! statement.params.length ) {
                    parts = composeParts( statement.id.parts );
                    for( part in parts ) {
                      if ( parts[ part ] ) {
                        newprefix = parts[ part ] || newprefix;
                        res.push( prefix + parts[ part ] );
                      }
                    }
                    res.push(prefix + statement.id.string);
                  }

                  var paramsWithoutParts = ['this', '.', '..', './..', '../..', '../../..'];

                  // grab the params
                  if ( statement.params ) {
                    _(statement.params).forEach(function(param) {
                      if ( _(paramsWithoutParts).contains(param.original) ) {
                        helpersres.push(statement.id.string);
                      }

                      parts = composeParts( param.parts );

                      for(var part in parts ) {
                        if ( parts[ part ] ) {
                          newprefix = parts[part] || newprefix;
                          helpersres.push(statement.id.string);
                          res.push( prefix + parts[ part ] );
                        }
                      }
                    });
                  }
                }

                // If it's a meta block
                if ( statement && statement.mustache  ) {
                  recursiveVarSearch( [statement.mustache], res, prefix + newprefix, helpersres );
                }

                // if it's a whole new program
                if ( statement && statement.program && statement.program.statements ) {
                  sideways = recursiveVarSearch([statement.mustache],[], "", helpersres)[0] || "";
                  if ( statement.program.inverse && statement.program.inverse.statements ) {
                    recursiveVarSearch( statement.program.inverse.statements, res, prefix + newprefix + (sideways ? (prefix+newprefix) ? "."+sideways : sideways : ""), helpersres);
                  }
                  recursiveVarSearch( statement.program.statements, res, prefix + newprefix + (sideways ? (prefix+newprefix) ? "."+sideways : sideways : ""), helpersres);
                }
              });
              return res;
            }

            // This finds the Helper dependencies since it's soooo similar
            function getExternalDeps( nodes ) {
              var res   = [];
              var helpersres = [];

              if ( nodes && nodes.statements ) {
                res = recursiveVarSearch( nodes.statements, [], undefined, helpersres );
              }

              var defaultHelpers = ["helperMissing", "blockHelperMissing", "each", "if", "unless", "with"];

              return {
                vars : _(res).chain().unique().map(function(e){
                  if ( e === "" ) {
                    return '.';
                  }
                  if ( e.length && e[e.length-1] === '.' ) {
                    return e.substr(0,e.length-1) + '[]';
                  }
                  return e;
                }).value(),
                helpers : _(helpersres).chain().unique().map(function(e){
                  if ( _(defaultHelpers).contains(e) ) {
                    return undefined;
                  }
                  return e;
                }).compact().value()
              };
            }

            function fetchAndRegister(langMap){
              fetchText(path, function (text) {
                  // for some reason it doesn't include hbs _first_ when i don't add it here...
                  var nodes = Handlebars.parse(text),
                      deps = findPartialDeps( nodes ),
                      meta = getMetaData( nodes ),
                      extDeps = getExternalDeps( nodes ),
                      vars = extDeps.vars,
                      helps = extDeps.helpers || [],
                      depStr = deps.join("', 'hbs!").replace(/_/g, '/'),
                      helpDepStr = config.hbs && config.hbs.disableHelpers ?
                      "" : (function (){
                        var i, paths = [],
                            pathGetter = config.hbs && config.hbs.helperPathCallback
                              ? config.hbs.helperPathCallback
                              : function (name){return (config.hbs && config.hbs.helperDirectory ? config.hbs.helperDirectory : helperDirectory) + name;};

                        for ( i = 0; i < helps.length; i++ ) {
                          paths[i] = "'" + pathGetter(helps[i]) + "'"
                        }
                        return paths;
                      })().join(','),
                      debugOutputStart = "",
                      debugOutputEnd   = "",
                      debugProperties = "",
                      metaObj, head, linkElem;

                  if ( depStr ) {
                    depStr = ",'hbs!" + depStr + "'";
                  }
                  if ( helpDepStr ) {
                    helpDepStr = "," + helpDepStr;
                  }

                  if ( meta !== "{}" ) {
                    try {
                      metaObj = JSON.parse(meta);
                      if ( metaObj && metaObj.styles ) {
                        styleList = _.union(styleList, metaObj.styles);

                        // In dev mode in the browser
                        if ( require.isBrowser && ! config.isBuild ) {
                          head = document.head || document.getElementsByTagName('head')[0];
                          _(metaObj.styles).forEach(function (style) {
                            if ( !styleMap[style] ) {
                              linkElem = document.createElement('link');
                              linkElem.href = config.baseUrl + devStyleDirectory + style + '.css';
                              linkElem.media = 'all';
                              linkElem.rel = 'stylesheet';
                              linkElem.type = 'text/css';
                              head.appendChild(linkElem);
                              styleMap[style] = linkElem;
                            }
                          });
                        }
                        else if ( config.isBuild ) {
                          (function(){
                            var fs  = require.nodeRequire('fs'),
                                str = _(metaObj.styles).map(function (style) {
                                  if (!styleMap[style]) {
                                    styleMap[style] = true;
                                    return "@import url("+style+".css);\n";
                                  }
                                  return "";
                                }).join("\n");

                            // I write out my import statements to a file in order to help me build stuff.
                            // Then I use a tool to inline my import statements afterwards. (you can run r.js on it too)
                            fs.open(__dirname + buildStyleDirectory + buildCSSFileName, filecode, '0666', function( e, id ) {
                              fs.writeSync(id, str, null, encoding='utf8');
                              fs.close(id);
                            });
                            filecode = "a";
                          })();
                        }
                      }
                    }
                    catch(e){
                      console.log('error injecting styles');
                    }
                  }

                  if ( ! config.isBuild && ! config.serverRender ) {
                    debugOutputStart = "<!-- START - " + name + " -->";
                    debugOutputEnd = "<!-- END - " + name + " -->";
                    debugProperties = "t.meta = " + meta + ";\n" +
                                      "t.helpers = " + JSON.stringify(helps) + ";\n" +
                                      "t.deps = " + JSON.stringify(deps) + ";\n" +
                                      "t.vars = " + JSON.stringify(vars) + ";\n";
                  }

                  var mapping = disableI18n? false : _.extend( langMap, config.localeMapping ),
                      prec = precompile( text, mapping, { originalKeyFallback: (config.hbs || {}).originalKeyFallback });

                  text = "/* START_TEMPLATE */\n" +
                         "define(['hbs','handlebars'"+depStr+helpDepStr+"], function( hbs, Handlebars ){ \n" +
                           "var t = Handlebars.template(" + prec + ");\n" +
                           "Handlebars.registerPartial('" + name.replace( /\//g , '_') + "', t);\n" +
                           debugProperties +
                           "return t;\n" +
                         "});\n" +
                         "/* END_TEMPLATE */\n";

                  //Hold on to the transformed text if a build.
                  if (config.isBuild) {
                      buildMap[compiledName] = text;
                  }

                  //IE with conditional comments on cannot handle the
                  //sourceURL trick, so skip it if enabled.
                  /*@if (@_jscript) @else @*/
                  if (!config.isBuild) {
                      text += "\r\n//@ sourceURL=" + path;
                  }
                  /*@end@*/

                  for ( var i in deps ) {
                    if ( deps.hasOwnProperty(i) ) {
                      deps[ i ] = 'hbs!' + deps[ i ].replace(/_/g, '/');
                    }
                  }

                  if ( !config.isBuild ) {
                    require( deps, function (){
                      load.fromText(text);

                      //Give result to load. Need to wait until the module
                      //is fully parse, which will happen after this
                      //execution.
                      parentRequire([name], function (value) {
                        load(value);
                      });
                    });
                  }
                  else {
                    load.fromText(text);

                    //Give result to load. Need to wait until the module
                    //is fully parse, which will happen after this
                    //execution.
                    parentRequire([name], function (value) {
                      load(value);
                    });
                  }

                  if ( config.removeCombined ) {
                    fs.unlinkSync(path);
                  }
              });
            }

            var path = parentRequire.toUrl(name +'.'+ (config.hbs && config.hbs.templateExtension? config.hbs.templateExtension : templateExtension));

            if (disableI18n){
                fetchAndRegister(false);
            } else {
                fetchOrGetCached(parentRequire.toUrl((config.hbs && config.hbs.i18nDirectory ? config.hbs.i18nDirectory : i18nDirectory) + (config.locale || "en_us") + '.json'), function (langMap) {
                  fetchAndRegister(JSON.parse(langMap));
                });
            }
                  }
      };
});
/* END_hbs_PLUGIN */
;
/**
 * @license RequireJS text 2.0.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    'use strict';

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.5',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});
/*!
 * jQuery JavaScript Library v2.1.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:10Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return a 'clean' array
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return just the object
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
    /**michael forbes - belkin - add underscore method to use original version of jquery when there are multiples **/
    _: _jQuery,
	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Support: Firefox <20
		// The try/catch suppresses exceptions thrown when attempting to access
		// the "constructor" property of certain host objects, ie. |window.location|
		// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
		try {
			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
		} catch ( e ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	trim: function( text ) {
		return text == null ? "" : trim.call( text );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.16
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-13
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select t=''><option selected=''></option></select>";

			// Support: IE8, Opera 10-12
			// Nothing should be selected when empty strings follow ^= or $= or *=
			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {
						name = attrs[ i ].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.slice(5) );
							dataAttr( elem, name, data[ name ] );
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) );

	// #11217 - WebKit loses check when the name is after the checked attribute
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				// Support: Android < 4.0
				src.defaultPrevented === undefined &&
				src.getPreventDefault && src.getPreventDefault() ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, events, type, key, j,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					events = Object.keys( data.events || {} );
					if ( events.length ) {
						for ( j = 0; (type = events[j]) !== undefined; j++ ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
		divReset = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;" +
			"-moz-box-sizing:content-box;box-sizing:content-box",
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;" +
		"margin-top:1px";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
		div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;" +
			"position:absolute;top:1%";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Use window.getComputedStyle because jsdom on node.js will break without it.
	if ( window.getComputedStyle ) {
		jQuery.extend(support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				// Clean up the div for other support tests.
				div.innerHTML = "";

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css(elem, "display") );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Support: Chrome, Safari
				// Setting style to blank string required to delete "style: x !important;"
				style[ name ] = "";
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );
		// Get default display if display is currently "none"
		if ( display === "none" ) {
			display = defaultDisplay( elem.nodeName );
		}
		if ( display === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				// Do send the request
				// This may raise an exception which is actually
				// handled in jQuery.ajax (so no try/catch here)
				xhr.send( options.hasContent && options.data || null );
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

define('aura/platform',[],function() {
  // The bind method is used for callbacks.
  //
  // * (bind)[https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind]
  // * (You don't need to use $.proxy)[http://www.aaron-powell.com/javascript/you-dont-need-jquery-proxy]
  if (typeof Function.prototype.bind !== "function") {
    Function.prototype.bind = function(oThis) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1);
      var fToBind = this;
      var FNOP = function() {};
      var FBound = function() {
          return fToBind.apply(this instanceof FNOP && oThis ? this : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
        };

      FNOP.prototype = this.prototype;
      FBound.prototype = new FNOP();

      return FBound;
    };
  }

  // Returns true if an object is an array, false if it is not.
  //
  // * (isArray)[https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray]
  if (typeof Array.isArray !== "function") {
    Array.isArray = function(vArg) {
      return Object.prototype.toString.call(vArg) === "[object Array]";
    };
  }

  // Creates a new object with the specified prototype object and properties.
  //
  // * (create)[https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create]

  if (!Object.create) {
    Object.create = function (o) {
      if (arguments.length > 1) {
        throw new Error('Object.create implementation only accepts the first parameter.');
      }
      function F() {}
      F.prototype = o;
      return new F();
    };
  }
  // Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop
  // (the difference being that a for-in loop enumerates properties in the prototype chain as well).
  //
  // (keys)[https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys]
  if (!Object.keys) {
    Object.keys = (function () {
      var ownProp = Object.prototype.hasOwnProperty,
          hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
          dontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
          ],
          dontEnumsLength = dontEnums.length;

      return function (obj) {
        if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
          throw new TypeError('Object.keys called on non-object');
        }

        var result = [];

        for (var prop in obj) {
          if (ownProp.call(obj, prop)) {
            result.push(prop);
          }
        }

        if (hasDontEnumBug) {
          for (var i=0; i < dontEnumsLength; i++) {
            if (ownProp.call(obj, dontEnums[i])) {
              result.push(dontEnums[i]);
            }
          }
        }
        return result;
      };
    })();
  }


});


  define('aura/base',['module', 'underscore', 'jquery', './platform'], function(module, _, $, platform) {

    // Auto configure aura path... if not set yet...
    if (!require.s.contexts._.config.paths.aura) {
      require.config({ paths: { aura: module.id.replace(/base$/, '') }});
    }

    var base = {};

    base.dom = {
      find: function(selector, context) {
        context = context || document;
        return $(context).find(selector);
      },
      data: function(selector, attribute) {
        return $(selector).data(attribute);
      }
    };

    base.data = {
      deferred: $.Deferred,
      when: $.when
    };

    base.util = {
      each: $.each,
      extend: $.extend,
      uniq: _.uniq,
      _: _,
      decamelize: function(camelCase, delimiter) {
        delimiter = (delimiter === undefined) ? '_' : delimiter;
        return camelCase.replace(/([A-Z])/g, delimiter + '$1').toLowerCase();
      }
    };

    base.events = {
      listen: function(context, events, selector, callback) {
        return $(context).on(events, selector, callback);
      },
      bindAll: function() {
        return _.bindAll.apply(this, arguments);
      }
    };

    base.template = {
      parse: _.template
    };

    return base;

  });



define('aura/logger',[], function() {
  'use strict';

  var noop    = function() {},
      console = window.console || {};

  function Logger(name) {
    this.name   = name;
    this._log   = noop;
    this._warn  = noop;
    this._error = noop;
    return this;
  }

  Logger.prototype.setName = function(name){
    this.name = name;
  };

  Logger.prototype.enable = function() {
    this._log   = (console.log   || noop);
    this._warn  = (console.warn  || this._log);
    this._error = (console.error || this._log);
    return this;
  };

  Logger.prototype.write = function(output, args){
    var parameters = Array.prototype.slice.call(args);
    parameters.unshift(this.name + ":");
    output.apply(console, parameters);
  };

  Logger.prototype.log = function() {
    this.write(this._log, arguments);
  };

  Logger.prototype.warn = function() {
    this.write(this._warn, arguments);
  };

  Logger.prototype.error = function() {
    this.write(this._error, arguments);
  };

  return Logger;
});

define('aura/aura.extensions',['./base', './logger'], function(base, Logger) {

  var _ = base.util._,
      slice = Array.prototype.slice,
      deferred = base.data.deferred,
      when     = base.data.when,
      logger   = new Logger('Extensions').enable();

  /**
   * Anatomy of an extension...
   * TODO...
   */

  function ExtManager() {
    this._extensions  = [];
    this.initStatus   = deferred();
    return this;
  }

  //---------------------------------------------------------------------------
  // Public API
  //---------------------------------------------------------------------------

  ExtManager.prototype.add = function(ext) {
    if (_.include(this._extensions, ext)) {
      var msg =  ext.ref.toString() + " is already registered.";
          msg += "Extensions can only be added once.";
      throw new Error(msg);
    }

    if (this.initStarted) {
      throw new Error("Init extensions already called");
    }

    this._extensions.push(ext);
    return this;
  };

  ExtManager.prototype.onReady = function(fn) {
    this.initStatus.then(fn);
    return this;
  };

  ExtManager.prototype.onFailure = function(fn) {
    this.initStatus.fail(fn);
    return this;
  };

  ExtManager.prototype.init = function() {

    if (this.initStarted) {
      throw new Error("Init extensions already called");
    }

    this.initStarted = true;

    var extensions    = _.compact(this._extensions.slice(0)),
        initialized   = [],
        initStatus    = this.initStatus;

    // Enforce sequencial loading of extensions.
    // The `initStatus` promise resolves to the
    // actually resolved and loaded extensions.
    (function _init(extDef) {
      if (extDef) {
        var ext = initExtension(extDef);
        initialized.push(ext);
        ext.done(function () { _init(extensions.shift()); });
        ext.fail(function (err) {
          if (!err) {
            err = "Unknown error while loading an extension";
          }
          if (!(err instanceof Error)) {
            err = new Error(err);
          }
          initStatus.reject(err);
        });
      } else if (extensions.length === 0) {
        when.apply(undefined, initialized).done(function () {
          initStatus.resolve(Array.prototype.slice.call(arguments));
        });
      }
    })(extensions.shift());

    return initStatus.promise();
  };

  //---------------------------------------------------------------------------
  // Private API
  //---------------------------------------------------------------------------

  /*!
   * Helper function that returns the first function found among its arguments.
   * If no function if found, it return a noop (empty function).
   *
   * @return {[type]} [description]
   */
  function getFn() {
    var funcs = slice.call(arguments), fn;
    for (var f = 0, l = funcs.length; f < l; f++) {
      fn = funcs[f];
      if (typeof(fn) === 'function') { return fn; }
    }
    return function () {};
  }

  /*!
   * If the value of the first argument is a function then invoke
   * it with the rest of the args, otherwise, return it.
   */
  function getVal(val) {
    if (typeof val === 'function') {
      return val.apply(undefined, slice.call(arguments, 1));
    } else {
      return val;
    }
  }

  /*!
  * Actual extension loading.
  *
  * The sequence is:
  *
  * * resolves the extension reference
  * * register and requires its dependencies if any
  * * init the extension
  *
  * This method also returns a promise that allows
  * to keep track of the app's loading sequence.
  *
  * If the extension provides a `afterAppStart` method,
  * the promise will resolve to that function that
  * will be called at the end of the app loading sequence.
  *
  * @param {String|Object|Function} extDef the reference and context of the extension
  */

  function initExtension(extDef) {
    var dfd       = deferred(),
        ref       = extDef.ref,
        context   = extDef.context;

    var req = requireExtension(ref, context);
    req.fail(dfd.reject);
    req.done(function (ext) {

      // The extension did not return anything,
      // but probably already did what it had to do.
      if (!ext) { return dfd.resolve(); }

      // Let's initialize it then...
      // If ext is a function, call it
      // Else If ext has a init method, call it

      var _fn;
      try {
        _fn = getFn(ext, ext.initialize)(context);
      } catch (e) {
          console.log(e)
        dfd.reject(e);
      }
       // console.log(ext)
      var init = when(_fn);
      init.done(function () { dfd.resolve(ext); });
      init.fail(dfd.reject);
    });
    return dfd.promise();
  }

  /*!
  * Extension resolution before actual loading.
  * If `ext` is a String, it is considered as a reference
  * to an AMD module that has to be loaded.
  *
  * This method returns a promise that resolves to the actual extension,
  * With all its dependencies already required' too.
  *
  * @param {String|Object|Function} ext the reference of the extension
  * @param {Object} context the thing this extension is supposed to extend
  */

  function requireExtension(ext, context) {
    var dfd = deferred();

    var resolve = function (ext) {

      try {
        ext = getVal(ext, context);
        if (ext && ext.require && ext.require.paths) {
          var deps = Object.keys(ext.require.paths) || [];
          require.config(ext.require);
          require(deps, function() {
            dfd.resolve(ext);
          }, reject);
        } else {
          dfd.resolve(ext);
        }
      } catch (err) {
        reject(err);
      }
    };

    var reject = function (err) {
      logger.error("Error loading ext:", ext, err);
      dfd.reject(err);
    };

    if (typeof ext === 'string') {
      require([ext], resolve, reject);
    } else {
      resolve(ext);
    }

    return dfd;
  }

  return ExtManager;
});

define('aura/aura',[
  './base',
  './aura.extensions',
  './logger'
  ], function(base, ExtManager, Logger) {

  var _ = base.util._,
      noop     = function() {},
      freeze   = Object.freeze || noop;

  /**
  * Aura constructor and main entry point
  * Loads mediator & widgets extensions by default.
  */
  function Aura(config) {
    if (!(this instanceof Aura)) {
      return new Aura(config);
    }

    this.ref        = _.uniqueId('aura_');
    this.config     = config = config || {};
    this.extensions = new ExtManager();

    this.core       = Object.create(base);
    this.sandbox    = Object.create(base);
    this.sandboxes  = {};
    this.logger     = new Logger(this.ref);

    if (config.debug) {
      this.logger.enable();
      this.use('aura/ext/debug');
    }

    this.use('aura/ext/mediator');

    config.widgets = (config.widgets || {});
    config.widgets.sources = (config.widgets.sources || { "default" : "widgets" });
    this.use('aura/ext/widgets');

    return this;
  }

  /**
   * Creates a brand new sandbox, using the app sandbox object as a prototype
   *
   */
  Aura.prototype.createSandbox = function() {
    var sandbox = Object.create(this.sandbox);
    sandbox.ref = _.uniqueId('sandbox-');
    sandbox.logger = new Logger(sandbox.ref);
    if(this.config.debug){
      sandbox.logger.enable();
    }
    this.sandboxes[sandbox.ref] = sandbox;
    return sandbox;
  };


  /**
   * Get a sandbox by its ref
   *
   */
  Aura.prototype.getSandbox = function(ref) {
    return this.sandboxes[ref];
  };

  /**
   * Tells the app to init with the given extension.
   *
   * This method can only be called before the app is actually started.
   *
   * @param  {String|Object|Function} ref the reference of the extension
   * @return {Aura}   the Aura app object
   */
  Aura.prototype.use = function(ref) {
    this.extensions.add({ ref: ref, context: this });
    return this;
  };

  /**
   * Adds a new source for widgets
   *
   * @param {String} name    the name of the source
   * @param {String} baseUrl the base url for those widgets
   */
  Aura.prototype.registerWidgetsSource = function(name, baseUrl) {
    if (this.config.widgets.sources[name]) {
      throw new Error("Widgets source '" + name + "' is already registered");
    }
    this.config.widgets.sources[name] = baseUrl;
    return this;
  };

  /**
   * Application start.
   * Bootstraps the extensions loading process
   * @return {Promise} a promise that resolves when the app is started
   */
  Aura.prototype.start = function(options) {


    var app = this;
    if (app.started) {
      app.logger.error("Aura already started... !");
      return app.extensions.initStatus;
    }
    app.logger.log("Starting Aura...");
    app.startOptions  = options || {};
    app.started       = true;
    app.extensions.onReady(function(exts) {

      // Then we call all the `afterAppStart` provided by the extensions
      base.util.each(exts, function(i, ext) {
        if (ext && typeof(ext.afterAppStart) === 'function') {
          try {
            ext.afterAppStart(app);
          } catch(e) {
            app.logger.error("Error on ", (ext.name || ext) , ".afterAppStart callback: (", e.message, ")", e);
          }
        }
      });
    });


    // If there was an error in the boot sequence we
    // reject every body an do some cleanup
    // TODO: Provide a better error message to the user.
    app.extensions.onFailure(function() {
      app.logger.error("Error initializing app...", app.config.name, arguments);
      app.stop();
    });

    // Finally... we return a promise that allows
    // to keep track of the loading process...
    //

    return app.extensions.init();
  };

  /**
   * Stops the application and unregister its loaded dependencies.
   * TODO: We need to do a little more cleanup here...
   * @return {void}
   */
  Aura.prototype.stop = function() {
    this.started = false;

    // unregisterDeps(this.ref, Object.keys(allDeps.apps[env.appRef] || {}));
  };

  return Aura;
});

define('features/appSettings/wemo-production',[/*backbone wasp connector goes here*/],function(/*Connector*/){
    'use strict';

    return {
        'environment':'production',
        'cloudIpAddress':'https://api.xbcs.net:8443',
        'firmwareIpAddress':'https://fw.xbcs.net',
        'bundleIpAddress':'https://qa.linksyssmartwifi.com/rule-service/rest/rules/execution',
        'ifDevDeviceEnvironment': null,
        'startWidget':'devicelist'
    };

});
// i18next, v1.8.0
// Copyright (c)2015 Jan Mühlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com
(function (root, factory) {
    if (typeof exports === 'object') {

      var jquery = require('jquery');

      module.exports = factory(jquery);

    } else if (typeof define === 'function' && define.amd) {

      define('i18next',['jquery'], factory);

    } 
}(this, function ($) {

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }
    
    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }
    
    // Add string trim for IE8.
    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, ''); 
        }
    }

    var i18n = {}
        , resStore = {}
        , currentLng
        , replacementCounter = 0
        , languages = []
        , initialized = false
        , sync = {};

    sync = {
    
        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }
    
                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);
    
                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },
    
        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();
    
            if(window.localStorage) {
    
                var todo = lngs.length;
    
                f.each(lngs, function(key, lng) {
                    var local = f.localStorage.getItem('res_' + lng);
    
                    if (local) {
                        local = JSON.parse(local);
    
                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }
    
                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },
    
        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    f.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },
    
        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};
            
            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;
    
                // load each file individual
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {
                        
                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;
    
                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };
                        
                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });
            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };
    
                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data);
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "json",
                        async : options.getAsync
                    });
                }    
            }
        },
    
        _fetchOne: function(lng, ns, options, done) {
            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    done(null, data);
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        f.error('There is a typo in: ' + url);
                    } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                        f.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                        f.log(theStatus + ' when loading ' + url);
                    }
                    
                    done(error, {});
                },
                dataType: "json",
                async : options.getAsync
            });
        },
    
        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;
    
            var urls = [];
    
            if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                }
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }
    
            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);
    
                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        },
    
        reload: reload
    };
    // defaults
    var o = {
        lng: undefined,
        load: 'all',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: ['dev'],
        fallbackNS: [],
        detectLngQS: 'setLng',
        detectLngFromLocalStorage: false,
        ns: 'translation',
        fallbackOnNull: true,
        fallbackOnEmpty: false,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,
        
        resGetPath: 'locales/__lng__/__ns__.json',
        resPostPath: 'locales/add/__lng__/__ns__',
    
        getAsync: true,
        postAsync: true,
    
        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,
    
        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',
    
        interpolationPrefix: '__',
        interpolationSuffix: '__',
        defaultVariables: false,
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,
        indefiniteSuffix: '_indefinite',
        indefiniteNotFound: ['indefinite_not_found', Math.random()].join(''),
    
        setJqueryExt: true,
        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
        cookieDomain: undefined,
    
        objectTreeKeyHandler: undefined,
        postProcess: undefined,
        parseMissingKey: undefined,
        missingKeyHandler: sync.postMissing,
    
        shortcutFunction: 'sprintf' // or: defaultValue
    };
    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }
    
        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }
    
    function _deepExtend(target, source) {
        for (var prop in source)
            if (prop in target)
                _deepExtend(target[prop], source[prop]);
            else
                target[prop] = source[prop];
        return target;
    }
    
    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";
    
        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }
    
        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }
    
        return object;
    }
    
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };
    
    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });
        }else{
            return data;
        }
    }
    
    function _ajax(options) {
    
        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }
    
            // If no XHR support was found, throw an error.
            return callback(new Error());
        };
    
        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }
    
            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }
    
            return result.join('&');
        };
    
        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';
    
            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
    
                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }
    
            return result;
        };
    
        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    
            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;
    
            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);
    
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
    
                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }
    
                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);
    
            return result;
        };
    
        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];
    
            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }
    
            // Return the merged headers.
            return result;
        };
    
        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }
    
            // Set default parameter values.
            options.cache = options.cache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;
    
            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);
    
            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);
            }
    
            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }
    
                // Handle caching.
                if(!options.cache) {
                    queryString.push('_=' + (new Date()).getTime());
                }
    
                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }
    
                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }
    
                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);
                    return;
                }
            }
    
            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);
    
                // Open the request.
                xhr.open(method, url, options.async);
    
                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }
    
                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';
    
                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }
    
                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, {
                            text: function () {
                                return data;
                            },
    
                            json: function () {
                                try {
                                    return JSON.parse(data)
                                } catch (e) {
                                    f.error('Can not parse JSON. URL: ' + url);
                                    return {};
                                }
                            }
                        });
                    }
                };
    
                // Actually send the XHR request.
                xhr.send(payload);
            });
        };
    
        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },
    
            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);
            },
    
            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);
            },
    
            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },
    
            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },
    
            headers: function (headers) {
                ajax.headers = headers || {};
            },
    
            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },
    
            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },
    
            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);
            },
    
            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);
            },
    
            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);
            },
    
            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };
    
    
        var methode = options.type ? options.type.toLowerCase() : 'get';
    
        http[methode](options.url, options, function (status, data) {
            // file: protocol always gives status code 0, so check for data
            if (status === 200 || (status === 0 && data.text())) {
                options.success(data.json(), status, null);
            } else {
                options.error(data.text(), status, null);
            }
        });
    }
    
    var _cookie = {
        create: function(name,value,minutes,domain) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            domain = (domain)? "domain="+domain+";" : "";
            document.cookie = name+"="+value+expires+";"+domain+"path=/";
        },
    
        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },
    
        remove: function(name) {
            this.create(name,"",-1);
        }
    };
    
    var cookie_noop = {
        create: function(name,value,minutes,domain) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };
    
    
    
    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        deepExtend: _deepExtend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {
            if (o.debug && typeof console !== "undefined") console.log(str);
        },
        error: function(str) {
            if (typeof console !== "undefined") console.error(str);
        },
        getCountyIndexOfLng: function(lng) {
            var lng_index = 0;
            if (lng === 'nb-NO' || lng === 'nn-NO' || lng === 'nb-no' || lng === 'nn-no') lng_index = 1;
            return lng_index;
        },
        toLanguages: function(lng) {
            var log = this.log;
    
            function applyCase(l) {
                var ret = l;
    
                if (typeof l === 'string' && l.indexOf('-') > -1) {
                    var parts = l.split('-');
    
                    ret = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                } else {
                    ret = o.lowerCaseLng ? l.toLowerCase() : l;
                }
    
                return ret;
            }
    
            var languages = [];
            var whitelist = o.lngWhitelist || false;
            var addLanguage = function(language){
              //reject langs not whitelisted
              if(!whitelist || whitelist.indexOf(language) > -1){
                languages.push(language);
              }else{
                log('rejecting non-whitelisted language: ' + language);
              }
            };
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');
    
                if (o.load !== 'unspecific') addLanguage(applyCase(lng));
                if (o.load !== 'current') addLanguage(applyCase(parts[this.getCountyIndexOfLng(lng)]));
            } else {
                addLanguage(applyCase(lng));
            }
    
            for (var i = 0; i < o.fallbackLng.length; i++) {
                if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(applyCase(o.fallbackLng[i]));
            }
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        regexReplacementEscape: function(strOrFn) {
            if (typeof strOrFn === 'string') {
                return strOrFn.replace(/\$/g, "$$$$");
            } else {
                return strOrFn;
            }
        },
        localStorage: {
            setItem: function(key, value) {
                if (window.localStorage) {
                    try {
                        window.localStorage.setItem(key, value);
                    } catch (e) {
                        f.log('failed to set value for key "' + key + '" to localStorage.');
                    }
                }
            },
            getItem: function(key, value) {
                if (window.localStorage) {
                    try {
                        return window.localStorage.getItem(key, value);
                    } catch (e) {
                        f.log('failed to get value for key "' + key + '" from localStorage.');
                        return undefined;
                    }
                }
            }
        }
    };
    function init(options, cb) {
        
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};
        
        // override defaults with passed in options
        f.extend(o, options);
        delete o.fixLng; /* passed in each time */
    
        // override functions: .log(), .detectLanguage(), etc
        if (o.functions) {
            delete o.functions;
            f.extend(f, options.functions);
        }
    
        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }
    
        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }
    
        // fallback languages
        if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
            o.fallbackLng = [o.fallbackLng];
        }
    
        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);
    
        if (!o.lng) o.lng = f.detectLanguage();
    
        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);
    
        if (o.useCookie && f.cookie.read(o.cookieName) !== currentLng){ //cookie is unset or invalid
            f.cookie.create(o.cookieName, currentLng, o.cookieExpirationTime, o.cookieDomain);
        }
        if (o.detectLngFromLocalStorage && typeof document !== 'undefined' && window.localStorage) {
            f.localStorage.setItem('i18next_lng', currentLng);
        }
    
        var lngTranslate = translate;
        if (options.fixLng) {
            lngTranslate = function(key, options) {
                options = options || {};
                options.lng = options.lng || lngTranslate.lng;
                return translate(key, options);
            };
            lngTranslate.lng = currentLng;
        }
    
        pluralExtensions.setCurrentLng(currentLng);
    
        // add JQuery extensions
        if ($ && o.setJqueryExt) addJqueryFunct();
    
        // jQuery deferred
        var deferred;
        if ($ && $.Deferred) {
            deferred = $.Deferred();
        }
    
        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            initialized = true;
            if (cb) cb(lngTranslate);
            if (deferred) deferred.resolve(lngTranslate);
            if (deferred) return deferred.promise();
            return;
        }
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // else load them
        i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
            initialized = true;
    
            if (cb) cb(lngTranslate);
            if (deferred) deferred.resolve(lngTranslate);
        });
    
        if (deferred) return deferred.promise();
    }
    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }
    
    function addResourceBundle(lng, ns, resources, deep) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};
    
        if (deep) {
            f.deepExtend(resStore[lng][ns], resources);
        } else {
            f.extend(resStore[lng][ns], resources);
        }
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }
    
    function hasResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }
    
        resStore[lng] = resStore[lng] || {};
        var res = resStore[lng][ns] || {};
    
        var hasValues = false;
        for(var prop in res) {
            if (res.hasOwnProperty(prop)) {
                hasValues = true;
            }
        }
    
        return hasValues;
    }
    
    function getResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }
    
        resStore[lng] = resStore[lng] || {};
        return f.extend({}, resStore[lng][ns]);
    }
    
    function removeResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = {};
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }
    
    function addResource(lng, ns, key, value) {
        if (typeof ns !== 'string') {
            resource = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};
    
        var keys = key.split(o.keyseparator);
        var x = 0;
        var node = resStore[lng][ns];
        var origRef = node;
    
        while (keys[x]) {
            if (x == keys.length - 1)
                node[keys[x]] = value;
            else {
                if (node[keys[x]] == null)
                    node[keys[x]] = {};
    
                node = node[keys[x]];
            }
            x++;
        }
        if (o.useLocalStorage) {
            sync._storeLocal(resStore);
        }
    }
    
    function addResources(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resource = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        for (var m in resources) {
            if (typeof resources[m] === 'string') addResource(lng, ns, m, resources[m]);
        }
    }
    
    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }
    
    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }
    
    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }
    
            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }
    
        if (lngNeedLoad.length) {
            i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;
    
                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {
    
                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }
    
                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];
    
                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }
    
    function setLng(lng, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        } else if (!options) {
            options = {};
        }
    
        options.lng = lng;
        return init(options, cb);
    }
    
    function lng() {
        return currentLng;
    }
    
    function reload(cb) {
        resStore = {};
        setLng(currentLng, cb);
    }
    function addJqueryFunct() {
        // $.t shortcut
        $.t = $.t || translate;
    
        function parse(ele, key, options) {
            if (key.length === 0) return;
    
            var attr = 'text';
    
            if (key.indexOf('[') === 0) {
                var parts = key.split(']');
                key = parts[1];
                attr = parts[0].substr(1, parts[0].length-1);
            }
    
            if (key.indexOf(';') === key.length-1) {
                key = key.substr(0, key.length-2);
            }
    
            var optionsToUse;
            if (attr === 'html') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.html($.t(key, optionsToUse));
            } else if (attr === 'text') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.text() }, options) : options;
                ele.text($.t(key, optionsToUse));
            } else if (attr === 'prepend') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.prepend($.t(key, optionsToUse));
            } else if (attr === 'append') {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.html() }, options) : options;
                ele.append($.t(key, optionsToUse));
            } else if (attr.indexOf("data-") === 0) {
                var dataAttr = attr.substr(("data-").length);
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.data(dataAttr) }, options) : options;
                var translated = $.t(key, optionsToUse);
                //we change into the data cache
                ele.data(dataAttr, translated);
                //we change into the dom
                ele.attr(attr, translated);
            } else {
                optionsToUse = o.defaultValueFromContent ? $.extend({ defaultValue: ele.attr(attr) }, options) : options;
                ele.attr(attr, $.t(key, optionsToUse));
            }
        }
    
        function localize(ele, options) {
            var key = ele.attr(o.selectorAttr);
            if (!key && typeof key !== 'undefined' && key !== false) key = ele.text() || ele.val();
            if (!key) return;
    
            var target = ele
              , targetSelector = ele.data("i18n-target");
            if (targetSelector) {
                target = ele.find(targetSelector) || ele;
            }
    
            if (!options && o.useDataAttrOptions === true) {
                options = ele.data("i18n-options");
            }
            options = options || {};
    
            if (key.indexOf(';') >= 0) {
                var keys = key.split(';');
    
                $.each(keys, function(m, k) {
                    if (k !== '') parse(target, k, options);
                });
    
            } else {
                parse(target, key, options);
            }
    
            if (o.useDataAttrOptions === true) ele.data("i18n-options", options);
        }
    
        // fn
        $.fn.i18n = function (options) {
            return this.each(function() {
                // localize element itself
                localize($(this), options);
    
                // localize childs
                var elements =  $(this).find('[' + o.selectorAttr + ']');
                elements.each(function() { 
                    localize($(this), options);
                });
            });
        };
    }
    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;
    
        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
    
        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;
    
        var hash = replacementHash.replace && typeof replacementHash.replace === 'object' ? replacementHash.replace : replacementHash;
        f.each(hash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), f.regexReplacementEscape(value));
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(f.escape(value)));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.regexReplacementEscape(value));
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }
    
    // append it to functions
    f.applyReplacement = applyReplacement;
    
    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';
    
        var opts = f.extend({}, options);
        delete opts.postProcess;
    
        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');
    
            if (index_of_end_of_closing <= index_of_opening) {
                f.error('there is an missing closing in following translation value', translated);
                return '';
            }
    
            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }
    
            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, f.regexReplacementEscape(translated_token));
        }
        return translated;
    }
    
    function hasContext(options) {
        return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
    }
    
    function needsPlural(options, lng) {
        return (options.count !== undefined && typeof options.count != 'string'/* && pluralExtensions.needsPlural(lng, options.count)*/);
    }
    
    function needsIndefiniteArticle(options) {
        return (options.indefinite_article !== undefined && typeof options.indefinite_article != 'string' && options.indefinite_article);
    }
    
    function exists(key, options) {
        options = options || {};
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options);
    
        return found !== undefined || found === notFound;
    }
    
    function translate(key, options) {
        options = options || {};
    
        if (!initialized) {
            f.log('i18next not finished initialization. you might have called t function before loading resources finished.')
            return options.defaultValue || '';
        };
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }
    
    function _getDefaultValue(key, options) {
        return (options.defaultValue !== undefined) ? options.defaultValue : key;
    }
    
    function _injectSprintfProcessor() {
    
        var values = [];
    
        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }
    
        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }
    
    function _translate(potentialKeys, options) {
        if (options && typeof options !== 'object') {
            if (o.shortcutFunction === 'sprintf') {
                // mh: gettext like sprintf syntax found, automatically create sprintf processor
                options = _injectSprintfProcessor.apply(null, arguments);
            } else if (o.shortcutFunction === 'defaultValue') {
                options = {
                    defaultValue: options
                }
            }
        } else {
            options = options || {};
        }
    
        if (typeof o.defaultVariables === 'object') {
            options = f.extend({}, o.defaultVariables, options);
        }
    
        if (potentialKeys === undefined || potentialKeys === null || potentialKeys === '') return '';
    
        if (typeof potentialKeys === 'number') {
            potentialKeys = String(potentialKeys);
        }
    
        if (typeof potentialKeys === 'string') {
            potentialKeys = [potentialKeys];
        }
    
        var key = potentialKeys[0];
    
        if (potentialKeys.length > 1) {
            for (var i = 0; i < potentialKeys.length; i++) {
                key = potentialKeys[i];
                if (exists(key, options)) {
                    break;
                }
            }
        }
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng, options.fallbackLng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;
    
        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (found === undefined && o.sendMissing && typeof o.missingKeyHandler === 'function') {
            if (options.lng) {
                o.missingKeyHandler(lngs[0], ns, key, notFound, lngs);
            } else {
                o.missingKeyHandler(o.lng, ns, key, notFound, lngs);
            }
        }
    
        var postProcessorsToApply;
        if (typeof o.postProcess === 'string' && o.postProcess !== '') {
            postProcessorsToApply = [o.postProcess];
        } else if (typeof o.postProcess === 'array' || typeof o.postProcess === 'object') {
            postProcessorsToApply = o.postProcess;
        } else {
            postProcessorsToApply = [];
        }
    
        if (typeof options.postProcess === 'string' && options.postProcess !== '') {
            postProcessorsToApply = postProcessorsToApply.concat([options.postProcess]);
        } else if (typeof options.postProcess === 'array' || typeof options.postProcess === 'object') {
            postProcessorsToApply = postProcessorsToApply.concat(options.postProcess);
        }
    
        if (found !== undefined && postProcessorsToApply.length) {
            postProcessorsToApply.forEach(function(postProcessor) {
                if (postProcessors[postProcessor]) {
                    found = postProcessors[postProcessor](found, key, options);
                }
            });
        }
    
        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }
    
        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);
    
            if (postProcessorsToApply.length) {
                var val = _getDefaultValue(key, options);
                postProcessorsToApply.forEach(function(postProcessor) {
                    if (postProcessors[postProcessor]) {
                        found = postProcessors[postProcessor](val, key, options);
                    }
                });
            }
        }
    
        return (found !== undefined) ? found : notFound;
    }
    
    function _find(key, options) {
        options = options || {};
    
        var optionWithoutCount, translated
            , notFound = _getDefaultValue(key, options)
            , lngs = languages;
    
        if (!resStore) { return notFound; } // no resStore to translate from
    
        // CI mode
        if (lngs[0].toLowerCase() === 'cimode') return notFound;
    
        // passed in lng
        if (options.lngs) lngs = options.lngs;
        if (options.lng) {
            lngs = f.toLanguages(options.lng, options.fallbackLng);
    
            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;
    
                i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }
    
        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;
    
            var contextKey = ns + o.nsseparator + key + '_' + options.context;
    
            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }
    
        if (needsPlural(options, lngs[0])) {
            optionWithoutCount = f.extend({ lngs: [lngs[0]]}, options);
            delete optionWithoutCount.count;
            optionWithoutCount._origLng = optionWithoutCount._origLng || optionWithoutCount.lng || lngs[0];
            delete optionWithoutCount.lng;
            optionWithoutCount.defaultValue = o.pluralNotFound;
    
            var pluralKey;
            if (!pluralExtensions.needsPlural(lngs[0], options.count)) {
                pluralKey = ns + o.nsseparator + key;
            } else {
                pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
                var pluralExtension = pluralExtensions.get(lngs[0], options.count);
                if (pluralExtension >= 0) {
                    pluralKey = pluralKey + '_' + pluralExtension;
                } else if (pluralExtension === 1) {
                    pluralKey = ns + o.nsseparator + key; // singular
                }
            }
    
            translated = translate(pluralKey, optionWithoutCount);
    
            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } else if (lngs.length > 1) {
                // remove failed lng
                var clone = lngs.slice();
                clone.shift();
                options = f.extend(options, { lngs: clone });
                options._origLng = optionWithoutCount._origLng;
                delete options.lng;
                // retry with fallbacks
                translated = translate(ns + o.nsseparator + key, options);
                if (translated != o.pluralNotFound) return translated;
            } else {
                optionWithoutCount.lng = optionWithoutCount._origLng;
                delete optionWithoutCount._origLng;
                translated = translate(ns + o.nsseparator + key, optionWithoutCount);
                
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                });
            }
        }
    
        if (needsIndefiniteArticle(options)) {
            var optionsWithoutIndef = f.extend({}, options);
            delete optionsWithoutIndef.indefinite_article;
            optionsWithoutIndef.defaultValue = o.indefiniteNotFound;
            // If we don't have a count, we want the indefinite, if we do have a count, and needsPlural is false
            var indefiniteKey = ns + o.nsseparator + key + (((options.count && !needsPlural(options, lngs[0])) || !options.count) ? o.indefiniteSuffix : "");
            translated = translate(indefiniteKey, optionsWithoutIndef);
            if (translated != o.indefiniteNotFound) {
                return translated;
            }
        }
    
        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;
    
            var l = lngs[i];
    
            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                var valueType = Object.prototype.toString.apply(value);
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                            value = o.objectTreeKeyHandler(key, value, l, ns, options);
                        } else {
                            value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                'returned an object instead of string.';
                            f.log(value);
                        }
                    } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                        var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                        f.each(value, function(m) {
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        });
                        value = copy;
                    }
                }
    
                if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                    value = undefined;
    
                found = value;
            }
        }
    
        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;
    
            if (o.fallbackNS.length) {
    
                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
    
                    if (found || (found==="" && o.fallbackOnEmpty === false)) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;
    
                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
            options.isFallbackLookup = false;
        }
    
        return found;
    }
    function detectLanguage() {
        var detectedLng;
        var whitelist = o.lngWhitelist || [];
        var userLngChoices = [];
    
        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var params = query.split('&');
                for (var i=0; i<params.length; i++) {
                    var pos = params[i].indexOf('=');
                    if (pos > 0) {
                        var key = params[i].substring(0,pos);
                        if (key == o.detectLngQS) {
                            userLngChoices.push(params[i].substring(pos+1));
                        }
                    }
                }
            })();
        }
    
        // get from cookie
        if (o.useCookie && typeof document !== 'undefined') {
            var c = f.cookie.read(o.cookieName);
            if (c) userLngChoices.push(c);
        }
    
        // get from localStorage
        if (o.detectLngFromLocalStorage && typeof window !== 'undefined' && window.localStorage) {
            userLngChoices.push(f.localStorage.getItem('i18next_lng'));
        }
    
        // get from navigator
        if (typeof navigator !== 'undefined') {
            if (navigator.languages) { // chrome only; not an array, so can't use .push.apply instead of iterating
                for (var i=0;i<navigator.languages.length;i++) {
                    userLngChoices.push(navigator.languages[i]);
                }
            }
            if (navigator.userLanguage) {
                userLngChoices.push(navigator.userLanguage);
            }
            if (navigator.language) {
                userLngChoices.push(navigator.language);
            }
        }
    
        (function() {
            for (var i=0;i<userLngChoices.length;i++) {
                var lng = userLngChoices[i];
    
                if (lng.indexOf('-') > -1) {
                    var parts = lng.split('-');
                    lng = o.lowerCaseLng ?
                        parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                        parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
                }
    
                if (whitelist.length === 0 || whitelist.indexOf(lng) > -1) {
                    detectedLng = lng;
                    break;
                }
            }
        })();
    
        //fallback
        if (!detectedLng){
          detectedLng = o.fallbackLng[0];
        }
        
        return detectedLng;
    }
    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
    
    /* [code, name, numbers, pluralsType] */
    var _rules = [
        ["ach", "Acholi", [1,2], 1],
        ["af", "Afrikaans",[1,2], 2],
        ["ak", "Akan", [1,2], 1],
        ["am", "Amharic", [1,2], 1],
        ["an", "Aragonese",[1,2], 2],
        ["ar", "Arabic", [0,1,2,3,11,100],5],
        ["arn", "Mapudungun",[1,2], 1],
        ["ast", "Asturian", [1,2], 2],
        ["ay", "Aymará", [1], 3],
        ["az", "Azerbaijani",[1,2],2],
        ["be", "Belarusian",[1,2,5],4],
        ["bg", "Bulgarian",[1,2], 2],
        ["bn", "Bengali", [1,2], 2],
        ["bo", "Tibetan", [1], 3],
        ["br", "Breton", [1,2], 1],
        ["bs", "Bosnian", [1,2,5],4],
        ["ca", "Catalan", [1,2], 2],
        ["cgg", "Chiga", [1], 3],
        ["cs", "Czech", [1,2,5],6],
        ["csb", "Kashubian",[1,2,5],7],
        ["cy", "Welsh", [1,2,3,8],8],
        ["da", "Danish", [1,2], 2],
        ["de", "German", [1,2], 2],
        ["dev", "Development Fallback", [1,2], 2],
        ["dz", "Dzongkha", [1], 3],
        ["el", "Greek", [1,2], 2],
        ["en", "English", [1,2], 2],
        ["eo", "Esperanto",[1,2], 2],
        ["es", "Spanish", [1,2], 2],
        ["es_ar","Argentinean Spanish", [1,2], 2],
        ["et", "Estonian", [1,2], 2],
        ["eu", "Basque", [1,2], 2],
        ["fa", "Persian", [1], 3],
        ["fi", "Finnish", [1,2], 2],
        ["fil", "Filipino", [1,2], 1],
        ["fo", "Faroese", [1,2], 2],
        ["fr", "French", [1,2], 9],
        ["fur", "Friulian", [1,2], 2],
        ["fy", "Frisian", [1,2], 2],
        ["ga", "Irish", [1,2,3,7,11],10],
        ["gd", "Scottish Gaelic",[1,2,3,20],11],
        ["gl", "Galician", [1,2], 2],
        ["gu", "Gujarati", [1,2], 2],
        ["gun", "Gun", [1,2], 1],
        ["ha", "Hausa", [1,2], 2],
        ["he", "Hebrew", [1,2], 2],
        ["hi", "Hindi", [1,2], 2],
        ["hr", "Croatian", [1,2,5],4],
        ["hu", "Hungarian",[1,2], 2],
        ["hy", "Armenian", [1,2], 2],
        ["ia", "Interlingua",[1,2],2],
        ["id", "Indonesian",[1], 3],
        ["is", "Icelandic",[1,2], 12],
        ["it", "Italian", [1,2], 2],
        ["ja", "Japanese", [1], 3],
        ["jbo", "Lojban", [1], 3],
        ["jv", "Javanese", [0,1], 13],
        ["ka", "Georgian", [1], 3],
        ["kk", "Kazakh", [1], 3],
        ["km", "Khmer", [1], 3],
        ["kn", "Kannada", [1,2], 2],
        ["ko", "Korean", [1], 3],
        ["ku", "Kurdish", [1,2], 2],
        ["kw", "Cornish", [1,2,3,4],14],
        ["ky", "Kyrgyz", [1], 3],
        ["lb", "Letzeburgesch",[1,2],2],
        ["ln", "Lingala", [1,2], 1],
        ["lo", "Lao", [1], 3],
        ["lt", "Lithuanian",[1,2,10],15],
        ["lv", "Latvian", [1,2,0],16],
        ["mai", "Maithili", [1,2], 2],
        ["mfe", "Mauritian Creole",[1,2],1],
        ["mg", "Malagasy", [1,2], 1],
        ["mi", "Maori", [1,2], 1],
        ["mk", "Macedonian",[1,2],17],
        ["ml", "Malayalam",[1,2], 2],
        ["mn", "Mongolian",[1,2], 2],
        ["mnk", "Mandinka", [0,1,2],18],
        ["mr", "Marathi", [1,2], 2],
        ["ms", "Malay", [1], 3],
        ["mt", "Maltese", [1,2,11,20],19],
        ["nah", "Nahuatl", [1,2], 2],
        ["nap", "Neapolitan",[1,2], 2],
        ["nb", "Norwegian Bokmal",[1,2],2],
        ["ne", "Nepali", [1,2], 2],
        ["nl", "Dutch", [1,2], 2],
        ["nn", "Norwegian Nynorsk",[1,2],2],
        ["no", "Norwegian",[1,2], 2],
        ["nso", "Northern Sotho",[1,2],2],
        ["oc", "Occitan", [1,2], 1],
        ["or", "Oriya", [2,1], 2],
        ["pa", "Punjabi", [1,2], 2],
        ["pap", "Papiamento",[1,2], 2],
        ["pl", "Polish", [1,2,5],7],
        ["pms", "Piemontese",[1,2], 2],
        ["ps", "Pashto", [1,2], 2],
        ["pt", "Portuguese",[1,2], 2],
        ["pt_br","Brazilian Portuguese",[1,2], 2],
        ["rm", "Romansh", [1,2], 2],
        ["ro", "Romanian", [1,2,20],20],
        ["ru", "Russian", [1,2,5],4],
        ["sah", "Yakut", [1], 3],
        ["sco", "Scots", [1,2], 2],
        ["se", "Northern Sami",[1,2], 2],
        ["si", "Sinhala", [1,2], 2],
        ["sk", "Slovak", [1,2,5],6],
        ["sl", "Slovenian",[5,1,2,3],21],
        ["so", "Somali", [1,2], 2],
        ["son", "Songhay", [1,2], 2],
        ["sq", "Albanian", [1,2], 2],
        ["sr", "Serbian", [1,2,5],4],
        ["su", "Sundanese",[1], 3],
        ["sv", "Swedish", [1,2], 2],
        ["sw", "Swahili", [1,2], 2],
        ["ta", "Tamil", [1,2], 2],
        ["te", "Telugu", [1,2], 2],
        ["tg", "Tajik", [1,2], 1],
        ["th", "Thai", [1], 3],
        ["ti", "Tigrinya", [1,2], 1],
        ["tk", "Turkmen", [1,2], 2],
        ["tr", "Turkish", [1,2], 1],
        ["tt", "Tatar", [1], 3],
        ["ug", "Uyghur", [1], 3],
        ["uk", "Ukrainian",[1,2,5],4],
        ["ur", "Urdu", [1,2], 2],
        ["uz", "Uzbek", [1,2], 1],
        ["vi", "Vietnamese",[1], 3],
        ["wa", "Walloon", [1,2], 1],
        ["wo", "Wolof", [1], 3],
        ["yo", "Yoruba", [1,2], 2],
        ["zh", "Chinese", [1], 3]
    ];
    
    var _rulesPluralsTypes = {
        1: function(n) {return Number(n > 1);},
        2: function(n) {return Number(n != 1);},
        3: function(n) {return 0;},
        4: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
        5: function(n) {return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);},
        6: function(n) {return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2);},
        7: function(n) {return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);},
        8: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3);},
        9: function(n) {return Number(n >= 2);},
        10: function(n) {return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;},
        11: function(n) {return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3);},
        12: function(n) {return Number(n%10!=1 || n%100==11);},
        13: function(n) {return Number(n !== 0);},
        14: function(n) {return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3);},
        15: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);},
        16: function(n) {return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2);},
        17: function(n) {return Number(n==1 || n%10==1 ? 0 : 1);},
        18: function(n) {return Number(0 ? 0 : n==1 ? 1 : 2);},
        19: function(n) {return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3);},
        20: function(n) {return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2);},
        21: function(n) {return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
    };
    
    var pluralExtensions = {
    
        rules: (function () {
            var l, rules = {};
            for (l=_rules.length; l-- ;) {
                rules[_rules[l][0]] = {
                    name: _rules[l][1],
                    numbers: _rules[l][2],
                    plurals: _rulesPluralsTypes[_rules[l][3]]
                }
            }
            return rules;
        }()),
    
        // you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;
        },
    
        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');
    
                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },
    
        needsPlural: function(lng, count) {
            var parts = lng.split('-');
    
            var ext;
            if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                ext = pluralExtensions.currentRule.rule; 
            } else {
                ext = pluralExtensions.rules[parts[f.getCountyIndexOfLng(lng)]];
            }
    
            if (ext && ext.numbers.length <= 1) {
                return false;
            } else {
                return this.get(lng, count) !== 1;
            }
        },
    
        get: function(lng, count) {
            var parts = lng.split('-');
    
            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule; 
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i;
                    if (ext.noAbs) {
                        i = ext.plurals(c);
                    } else {
                        i = ext.plurals(Math.abs(c));
                    }
                    
                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) { 
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }
                        
            return getResult(parts[f.getCountyIndexOfLng(lng)], count);
        }
    
    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };
    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }
    
        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
    
        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }
    
                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };
    
        str_format.cache = {};
    
        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };
    
        return str_format;
    })();
    
    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };
    
    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;
    
        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }
    
        return val;
    });
    // public api interface
    i18n.init = init;
    i18n.setLng = setLng;
    i18n.preload = preload;
    i18n.addResourceBundle = addResourceBundle;
    i18n.hasResourceBundle = hasResourceBundle;
    i18n.getResourceBundle = getResourceBundle;
    i18n.addResource = addResource;
    i18n.addResources = addResources;
    i18n.removeResourceBundle = removeResourceBundle;
    i18n.loadNamespace = loadNamespace;
    i18n.loadNamespaces = loadNamespaces;
    i18n.setDefaultNamespace = setDefaultNamespace;
    i18n.t = translate;
    i18n.translate = translate;
    i18n.exists = exists;
    i18n.detectLanguage = f.detectLanguage;
    i18n.pluralExtensions = pluralExtensions;
    i18n.sync = sync;
    i18n.functions = f;
    i18n.lng = lng;
    i18n.addPostProcessor = addPostProcessor;
    i18n.applyReplacement = f.applyReplacement;
    i18n.options = o;

    $.i18n = i18n;
    $.t = i18n.t;
        
    return i18n;

}));
define('extensions/i18next', ['i18next'], function(i18next) {
    'use strict';
    var lang;
    if (window.location.protocol === "file:") {
        navigator.globalization.getLocaleName(
            function(locale) {
                DEBUG && console.log("i18next locale info: " + locale.value);
                lang = locale.value;
                lang = (lang.indexOf('_')) ? lang.replace('_', '-') : lang;
            },
            function() {
                DEBUG && console.log("i18next locale info else: " + locale.value);
                lang = 'en-US';
            }
        );
    } else {
        lang = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);
        DEBUG && console.log("i18next locale info for browser: " + lang);
    }
    return {
        initialize: function(app) {
            app.core.i18n = i18next;
            app.sandbox.i18n = i18next;
            app.core.i18n.init({
                lng: lang,
                fallbackLng: 'en-US',
                cookieName: 'i18n',
                useLocalStorage: true,
                localStorageExpirationTime: 86400000 // in ms, default 1 week
            });
        }
    };
});
/**
 * jQuery Cookie plugin
 *
 * Copyright (c) 2010 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
jQuery.cookie = function (key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && String(value) !== "[object Object]") {
        options = jQuery.extend({}, options);

        if (value === null || value === undefined) {
            options.expires = -1;
        }

        if (typeof options.expires === 'number') {
            var days = options.expires, t = options.expires = new Date();
            t.setDate(t.getDate() + days);
        }

        value = String(value);

        return (document.cookie = [
            encodeURIComponent(key), '=',
            options.raw ? value : encodeURIComponent(value),
            options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
            options.path ? '; path=' + options.path : '',
            options.domain ? '; domain=' + options.domain : '',
            options.secure ? '; secure' : ''
        ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || {};
    var result, decode = options.raw ? function (s) { return s; } : decodeURIComponent;
    return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
};

define("plugins/jquery.cookie", function(){});

//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);

define("backboneBase", ["jquery","underscore","plugins/jquery.cookie"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Backbone;
    };
}(this)));

/** overrides some backbone prototypes **/
define('backbone',['backboneBase'], function(Backbone) {

    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var pointerEvents = ['click', 'touch', 'press', 'pointerdown', 'down'];
    var methodObj = {};

    function addEvent(selector, method, event) {

        var $delegateEl;
        var delegate = 'delegateEvents' + this.cid;
        if (!selector) {
            $delegateEl = this.$el;
        } else {
            $delegateEl = this.$el.find(selector);
        }


        _.each($delegateEl, function(element) {

            var $element = $(element);


            var newmethod = function() {
                $element.trigger('process');
                var args = Array.prototype.slice.call(arguments);
                DEBUG && console.log('ELEMENT: HIT THE BUTTON!!!!');
                return method.apply(this, args);
            };

            var throttledMethod = _.throttle(newmethod, 500, {
                trailing: false
            });

            if (!$element.hasClass(delegate) || !$element.hasClass(event)) {
                $element.addClass(delegate);
                $element.addClass(event);
                $element.attr('data-event', event);
                //element.addEventListener(event,newmethod);
                if (event === 'tap') {
                    $element.hammer({
                        preventDefault: true
                    }).on(event, throttledMethod);
                } else {
                    $element.hammer({
                        preventDefault: true
                    }).on(event, newmethod);
                }

                if (!methodObj[delegate]) {
                    methodObj[delegate] = {};
                }
                methodObj[delegate][event] = newmethod;
            }
        });

    }


    _.extend(Backbone.Model.prototype, {
        /**
         * saves current model state for undo
         */
        preserveState: function() {
            this.originalState = _.clone(this.attributes);
        },
        /**
         * backs out model changes one step only (currently)
         */
        undo: function() {
            if (this.originalState) {
                this.set(this.originalState);
                // this.originalState = null;
                /** need to fire events so ui state will be updated **/
                this.trigger('save');
            }
        },
        getStatus: function() {
            Backbone.Model.prototype.fetch.apply(this, arguments);
        },
        i18n: function(key, value, options) {
            options = options || {};
            var name = this.name || this.sandbox.name || '';
            name = name.replace(/app/, 'translation');
            if (key.match(':')) {
                if (!value) {
                    return this.sandbox.i18n.t(key, options);
                } else {
                    return this.sandbox.i18n.t(key + '.' + value, options);
                }
            } else if (value !== undefined) {
                if (value === '') {
                    return '';
                } else {
                    return this.sandbox.i18n.t(name + ':' + key + '.' + value, options);
                }

            } else if (name) {
                return this.sandbox.i18n.t(name + ':' + key, options);
            } else {
                return this.sandbox.i18n.t(key, options);
            }
        },
    });


    _.extend(Backbone.View.prototype, {
        _makeScrollable: function() {
            /** calculate the content box size **/

            this.$header = this.$el.find('header');
            this.$footer = this.$el.find('footer');
            this.$content = this.$el.find('.content');


            var viewportHeight = parseInt($(window).height(), 10),
                headerHeight = parseInt(this.$header.outerHeight(true), 10),
                footerHeight = parseInt(this.$footer.outerHeight(true), 10)


            if (this.$header.length === 0) {
                headerHeight = 0;
            }

            if (this.$footer.length === 0) {
                footerHeight = 0;
            }

            if (this.type === 'drawer') {
                viewportHeight = parseInt(this.$el.height(), 10);
            }


            //var contentHeight = viewportHeight - headerHeight - footerHeight;
            //


            // DEBUG && console.log('DEVICELIST:SETTINGS:contentHeight:' + contentHeight + ':footerHeight:' + footerHeight + ":headerHeight:" + headerHeight);
            this.$content.css({
                position: 'absolute',
                top: headerHeight + 'px',
                bottom: footerHeight + 'px',
                width: '100%'
            });


        },
        addBackButtonCommand: function(data) {
            var originalKey = data.key;

            var key = this.sandbox.name + '-' + this.cid + '-' + originalKey;

            // First create the event
            var command = new CustomEvent("addBackButtonCommand", {
                detail: {
                    key: key,
                    callback: data.callback
                }
            });

            // Trigger it!
            DEBUG && console.warn('DISPATCHING EVENT', command);
            document.dispatchEvent(command);

            /* window.app.events.emit('addBackButtonCommand', {
             key: key,
             callback: data.callback
             });*/
        },
        removeBackButtonCommand: function(key) {
            key = key || '';
            var originalKey = key;
            key = this.sandbox.name + '-' + this.cid + '-' + originalKey.key;

            var command = new CustomEvent("removeBackButtonCommand", {
                detail: {
                    key: key
                }
            });

            // Trigger it!
            DEBUG && console.warn('DISPATCHING EVENT', command);
            document.dispatchEvent(command);

            //   window.app.events.emit('removeBackButtonCommand', key);
        },
        renderHiddenDrawerContent: function(template) {
            var $parent = this.$el.parent();
            var html;
            if (!$parent.hasClass('open')) {

                $parent.addClass('shiftOffscreen').show();
                html = this.i18n(template);
                this.$el.html(html);
                $parent.removeClass('shiftOffscreen').hide();
            } else {
                html = this.i18n(template);
                this.$el.html(html);
            }
        },
        delegateEvents: function(events) {
            if (!(events || (events = _.result(this, 'events')))) {
                return this;
            }
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) {
                    method = this[events[key]];
                }
                if (!method) {
                    continue;
                }

                var match = key.match(delegateEventSplitter);
                var eventName = match[1],
                    selector = match[2];
                method = _.bind(method, this);


                if (eventName === 'move' || eventName === 'pointermove' || eventName === 'drag') {
                    addEvent.call(this, selector, method, 'drag');
                } else if (eventName === 'pointerup' || eventName === 'up' || eventName === 'tap') {
                    addEvent.call(this, selector, method, 'tap');
                } else if (_.indexOf(pointerEvents, eventName) !== -1) {
                    addEvent.call(this, selector, method, 'tap');
                } else if (eventName === 'longpress' || eventName === 'gesturelongpress' || eventName === 'hold') {
                    addEvent.call(this, selector, method, 'hold');
                } else {
                    eventName += '.delegateEvents' + this.cid;
                    if (selector === '') {
                        this.$el.on(eventName, method);
                    } else {
                        this.$el.on(eventName, selector, method);
                    }
                }


            }
            return this;
        },
        undelegateEvents: function() {
            var delegate = 'delegateEvents' + this.cid;
            this.$el.off('.' + delegate);
            _.each(this.$el.find(delegate), function(element) {
                var event;
                var $element = $(element);
                $element.removeClass(delegate);
                event = $element.attr('data-event');

                var method = methodObj[delegate];
                if (event) {
                    method = methodObj[delegate][event];
                }

                element.removeEventListener('tap', method);
                element.removeEventListener('drag', method);
                element.removeEventListener('hold', method);
                delete methodObj[delegate];
            });
            return this;
        },
        i18n: function(key, value, options) {
            options = options || {};
            var name = this.name || this.sandbox.name || '';

            name = name.replace(/app/, 'translation');

            if (typeof key === 'function') {

                var $html = this.sandbox.i18n.translate(key, name, options);
                this.sandbox.emit('widgetTemplate', {
                    sandbox: this.sandbox,
                    $el: $html
                });
                return $html;
            }

            if (value !== undefined) {
                if (value === '') {
                    return '';
                } else {
                    return this.sandbox.i18n.t(name + ':' + key + '.' + value, options);
                }

            } else if (key.match(/\:/gi)) {
                return this.sandbox.i18n.t(key, options);
            } else if (name) {
                return this.sandbox.i18n.t(name + ':' + key, options);
            }
        },
        /** for devices with jarden rules implementations **/
        checkRules: function() {
            var self = this;
            if (this.rulesTemplate && !this.sandbox.rulesEngine) {
                this.initializeRules();
            } else if (this.rulesTemplate) {
                this.rulesEngine = this.sandbox.rulesEngine;
                this.rulesEngine.collection.on('sync', this.rulesSync);
                this.rulesEngine.collection.on('getRulesTimeout', this.rulesSyncTimeout);
                this.rulesEngine.collection.fetch().fail(function(resp) {
                    DEBUG && console.log('GETRULES:FAIL:CHECKRULES ' + resp);
                    self.getRulesError(resp);
                });
            }
        },
        initializeRules: function() {

            var self = this;
            this.sandbox.rulesEngine = new this.sandbox.RulesEngine({
                sandbox: this.sandbox,
                template: this.rulesTemplate
            });

            this.rulesEngine = this.sandbox.rulesEngine;

            self.rulesEngine.collection.on('sync', self.rulesSync);
            self.rulesEngine.collection.on('getRulesTimeout', self.rulesSyncTimeout);
            self.rulesEngine.getTemplates().then(function() {
                self.rulesEngine.collection.fetch().done(function(resp) {
                    //Required only for when notifications are migrated off of the cloud.
                    //self.rulesEngine.defaultRules();
                }).fail(function(resp) {
                    DEBUG && console.log('GETRULES:FAIL:INITIALIZE ' + resp);
                    self.getRulesError(resp);
                });
            });
            self.rulesEngine.collection.on('saveError', self.rulesError);
        },
        rulesSync: function() {
            console.warn('rulesSync:this is a placeholder method. put this method in your view or remove the rules template!!!');
        },
        rulesSyncTimeout: function() {
            throw ('rulesSyncTimeout:this is a placeholder method. put this method in your view');
        },
        defaultRules: function() {
            console.warn('defaultRules:this is a placeholder method. put this method in your view');
        },
        rulesError: function(resp) {
            var self = this;
            self.sandbox.uiInterface.hideSpinner();
            this.confirmDialog = new this.sandbox.dom.CustomModal({
                title: self.sandbox.i18n.t('translation:errors.rulesTitle'),
                message: self.sandbox.i18n.t('translation:errors.rulesMessage'),
                popupClass: 'ruleSaveError',
                buttons: [{
                    text: self.sandbox.i18n.t('translation:buttons.continue')
                }]
            });
        },
        getRulesError: function(resp) {
            console.warn('getRulesError:this is a placeholder method. put this method in your view!!!');
        },
        /**
         * loads a widget with a reference stored in 'this' widget (when proper listeners are set)
         * @param {Jquery DOM element} $el element to insert the widget into
         * @param {widgetName} string name of the widget to load (ex:wemo_edit_devices)
         *
         */
        loadChildWidget: function(options) {
            if (!this.children) {
                this.children = {};
            }


            this.children[options.widgetName] = $('<div id="' + options.widgetName + '">');
            this.children[options.widgetName].append('<div data-aura-widget="' + options.widgetName + '"></div>');
            this.sandbox.start(this.children[options.widgetName], {
                name: options.widgetName,
                childWidget: true
            });

            options.$el.append(this.children[options.widgetName]);

        },
        removeChildWidget: function(widgetName) {
            var $el = $('#' + widgetName);
            if ($el.length > 0) {
                $el.remove();
                delete this.children(widgetName);
            }
        },
        getBrandName: function(model) {
            if (!model) model = this.model;
            return this.cleanString(model.get('brandName'));
        },
        cleanString: function(s){
            var output = "";
            try {
                output = decodeURIComponent(escape(s));
            } catch (e) {
                output = unescape(s);
            }

            return output;
        },
        setBrandFooter: function(model) {
            var footerbanner = this.$('footer > span:first-child');
            footerbanner.removeClass();
            footerbanner.addClass(this.i18n('brands', this.getBrandName(model)));
        }
    });


    return Backbone;
});
// Backbone.Stickit v0.9.2, MIT Licensed
// Copyright (c) 2012-2015 The New York Times, CMS Group, Matthew DeLambo <delambo@gmail.com>

(function(factory) {

    // Set up Stickit appropriately for the environment. Start with AMD.
    if (typeof define === 'function' && define.amd)
        define('backboneModelBinder',['underscore', 'backbone', 'exports'], factory);

    // Next for Node.js or CommonJS.
    else if (typeof exports === 'object')
        factory(require('underscore'), require('backbone'), exports);

    // Finally, as a browser global.
    else
        factory(_, Backbone, {});

}(function(_, Backbone, Stickit) {

    // Stickit Namespace
    // --------------------------

    // Export onto Backbone object
    Backbone.Stickit = Stickit;

    Stickit._handlers = [];

    Stickit.addHandler = function(handlers) {
        // Fill-in default values.
        handlers = _.map(_.flatten([handlers]), function(handler) {
            return _.defaults({}, handler, {
                updateModel: true,
                updateView: true,
                updateMethod: 'text'
            });
        });
        this._handlers = this._handlers.concat(handlers);
    };

    // Backbone.View Mixins
    // --------------------

    Stickit.ViewMixin = {

        // Collection of model event bindings.
        //   [{model,event,fn,config}, ...]
        _modelBindings: null,

        // Unbind the model and event bindings from `this._modelBindings` and
        // `this.$el`. If the optional `model` parameter is defined, then only
        // delete bindings for the given `model` and its corresponding view events.
        unstickit: function(model, bindingSelector) {

            // Support passing a bindings hash in place of bindingSelector.
            if (_.isObject(bindingSelector)) {
                _.each(bindingSelector, function(v, selector) {
                    this.unstickit(model, selector);
                }, this);
                return;
            }

            var models = [],
                destroyFns = [];
            this._modelBindings = _.reject(this._modelBindings, function(binding) {
                if (model && binding.model !== model) return;
                if (bindingSelector && binding.config.selector != bindingSelector) return;

                binding.model.off(binding.event, binding.fn);
                destroyFns.push(binding.config._destroy);
                models.push(binding.model);
                return true;
            });

            // Trigger an event for each model that was unbound.
            _.invoke(_.uniq(models), 'trigger', 'stickit:unstuck', this.cid);

            // Call `_destroy` on a unique list of the binding callbacks.
            _.each(_.uniq(destroyFns), function(fn) {
                fn.call(this);
            }, this);

            this.$el.off('.stickit' + (model ? '.' + model.cid : ''), bindingSelector);
        },

        // Initilize Stickit bindings for the view. Subsequent binding additions
        // can either call `stickit` with the new bindings, or add them directly
        // with `addBinding`. Both arguments to `stickit` are optional.
        stickit: function(optionalModel, optionalBindingsConfig) {
            var model = optionalModel || this.model,
                bindings = optionalBindingsConfig || _.result(this, "bindings") || {};

            this._modelBindings || (this._modelBindings = []);

            // Add bindings in bulk using `addBinding`.
            this.addBinding(model, bindings);

            // Wrap `view.remove` to unbind stickit model and dom events.
            var remove = this.remove;
            if (!remove.stickitWrapped) {
                this.remove = function() {
                    var ret = this;
                    this.unstickit();
                    if (remove) ret = remove.apply(this, arguments);
                    return ret;
                };
            }
            this.remove.stickitWrapped = true;
            return this;
        },

        // Add a single Stickit binding or a hash of bindings to the model. If
        // `optionalModel` is ommitted, will default to the view's `model` property.
        addBinding: function(optionalModel, selector, binding) {
            var model = optionalModel || this.model,
                namespace = '.stickit.' + model.cid;

            binding = binding || {};

            // Support jQuery-style {key: val} event maps.
            if (_.isObject(selector)) {
                var bindings = selector;
                _.each(bindings, function(val, key) {
                    this.addBinding(model, key, val);
                }, this);
                return;
            }

            // Special case the ':el' selector to use the view's this.$el.
            var $el = selector === ':el' ? this.$el : this.$(selector);

            // Clear any previous matching bindings.
            this.unstickit(model, selector);

            // Fail fast if the selector didn't match an element.
            if (!$el.length) return;

            // Allow shorthand setting of model attributes - `'selector':'observe'`.
            if (_.isString(binding)) binding = {
                observe: binding
            };

            // Handle case where `observe` is in the form of a function.
            if (_.isFunction(binding.observe)) binding.observe = binding.observe.call(this);

            // Find all matching Stickit handlers that could apply to this element
            // and store in a config object.
            var config = getConfiguration($el, binding);

            // The attribute we're observing in our config.
            var modelAttr = config.observe;

            // Store needed properties for later.
            config.selector = selector;
            config.view = this;

            // Create the model set options with a unique `bindId` so that we
            // can avoid double-binding in the `change:attribute` event handler.
            var bindId = config.bindId = _.uniqueId();

            // Add a reference to the view for handlers of stickitChange events
            var options = _.extend({
                stickitChange: config
            }, config.setOptions);

            // Add a `_destroy` callback to the configuration, in case `destroy`
            // is a named function and we need a unique function when unsticking.
            config._destroy = function() {
                applyViewFn.call(this, config.destroy, $el, model, config);
            };

            initializeAttributes($el, config, model, modelAttr);
            initializeVisible($el, config, model, modelAttr);
            initializeClasses($el, config, model, modelAttr);

            if (modelAttr) {
                // Setup one-way (input element -> model) bindings.
                _.each(config.events, function(type) {
                    var eventName = type + namespace;
                    var listener = function(event) {
                        var val = applyViewFn.call(this, config.getVal, $el, event, config, slice.call(arguments, 1));

                        // Don't update the model if false is returned from the `updateModel` configuration.
                        var currentVal = evaluateBoolean(config.updateModel, val, event, config);
                        if (currentVal) setAttr(model, modelAttr, val, options, config);
                    };
                    var sel = selector === ':el' ? '' : selector;
                    this.$el.on(eventName, sel, _.bind(listener, this));
                }, this);

                // Setup a `change:modelAttr` observer to keep the view element in sync.
                // `modelAttr` may be an array of attributes or a single string value.
                _.each(_.flatten([modelAttr]), function(attr) {
                    observeModelEvent(model, 'change:' + attr, config, function(m, val, options) {
                        var changeId = options && options.stickitChange && options.stickitChange.bindId;
                        if (changeId !== bindId) {
                            var currentVal = getAttr(model, modelAttr, config);
                            updateViewBindEl($el, config, currentVal, model);
                        }
                    });
                });

                var currentVal = getAttr(model, modelAttr, config);
                updateViewBindEl($el, config, currentVal, model, true);
            }

            // After each binding is setup, call the `initialize` callback.
            applyViewFn.call(this, config.initialize, $el, model, config);
        }
    };

    _.extend(Backbone.View.prototype, Stickit.ViewMixin);

    // Helpers
    // -------

    var slice = [].slice;

    // Evaluates the given `path` (in object/dot-notation) relative to the given
    // `obj`. If the path is null/undefined, then the given `obj` is returned.
    var evaluatePath = function(obj, path) {
        var parts = (path || '').split('.');
        var result = _.reduce(parts, function(memo, i) {
            return memo[i];
        }, obj);
        return result == null ? obj : result;
    };

    // If the given `fn` is a string, then view[fn] is called, otherwise it is
    // a function that should be executed.
    var applyViewFn = function(fn) {
        fn = _.isString(fn) ? evaluatePath(this, fn) : fn;
        if (fn) return (fn).apply(this, slice.call(arguments, 1));
    };

    // Given a function, string (view function reference), or a boolean
    // value, returns the truthy result. Any other types evaluate as false.
    // The first argument must be `reference` and the last must be `config`, but
    // middle arguments can be variadic.
    var evaluateBoolean = function(reference, val, config) {
        if (_.isBoolean(reference)) {
            return reference;
        } else if (_.isFunction(reference) || _.isString(reference)) {
            var view = _.last(arguments).view;
            return applyViewFn.apply(view, arguments);
        }
        return false;
    };

    // Setup a model event binding with the given function, and track the event
    // in the view's _modelBindings.
    var observeModelEvent = function(model, event, config, fn) {
        var view = config.view;
        model.on(event, fn, view);
        view._modelBindings.push({
            model: model,
            event: event,
            fn: fn,
            config: config
        });
    };

    // Prepares the given `val`ue and sets it into the `model`.
    var setAttr = function(model, attr, val, options, config) {
        var value = {},
            view = config.view;
        if (config.onSet) {
            val = applyViewFn.call(view, config.onSet, val, config);
        }

        if (config.set) {
            applyViewFn.call(view, config.set, attr, val, options, config);
        } else {
            value[attr] = val;
            // If `observe` is defined as an array and `onSet` returned
            // an array, then map attributes to their values.
            if (_.isArray(attr) && _.isArray(val)) {
                value = _.reduce(attr, function(memo, attribute, index) {
                    memo[attribute] = _.has(val, index) ? val[index] : null;
                    return memo;
                }, {});
            }
            model.set(value, options);
        }
    };

    // Returns the given `attr`'s value from the `model`, escaping and
    // formatting if necessary. If `attr` is an array, then an array of
    // respective values will be returned.
    var getAttr = function(model, attr, config) {
        var view = config.view;
        var retrieveVal = function(field) {
            return model[config.escape ? 'escape' : 'get'](field);
        };
        var sanitizeVal = function(val) {
            return val == null ? '' : val;
        };
        var val = _.isArray(attr) ? _.map(attr, retrieveVal) : retrieveVal(attr);
        if (config.onGet) val = applyViewFn.call(view, config.onGet, val, config);
        return _.isArray(val) ? _.map(val, sanitizeVal) : sanitizeVal(val);
    };

    // Find handlers in `Backbone.Stickit._handlers` with selectors that match
    // `$el` and generate a configuration by mixing them in the order that they
    // were found with the given `binding`.
    var getConfiguration = Stickit.getConfiguration = function($el, binding) {
        var handlers = [{
            updateModel: false,
            updateMethod: 'text',
            update: function($el, val, m, opts) {
                if ($el[opts.updateMethod]) $el[opts.updateMethod](val);
            },
            getVal: function($el, e, opts) {
                return $el[opts.updateMethod]();
            }
        }];
        handlers = handlers.concat(_.filter(Stickit._handlers, function(handler) {
            return $el.is(handler.selector);
        }));
        handlers.push(binding);

        // Merge handlers into a single config object. Last props in wins.
        var config = _.extend.apply(_, handlers);

        // `updateView` is defaulted to false for configutrations with
        // `visible`; otherwise, `updateView` is defaulted to true.
        if (!_.has(config, 'updateView')) config.updateView = !config.visible;
        return config;
    };

    // Setup the attributes configuration - a list that maps an attribute or
    // property `name`, to an `observe`d model attribute, using an optional
    // `onGet` formatter.
    //
    //     attributes: [{
    //       name: 'attributeOrPropertyName',
    //       observe: 'modelAttrName'
    //       onGet: function(modelAttrVal, modelAttrName) { ... }
    //     }, ...]
    //
    var initializeAttributes = function($el, config, model, modelAttr) {
        var props = ['autofocus', 'autoplay', 'async', 'checked', 'controls',
            'defer', 'disabled', 'hidden', 'indeterminate', 'loop', 'multiple',
            'open', 'readonly', 'required', 'scoped', 'selected'
        ];

        var view = config.view;

        _.each(config.attributes || [], function(attrConfig) {
            attrConfig = _.clone(attrConfig);
            attrConfig.view = view;

            var lastClass = '';
            var observed = attrConfig.observe || (attrConfig.observe = modelAttr);
            var updateAttr = function() {
                var updateType = _.contains(props, attrConfig.name) ? 'prop' : 'attr',
                    val = getAttr(model, observed, attrConfig);

                // If it is a class then we need to remove the last value and add the new.
                if (attrConfig.name === 'class') {
                    $el.removeClass(lastClass).addClass(val);
                    lastClass = val;
                } else {
                    $el[updateType](attrConfig.name, val);
                }
            };

            _.each(_.flatten([observed]), function(attr) {
                observeModelEvent(model, 'change:' + attr, config, updateAttr);
            });

            // Initialize the matched element's state.
            updateAttr();
        });
    };

    var initializeClasses = function($el, config, model, modelAttr) {
        _.each(config.classes || [], function(classConfig, name) {
            if (_.isString(classConfig)) classConfig = {
                observe: classConfig
            };
            classConfig.view = config.view;

            var observed = classConfig.observe;
            var updateClass = function() {
                var val = getAttr(model, observed, classConfig);
                $el.toggleClass(name, !!val);
            };

            _.each(_.flatten([observed]), function(attr) {
                observeModelEvent(model, 'change:' + attr, config, updateClass);
            });
            updateClass();
        });
    };

    // If `visible` is configured, then the view element will be shown/hidden
    // based on the truthiness of the modelattr's value or the result of the
    // given callback. If a `visibleFn` is also supplied, then that callback
    // will be executed to manually handle showing/hiding the view element.
    //
    //     observe: 'isRight',
    //     visible: true, // or function(val, options) {}
    //     visibleFn: function($el, isVisible, options) {} // optional handler
    //
    var initializeVisible = function($el, config, model, modelAttr) {
        if (config.visible == null) return;
        var view = config.view;

        var visibleCb = function() {
            var visible = config.visible,
                visibleFn = config.visibleFn,
                val = getAttr(model, modelAttr, config),
                isVisible = !!val;

            // If `visible` is a function then it should return a boolean result to show/hide.
            if (_.isFunction(visible) || _.isString(visible)) {
                isVisible = !!applyViewFn.call(view, visible, val, config);
            }

            // Either use the custom `visibleFn`, if provided, or execute the standard show/hide.
            if (visibleFn) {
                applyViewFn.call(view, visibleFn, $el, isVisible, config);
            } else {
                $el.toggle(isVisible);
            }
        };

        _.each(_.flatten([modelAttr]), function(attr) {
            observeModelEvent(model, 'change:' + attr, config, visibleCb);
        });

        visibleCb();
    };

    // Update the value of `$el` using the given configuration and trigger the
    // `afterUpdate` callback. This action may be blocked by `config.updateView`.
    //
    //     update: function($el, val, model, options) {},  // handler for updating
    //     updateView: true, // defaults to true
    //     afterUpdate: function($el, val, options) {} // optional callback
    //
    var updateViewBindEl = function($el, config, val, model, isInitializing) {
        var view = config.view;
        if (!evaluateBoolean(config.updateView, val, config)) return;
        applyViewFn.call(view, config.update, $el, val, model, config);
        if (!isInitializing) applyViewFn.call(view, config.afterUpdate, $el, val, config);
    };

    // Default Handlers
    // ----------------

    Stickit.addHandler([{
        selector: '[contenteditable]',
        updateMethod: 'html',
        events: ['input', 'change']
    }, {
        selector: 'input',
        events: ['propertychange', 'input', 'change'],
        update: function($el, val) {
            $el.val(val);
        },
        getVal: function($el) {
            return $el.val();
        }
    }, {
        selector: 'textarea',
        events: ['propertychange', 'input', 'change'],
        update: function($el, val) {
            $el.val(val);
        },
        getVal: function($el) {
            return $el.val();
        }
    }, {
        selector: 'input[type="radio"]',
        events: ['change'],
        update: function($el, val) {
            $el.filter('[value="' + val + '"]').prop('checked', true);
        },
        getVal: function($el) {
            return $el.filter(':checked').val();
        }
    }, {
        selector: 'input[type="checkbox"]',
        events: ['change'],
        update: function($el, val, model, options) {
            if ($el.length > 1) {
                // There are multiple checkboxes so we need to go through them and check
                // any that have value attributes that match what's in the array of `val`s.
                val || (val = []);
                $el.each(function(i, el) {
                    var checkbox = Backbone.$(el);
                    var checked = _.contains(val, checkbox.val());
                    checkbox.prop('checked', checked);
                });
            } else {
                var checked = _.isBoolean(val) ? val : val === $el.val();
                $el.prop('checked', checked);
            }
        },
        getVal: function($el) {
            var val;
            if ($el.length > 1) {
                val = _.reduce($el, function(memo, el) {
                    var checkbox = Backbone.$(el);
                    if (checkbox.prop('checked')) memo.push(checkbox.val());
                    return memo;
                }, []);
            } else {
                val = $el.prop('checked');
                // If the checkbox has a value attribute defined, then
                // use that value. Most browsers use "on" as a default.
                var boxval = $el.val();
                if (boxval !== 'on' && boxval != null) {
                    val = val ? $el.val() : null;
                }
            }
            return val;
        }
    }, {
        selector: 'select',
        events: ['change'],
        update: function($el, val, model, options) {
            var optList,
                selectConfig = options.selectOptions,
                list = selectConfig && selectConfig.collection || undefined,
                isMultiple = $el.prop('multiple');

            // If there are no `selectOptions` then we assume that the `<select>`
            // is pre-rendered and that we need to generate the collection.
            if (!selectConfig) {
                selectConfig = {};
                var getList = function($el) {
                    return $el.map(function(index, option) {
                        // Retrieve the text and value of the option, preferring "stickit-bind-val"
                        // data attribute over value property.
                        var dataVal = Backbone.$(option).data('stickit-bind-val');
                        return {
                            value: dataVal !== undefined ? dataVal : option.value,
                            label: option.text
                        };
                    }).get();
                };
                if ($el.find('optgroup').length) {
                    list = {
                        opt_labels: []
                    };
                    // Search for options without optgroup
                    if ($el.find('> option').length) {
                        list.opt_labels.push(undefined);
                        _.each($el.find('> option'), function(el) {
                            list[undefined] = getList(Backbone.$(el));
                        });
                    }
                    _.each($el.find('optgroup'), function(el) {
                        var label = Backbone.$(el).attr('label');
                        list.opt_labels.push(label);
                        list[label] = getList(Backbone.$(el).find('option'));
                    });
                } else {
                    list = getList($el.find('option'));
                }
            }

            // Fill in default label and path values.
            selectConfig.valuePath = selectConfig.valuePath || 'value';
            selectConfig.labelPath = selectConfig.labelPath || 'label';
            selectConfig.disabledPath = selectConfig.disabledPath || 'disabled';

            var addSelectOptions = function(optList, $el, fieldVal) {
                _.each(optList, function(obj) {
                    var option = Backbone.$('<option/>'),
                        optionVal = obj;

                    var fillOption = function(text, val, disabled) {
                        option.text(text);
                        optionVal = val;
                        // Save the option value as data so that we can reference it later.
                        option.data('stickit-bind-val', optionVal);
                        if (!_.isArray(optionVal) && !_.isObject(optionVal)) option.val(optionVal);

                        if (disabled === true) option.prop('disabled', 'disabled');
                    };

                    var text, val, disabled;
                    if (obj === '__default__') {
                        text = fieldVal.label,
                        val = fieldVal.value,
                        disabled = fieldVal.disabled;
                    } else {
                        text = evaluatePath(obj, selectConfig.labelPath),
                        val = evaluatePath(obj, selectConfig.valuePath),
                        disabled = evaluatePath(obj, selectConfig.disabledPath);
                    }
                    fillOption(text, val, disabled);

                    // Determine if this option is selected.
                    var isSelected = function() {
                        if (!isMultiple && optionVal != null && fieldVal != null && optionVal === fieldVal) {
                            return true;
                        } else if (_.isObject(fieldVal) && _.isEqual(optionVal, fieldVal)) {
                            return true;
                        }
                        return false;
                    };

                    if (isSelected()) {
                        option.prop('selected', true);
                    } else if (isMultiple && _.isArray(fieldVal)) {
                        _.each(fieldVal, function(val) {
                            if (_.isObject(val)) val = evaluatePath(val, selectConfig.valuePath);
                            if (val === optionVal || (_.isObject(val) && _.isEqual(optionVal, val)))
                                option.prop('selected', true);
                        });
                    }

                    $el.append(option);
                });
            };

            $el.find('*').remove();

            // The `list` configuration is a function that returns the options list or a string
            // which represents the path to the list relative to `window` or the view/`this`.
            if (_.isString(list)) {
                var context = window;
                if (list.indexOf('this.') === 0) context = this;
                list = list.replace(/^[a-z]*\.(.+)$/, '$1');
                optList = evaluatePath(context, list);
            } else if (_.isFunction(list)) {
                optList = applyViewFn.call(this, list, $el, options);
            } else {
                optList = list;
            }

            // Support Backbone.Collection and deserialize.
            if (optList instanceof Backbone.Collection) {
                var collection = optList;
                var refreshSelectOptions = function() {
                    var currentVal = getAttr(model, options.observe, options);
                    applyViewFn.call(this, options.update, $el, currentVal, model, options);
                };
                // We need to call this function after unstickit and after an update so we don't end up
                // with multiple listeners doing the same thing
                var removeCollectionListeners = function() {
                    collection.off('add remove reset sort', refreshSelectOptions);
                };
                var removeAllListeners = function() {
                    removeCollectionListeners();
                    collection.off('stickit:selectRefresh');
                    model.off('stickit:selectRefresh');
                };
                // Remove previously set event listeners by triggering a custom event
                collection.trigger('stickit:selectRefresh');
                collection.once('stickit:selectRefresh', removeCollectionListeners, this);

                // Listen to the collection and trigger an update of the select options
                collection.on('add remove reset sort', refreshSelectOptions, this);

                // Remove the previous model event listener
                model.trigger('stickit:selectRefresh');
                model.once('stickit:selectRefresh', function() {
                    model.off('stickit:unstuck', removeAllListeners);
                });
                // Remove collection event listeners once this binding is unstuck
                model.once('stickit:unstuck', removeAllListeners, this);
                optList = optList.toJSON();
            }

            if (selectConfig.defaultOption) {
                var option = _.isFunction(selectConfig.defaultOption) ?
                    selectConfig.defaultOption.call(this, $el, options) :
                    selectConfig.defaultOption;
                addSelectOptions(["__default__"], $el, option);
            }

            if (_.isArray(optList)) {
                addSelectOptions(optList, $el, val);
            } else if (optList.opt_labels) {
                // To define a select with optgroups, format selectOptions.collection as an object
                // with an 'opt_labels' property, as in the following:
                //
                //     {
                //       'opt_labels': ['Looney Tunes', 'Three Stooges'],
                //       'Looney Tunes': [{id: 1, name: 'Bugs Bunny'}, {id: 2, name: 'Donald Duck'}],
                //       'Three Stooges': [{id: 3, name : 'moe'}, {id: 4, name : 'larry'}, {id: 5, name : 'curly'}]
                //     }
                //
                _.each(optList.opt_labels, function(label) {
                    var $group = Backbone.$('<optgroup/>').attr('label', label);
                    addSelectOptions(optList[label], $group, val);
                    $el.append($group);
                });
                // With no 'opt_labels' parameter, the object is assumed to be a simple value-label map.
                // Pass a selectOptions.comparator to override the default order of alphabetical by label.
            } else {
                var opts = [],
                    opt;
                for (var i in optList) {
                    opt = {};
                    opt[selectConfig.valuePath] = i;
                    opt[selectConfig.labelPath] = optList[i];
                    opts.push(opt);
                }
                opts = _.sortBy(opts, selectConfig.comparator || selectConfig.labelPath);
                addSelectOptions(opts, $el, val);
            }
        },
        getVal: function($el) {
            var selected = $el.find('option:selected');

            if ($el.prop('multiple')) {
                return _.map(selected, function(el) {
                    return Backbone.$(el).data('stickit-bind-val');
                });
            } else {
                return selected.data('stickit-bind-val');
            }
        }
    }]);

    return Stickit;

}));
(function() {
 
  var arrays, basicObjects, deepClone, deepExtend, deepExtendCouple, isBasicObject,
    __slice = [].slice;

  deepClone = function(obj) {
    var func, isArr;
    if (!_.isObject(obj || _.isFunction(obj))) {
      return obj;
    }
    if (_.isDate(obj)) {
      return new Date(obj.getTime());
    }
    if (_.isRegExp(obj)) {
      return new RegExp(obj.source, obj.toString().replace(/.*\//, ""));
    }
    isArr = _.isArray(obj || _.isArguments(obj));
    func = function(memo, value, key) {
      if (isArr) {
        memo.push(deepClone(value));
      } else {
        memo[key] = deepClone(value);
      }
      return memo;
    };
    return _.reduce(obj, func, isArr ? [] : {});
  };

  isBasicObject = function(object) {
    return (object.prototype === {}.prototype || object.prototype === Object.prototype) && _.isObject(object) && !_.isArray(object) && !_.isFunction(object) && !_.isDate(object) && !_.isRegExp(object) && !_.isArguments(object);
  };

  basicObjects = function(object) {
    return _.filter(_.keys(object), function(key) {
      return isBasicObject(object[key]);
    });
  };

  arrays = function(object) {
    return _.filter(_.keys(object), function(key) {
      return _.isArray(object[key]);
    });
  };

  deepExtendCouple = function(destination, source, maxDepth) {
    var combine, recurse, sharedArrayKey, sharedArrayKeys, sharedObjectKey, sharedObjectKeys, _i, _j, _len, _len1;
    if (maxDepth == null) {
      maxDepth = 20;
    }
    if (maxDepth <= 0) {
      console.warn('_.deepExtend(): Maximum depth of recursion hit.');
      return _.extend(destination, source);
    }
    sharedObjectKeys = _.intersection(basicObjects(destination), basicObjects(source));
    recurse = function(key) {
      return source[key] = deepExtendCouple(destination[key], source[key], maxDepth - 1);
    };
    for (_i = 0, _len = sharedObjectKeys.length; _i < _len; _i++) {
      sharedObjectKey = sharedObjectKeys[_i];
      recurse(sharedObjectKey);
    }
    sharedArrayKeys = _.intersection(arrays(destination), arrays(source));
    combine = function(key) {
      return source[key] = _.union(destination[key], source[key]);
    };
    for (_j = 0, _len1 = sharedArrayKeys.length; _j < _len1; _j++) {
      sharedArrayKey = sharedArrayKeys[_j];
      combine(sharedArrayKey);
    }
    return _.extend(destination, source);
  };

  deepExtend = function() {
    var finalObj, maxDepth, objects, _i;
    objects = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), maxDepth = arguments[_i++];
    if (!_.isNumber(maxDepth)) {
      objects.push(maxDepth);
      maxDepth = 20;
    }
    if (objects.length <= 1) {
      return objects[0];
    }
    if (maxDepth <= 0) {
      return _.extend.apply(this, objects);
    }
    finalObj = objects.shift();
    while (objects.length > 0) {
      finalObj = deepExtendCouple(finalObj, deepClone(objects.shift()), maxDepth);
    }
    return finalObj;
  };

  _.mixin({
    deepClone: deepClone,
    isBasicObject: isBasicObject,
    basicObjects: basicObjects,
    arrays: arrays,
    deepExtend: deepExtend
  });

}).call(this);
define("plugins/underscore.mixin.deepExtend", function(){});

/**
 * Main source
 */

;
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('Cache',['underscore', 'backbone'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = factory(require('underscore'), require('backbone'));
    } else {
        // globals
        factory(_, Backbone);
    }
}(function(_, Backbone) {

    /**
     * Takes a nested object and returns a shallow object keyed with the path names
     * e.g. { "level1.level2": "value" }
     *
     * @param  {Object}      Nested object e.g. { level1: { level2: 'value' } }
     * @return {Object}      Shallow object with path names e.g. { 'level1.level2': 'value' }
     */
    function objToPaths(obj) {

        var ret = {},
            separator = DeepModel.keyPathSeparator;

        for (var key in obj) {
            /** michael forbes - added exclusion for sandbox. **/
            if (key !== 'sandbox') {
                var val = obj[key];

                if (val && (val.constructor === Object || val.constructor === Array) && !_.isEmpty(val)) {
                    //Recursion for embedded objects
                    var obj2 = objToPaths(val);

                    for (var key2 in obj2) {
                        var val2 = obj2[key2];

                        ret[key + separator + key2] = val2;
                    }
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    /**
     * @param {Object}  Object to fetch attribute from
     * @param {String}  Object path e.g. 'user.name'
     * @return {Mixed}
     */
    function getNested(obj, path, return_exists) {
        var separator = DeepModel.keyPathSeparator;

        var fields = path ? path.split(separator) : [];
        var result = obj;
        return_exists || (return_exists === false);
        for (var i = 0, n = fields.length; i < n; i++) {
            if (return_exists && !_.has(result, fields[i])) {
                return false;
            }
            result = result[fields[i]];

            if (result == null && i < n - 1) {
                result = {};
            }

            if (typeof result === 'undefined') {
                if (return_exists) {
                    return true;
                }
                return result;
            }
        }
        if (return_exists) {
            return true;
        }
        return result;
    }

    /**
     * @param {Object} obj                Object to fetch attribute from
     * @param {String} path               Object path e.g. 'user.name'
     * @param {Object} [options]          Options
     * @param {Boolean} [options.unset]   Whether to delete the value
     * @param {Mixed}                     Value to set
     */
    function setNested(obj, path, val, options) {
        options = options || {};

        var separator = DeepModel.keyPathSeparator;

        var fields = path ? path.split(separator) : [];
        var result = obj;
        for (var i = 0, n = fields.length; i < n && result !== undefined; i++) {
            var field = fields[i];

            //If the last in the path, set the value
            if (i === n - 1) {
                options.unset ? delete result[field] : result[field] = val;
            } else {
                //Create the child object if it doesn't exist, or isn't an object
                if (typeof result[field] === 'undefined' || !_.isObject(result[field])) {
                    var nextField = fields[i + 1];

                    // create array if next field is integer, else create object
                    result[field] = /^\d+$/.test(nextField) ? [] : {};
                }

                //Move onto the next part of the path
                result = result[field];
            }
        }
    }

    function deleteNested(obj, path) {
        setNested(obj, path, null, {
            unset: true
        });
    }

    var DeepModel = Backbone.Model.extend({

        // Override constructor
        // Support having nested defaults by using _.deepExtend instead of _.extend
        constructor: function(attributes, options) {
            var defaults;
            var attrs = attributes || {};
            this.cid = _.uniqueId('c');
            this.attributes = {};
            if (options && options.collection) this.collection = options.collection;
            if (options && options.parse) attrs = this.parse(attrs, options) || {};
            if (defaults = _.result(this, 'defaults')) {
                //<custom code>
                // Replaced the call to _.defaults with _.deepExtend.
                attrs = _.deepExtend({}, defaults, attrs);
                //</custom code>
            }
            this.set(attrs, options);
            this.changed = {};
            this.initialize.apply(this, arguments);
        },

        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
            return _.deepClone(this.attributes);
        },

        // Override get
        // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'
        get: function(attr) {
            return getNested(this.attributes, attr);
        },

        // Override set
        // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'
        set: function(key, val, options) {
            var attr, attrs, unset, changes, silent, changing, prev, current;
            if (key == null) return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (typeof key === 'object') {
                attrs = key;
                options = val || {};
            } else {
                (attrs = {})[key] = val;
            }

            options || (options = {});

            // Run validation.
            if (!this._validate(attrs, options)) return false;

            // Extract attributes and options.
            unset = options.unset;
            silent = options.silent;
            changes = [];
            changing = this._changing;
            this._changing = true;

            if (!changing) {
                this._previousAttributes = _.deepClone(this.attributes); //<custom>: Replaced _.clone with _.deepClone
                this.changed = {};
            }
            current = this.attributes, prev = this._previousAttributes;

            // Check for changes of `id`.
            if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

            //<custom code>
            attrs = objToPaths(attrs);
            //</custom code>

            // For each `set` attribute, update or delete the current value.
            for (attr in attrs) {
                val = attrs[attr];

                //<custom code>: Using getNested, setNested and deleteNested
                if (!_.isEqual(getNested(current, attr), val)) changes.push(attr);
                if (!_.isEqual(getNested(prev, attr), val)) {
                    setNested(this.changed, attr, val);
                } else {
                    deleteNested(this.changed, attr);
                }
                unset ? deleteNested(current, attr) : setNested(current, attr, val);
                //</custom code>
            }

            // Trigger all relevant attribute changes.
            if (!silent) {
                if (changes.length) this._pending = true;

                //<custom code>
                var separator = DeepModel.keyPathSeparator;
                var alreadyTriggered = {}; // * @restorer

                for (var i = 0, l = changes.length; i < l; i++) {
                    var key = changes[i];

                    if (!alreadyTriggered.hasOwnProperty(key) || !alreadyTriggered[key]) { // * @restorer
                        alreadyTriggered[key] = true; // * @restorer
                        this.trigger('change:' + key, this, getNested(current, key), options);
                    } // * @restorer

                    var fields = key.split(separator);

                    //Trigger change events for parent keys with wildcard (*) notation
                    for (var n = fields.length - 1; n > 0; n--) {
                        var parentKey = _.first(fields, n).join(separator),
                            wildcardKey = parentKey + separator + '*';

                        if (!alreadyTriggered.hasOwnProperty(wildcardKey) || !alreadyTriggered[wildcardKey]) { // * @restorer
                            alreadyTriggered[wildcardKey] = true; // * @restorer
                            this.trigger('change:' + wildcardKey, this, getNested(current, parentKey), options);
                        } // * @restorer

                        // + @restorer
                        if (!alreadyTriggered.hasOwnProperty(parentKey) || !alreadyTriggered[parentKey]) {
                            alreadyTriggered[parentKey] = true;
                            this.trigger('change:' + parentKey, this, getNested(current, parentKey), options);
                        }
                        // - @restorer
                    }
                    //</custom code>
                }
            }

            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    this._pending = false;
                    this.trigger('change', this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },

        // Clear all attributes on the model, firing `"change"` unless you choose
        // to silence it.
        clear: function(options) {
            var attrs = {};
            var shallowAttributes = objToPaths(this.attributes);
            for (var key in shallowAttributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {
                unset: true
            }));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return getNested(this.changed, attr) !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
            //<custom code>: objToPaths
            if (!diff) return this.hasChanged() ? objToPaths(this.changed) : false;
            //</custom code>

            var old = this._changing ? this._previousAttributes : this.attributes;

            //<custom code>
            diff = objToPaths(diff);
            old = objToPaths(old);
            //</custom code>

            var val, changed = false;
            for (var attr in diff) {
                if (_.isEqual(old[attr], (val = diff[attr]))) continue;
                (changed || (changed = {}))[attr] = val;
            }
            return changed;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;

            //<custom code>
            return getNested(this._previousAttributes, attr);
            //</custom code>
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
            //<custom code>
            return _.deepClone(this._previousAttributes);
            //</custom code>
        }
    });


    //Config; override in your app to customise
    DeepModel.keyPathSeparator = '.';


    //Exports
    Backbone.DeepModel = DeepModel;

    //For use in NodeJS
    if (typeof module != 'undefined') module.exports = DeepModel;

    return Backbone;

}));
define('extensions/backbone',['Cache'],function(Backbone) {

    'use strict';

    return{
        initialize: function (app) {
            app.core.mvc    = Backbone;
            app.sandbox.mvc = Backbone;
            app.core.registerWidgetType('Backbone', Backbone.View.prototype);
        }
    }
});
define('extensions/handlebars',['handlebars', 'i18next'],function(Handlebars, i18n) {

    Handlebars.registerHelper('t', function(i18n_key) {
        var result = i18n.t(i18n_key);
        return new Handlebars.SafeString(result);
    });

    Handlebars.registerHelper('i18n', function(i18n_key) {
        if(Handlebars.widget){
            var result = i18n.t(i18n_key);
        }
        else{

        }
        return new Handlebars.SafeString(result);
    });

    return{
        initialize: function (app) {
            app.core.template.hbs = Handlebars;
        }
    }
});
define('extensions/storage', [], function() {

    'use strict';
    //taken from basket.js - also included in this project.
    var defaultExpiration = 5000;

    var wrapStoreData = function(obj, data) {
        var now = +new Date();
        obj.data = data;
        obj.stamp = now;
        obj.expire = now + ((obj.expire || defaultExpiration) * 1000);
        return obj;
    };

    var Storage = Object.create({
        setItem: function(key, value, expire) {
            var objValue = JSON.stringify(wrapStoreData({
                expire: expire
            }, value));
            window.localStorage.setItem(key, objValue);
            return true;
        },
        getItem: function(key) {
            var now = +new Date();
            var item = window.localStorage.getItem(key);

            if (item) {
                item = JSON.parse(item);
            }

            if (item && (item.expire < now) && item.expire > 0) {
                this.removeItem(key);
                return null;
            } else if (item) {
                return item;
            } else {
                return null;
            }
        },
        removeItem: function(key) {
            window.localStorage.removeItem(key);
        }

    });



    return {
        initialize: function(app) {
            app.core.util.Storage = Storage;
            app.core.util.storage = Object.create(Storage);
            _.extend(app.sandbox, {
                setItem: function(key, value) {
                    if (this.model.id) {
                        key = this.model.id + '-' + key;
                    } else key = this.ref + '-' + key;
                    return Storage.setItem.call(this, key, value);
                },
                getItem: function(key) {
                    if (this.model.id) {
                        key = this.model.id + '-' + key;
                    } else key = this.ref + '-' + key;
                    var item = Storage.getItem.call(this, key);
                    if (item) {
                        return item.data;
                    } else {
                        return;
                    }

                },
                removeItem: function(key) {
                    if (this.model.id) {
                        key = this.model.id + '-' + key;
                    } else key = this.ref + '-' + key;
                    return Storage.removeItem.call(this, key);
                }
            })
        }
    };
});

/// this.sandbox.util.storage.setItem();
define('extensions/utils/css', [], function () {

    'use strict';

    var Stylesheet = function (widgetName, strStyles) {
        this.sheet = document.createElement("style");
        this.sheet.setAttribute('id', 'stylesheet-' + widgetName);
        this.sheet.appendChild(document.createTextNode(""));

        document.head.appendChild(this.sheet);

        if (strStyles) {
            this.processStyles(strStyles);
        }
    };

    Stylesheet.prototype = {
        constructor: Stylesheet,
        addRule: function (selector, rules, index) {
            if (this.sheet.insertRule) {
                this.sheet.insertRule(selector + "{" + rules + "}", index);
            }
            else {
                this.sheet.addRule(selector, rules, index);
            }
        },
        deleteRule: function (selector, rules) {
            //need to find the rule to delete it
            var foundRules = this.findRules(selector, rules);
        },
        processStyles: function (strStyles) {
            //need to take a string of rules and break it apart to add rules and ensure that the widget name is prepended to every rule
            this.sheet.appendChild(document.createTextNode(strStyles));
        },
        findRules: function (selector, rules) {
            var foundRules = [];
            var currentRules = this.sheet.cssRules ? this.sheet.cssRules : this.sheet.rules;
            currentRules.forEach(function (currentRule, index) {
                if (currentRule.selectorText === selector) {
                    foundRules.push({
                        currentRule: currentRule,
                        index: index
                    });
                }
            });

            return foundRules;
        }
    };


    return{
        initialize: function (app) {
            app.core.util.Stylesheet = Stylesheet;
        }
    };
});
/*! shifty - v1.4.1 - 2015-04-19 - http://jeremyckahn.github.io/shifty */ ;
(function() {
    var root = this;

    /*!
     * Shifty Core
     * By Jeremy Kahn - jeremyckahn@gmail.com
     */

    var Tweenable = (function() {

        'use strict';

        // Aliases that get defined later in this function
        var formula;

        // CONSTANTS
        var DEFAULT_SCHEDULE_FUNCTION;
        var DEFAULT_EASING = 'linear';
        var DEFAULT_DURATION = 500;
        var UPDATE_TIME = 1000 / 60;

        var _now = Date.now ? Date.now : function() {
            return +new Date();
        };

        var now = typeof SHIFTY_DEBUG_NOW !== 'undefined' ? SHIFTY_DEBUG_NOW : _now;

        if (typeof window !== 'undefined') {
            // requestAnimationFrame() shim by Paul Irish (modified for Shifty)
            // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
            DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || (window.mozCancelRequestAnimationFrame && window.mozRequestAnimationFrame) || setTimeout;
        } else {
            DEFAULT_SCHEDULE_FUNCTION = setTimeout;
        }

        function noop() {
            // NOOP!
        }

        /*!
         * Handy shortcut for doing a for-in loop. This is not a "normal" each
         * function, it is optimized for Shifty.  The iterator function only receives
         * the property name, not the value.
         * @param {Object} obj
         * @param {Function(string)} fn
         */
        function each(obj, fn) {
            var key;
            for (key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    fn(key);
                }
            }
        }

        /*!
         * Perform a shallow copy of Object properties.
         * @param {Object} targetObject The object to copy into
         * @param {Object} srcObject The object to copy from
         * @return {Object} A reference to the augmented `targetObj` Object
         */
        function shallowCopy(targetObj, srcObj) {
            each(srcObj, function(prop) {
                targetObj[prop] = srcObj[prop];
            });

            return targetObj;
        }

        /*!
         * Copies each property from src onto target, but only if the property to
         * copy to target is undefined.
         * @param {Object} target Missing properties in this Object are filled in
         * @param {Object} src
         */
        function defaults(target, src) {
            each(src, function(prop) {
                if (typeof target[prop] === 'undefined') {
                    target[prop] = src[prop];
                }
            });
        }

        /*!
         * Calculates the interpolated tween values of an Object for a given
         * timestamp.
         * @param {Number} forPosition The position to compute the state for.
         * @param {Object} currentState Current state properties.
         * @param {Object} originalState: The original state properties the Object is
         * tweening from.
         * @param {Object} targetState: The destination state properties the Object
         * is tweening to.
         * @param {number} duration: The length of the tween in milliseconds.
         * @param {number} timestamp: The UNIX epoch time at which the tween began.
         * @param {Object} easing: This Object's keys must correspond to the keys in
         * targetState.
         */
        function tweenProps(forPosition, currentState, originalState, targetState,
            duration, timestamp, easing) {
            var normalizedPosition =
                forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;


            var prop;
            for (prop in currentState) {
                if (currentState.hasOwnProperty(prop)) {
                    currentState[prop] = tweenProp(originalState[prop],
                        targetState[prop], formula[easing[prop]], normalizedPosition);
                }
            }

            return currentState;
        }

        /*!
         * Tweens a single property.
         * @param {number} start The value that the tween started from.
         * @param {number} end The value that the tween should end at.
         * @param {Function} easingFunc The easing curve to apply to the tween.
         * @param {number} position The normalized position (between 0.0 and 1.0) to
         * calculate the midpoint of 'start' and 'end' against.
         * @return {number} The tweened value.
         */
        function tweenProp(start, end, easingFunc, position) {
            return start + (end - start) * easingFunc(position);
        }

        /*!
         * Applies a filter to Tweenable instance.
         * @param {Tweenable} tweenable The `Tweenable` instance to call the filter
         * upon.
         * @param {String} filterName The name of the filter to apply.
         */
        function applyFilter(tweenable, filterName) {
            var filters = Tweenable.prototype.filter;
            var args = tweenable._filterArgs;

            each(filters, function(name) {
                if (typeof filters[name][filterName] !== 'undefined') {
                    filters[name][filterName].apply(tweenable, args);
                }
            });
        }

        var timeoutHandler_endTime;
        var timeoutHandler_currentTime;
        var timeoutHandler_isEnded;
        var timeoutHandler_offset;
        /*!
         * Handles the update logic for one step of a tween.
         * @param {Tweenable} tweenable
         * @param {number} timestamp
         * @param {number} delay
         * @param {number} duration
         * @param {Object} currentState
         * @param {Object} originalState
         * @param {Object} targetState
         * @param {Object} easing
         * @param {Function(Object, *, number)} step
         * @param {Function(Function,number)}} schedule
         * @param {number=} opt_currentTimeOverride Needed for accurate timestamp in
         * Tweenable#seek.
         */
        function timeoutHandler(tweenable, timestamp, delay, duration, currentState,
            originalState, targetState, easing, step, schedule,
            opt_currentTimeOverride) {

            timeoutHandler_endTime = timestamp + delay + duration;

            timeoutHandler_currentTime =
                Math.min(opt_currentTimeOverride || now(), timeoutHandler_endTime);

            timeoutHandler_isEnded =
                timeoutHandler_currentTime >= timeoutHandler_endTime;

            timeoutHandler_offset = duration - (
                timeoutHandler_endTime - timeoutHandler_currentTime);

            if (tweenable.isPlaying() && !timeoutHandler_isEnded) {
                tweenable._scheduleId = schedule(tweenable._timeoutHandler, UPDATE_TIME);

                applyFilter(tweenable, 'beforeTween');

                // If the animation has not yet reached the start point (e.g., there was
                // delay that has not yet completed), just interpolate the starting
                // position of the tween.
                if (timeoutHandler_currentTime < (timestamp + delay)) {
                    tweenProps(1, currentState, originalState, targetState, 1, 1, easing);
                } else {
                    tweenProps(timeoutHandler_currentTime, currentState, originalState,
                        targetState, duration, timestamp + delay, easing);
                }

                applyFilter(tweenable, 'afterTween');

                step(currentState, tweenable._attachment, timeoutHandler_offset);
            } else if (timeoutHandler_isEnded) {
                step(targetState, tweenable._attachment, timeoutHandler_offset);
                tweenable.stop(true);
            }
        }


        /*!
         * Creates a usable easing Object from either a string or another easing
         * Object.  If `easing` is an Object, then this function clones it and fills
         * in the missing properties with "linear".
         * @param {Object} fromTweenParams
         * @param {Object|string} easing
         */
        function composeEasingObject(fromTweenParams, easing) {
            var composedEasing = {};

            if (typeof easing === 'string') {
                each(fromTweenParams, function(prop) {
                    composedEasing[prop] = easing;
                });
            } else {
                each(fromTweenParams, function(prop) {
                    if (!composedEasing[prop]) {
                        composedEasing[prop] = easing[prop] || DEFAULT_EASING;
                    }
                });
            }

            return composedEasing;
        }

        /**
         * Tweenable constructor.
         * @class Tweenable
         * @param {Object=} opt_initialState The values that the initial tween should
         * start at if a `from` object is not provided to `{{#crossLink
         * "Tweenable/tween:method"}}{{/crossLink}}` or `{{#crossLink
         * "Tweenable/setConfig:method"}}{{/crossLink}}`.
         * @param {Object=} opt_config Configuration object to be passed to
         * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
         * @module Tweenable
         * @constructor
         */
        function Tweenable(opt_initialState, opt_config) {
            this._currentState = opt_initialState || {};
            this._configured = false;
            this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;

            // To prevent unnecessary calls to setConfig do not set default
            // configuration here.  Only set default configuration immediately before
            // tweening if none has been set.
            if (typeof opt_config !== 'undefined') {
                this.setConfig(opt_config);
            }
        }

        /**
         * Configure and start a tween.
         * @method tween
         * @param {Object=} opt_config Configuration object to be passed to
         * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
         * @chainable
         */
        Tweenable.prototype.tween = function(opt_config) {
            if (this._isTweening) {
                return this;
            }

            // Only set default config if no configuration has been set previously and
            // none is provided now.
            if (opt_config !== undefined || !this._configured) {
                this.setConfig(opt_config);
            }

            this._timestamp = now();
            this._start(this.get(), this._attachment);
            return this.resume();
        };

        /**
         * Configure a tween that will start at some point in the future.
         *
         * @method setConfig
         * @param {Object} config The following values are valid:
         * - __from__ (_Object=_): Starting position.  If omitted, `{{#crossLink
         *   "Tweenable/get:method"}}get(){{/crossLink}}` is used.
         * - __to__ (_Object=_): Ending position.
         * - __duration__ (_number=_): How many milliseconds to animate for.
         * - __delay__ (_delay=_): How many milliseconds to wait before starting the
         *   tween.
         * - __start__ (_Function(Object, *)_): Function to execute when the tween
         *   begins.  Receives the state of the tween as the first parameter and
         *   `attachment` as the second parameter.
         * - __step__ (_Function(Object, *, number)_): Function to execute on every
         *   tick.  Receives `{{#crossLink
         *   "Tweenable/get:method"}}get(){{/crossLink}}` as the first parameter,
         *   `attachment` as the second parameter, and the time elapsed since the
         *   start of the tween as the third. This function is not called on the
         *   final step of the animation, but `finish` is.
         * - __finish__ (_Function(Object, *)_): Function to execute upon tween
         *   completion.  Receives the state of the tween as the first parameter and
         *   `attachment` as the second parameter.
         * - __easing__ (_Object|string=_): Easing curve name(s) to use for the
         *   tween.
         * - __attachment__ (_*_): Cached value that is passed to the
         *   `step`/`start`/`finish` methods.
         * @chainable
         */
        Tweenable.prototype.setConfig = function(config) {
            config = config || {};
            this._configured = true;

            // Attach something to this Tweenable instance (e.g.: a DOM element, an
            // object, a string, etc.);
            this._attachment = config.attachment;

            // Init the internal state
            this._pausedAtTime = null;
            this._scheduleId = null;
            this._delay = config.delay || 0;
            this._start = config.start || noop;
            this._step = config.step || noop;
            this._finish = config.finish || noop;
            this._duration = config.duration || DEFAULT_DURATION;
            this._currentState = shallowCopy({}, config.from) || this.get();
            this._originalState = this.get();
            this._targetState = shallowCopy({}, config.to) || this.get();

            var self = this;
            this._timeoutHandler = function() {
                timeoutHandler(self,
                    self._timestamp,
                    self._delay,
                    self._duration,
                    self._currentState,
                    self._originalState,
                    self._targetState,
                    self._easing,
                    self._step,
                    self._scheduleFunction
                );
            };

            // Aliases used below
            var currentState = this._currentState;
            var targetState = this._targetState;

            // Ensure that there is always something to tween to.
            defaults(targetState, currentState);

            this._easing = composeEasingObject(
                currentState, config.easing || DEFAULT_EASING);

            this._filterArgs =
                [currentState, this._originalState, targetState, this._easing];

            applyFilter(this, 'tweenCreated');
            return this;
        };

        /**
         * @method get
         * @return {Object} The current state.
         */
        Tweenable.prototype.get = function() {
            return shallowCopy({}, this._currentState);
        };

        /**
         * @method set
         * @param {Object} state The current state.
         */
        Tweenable.prototype.set = function(state) {
            this._currentState = state;
        };

        /**
         * Pause a tween.  Paused tweens can be resumed from the point at which they
         * were paused.  This is different from `{{#crossLink
         * "Tweenable/stop:method"}}{{/crossLink}}`, as that method
         * causes a tween to start over when it is resumed.
         * @method pause
         * @chainable
         */
        Tweenable.prototype.pause = function() {
            this._pausedAtTime = now();
            this._isPaused = true;
            return this;
        };

        /**
         * Resume a paused tween.
         * @method resume
         * @chainable
         */
        Tweenable.prototype.resume = function() {
            if (this._isPaused) {
                this._timestamp += now() - this._pausedAtTime;
            }

            this._isPaused = false;
            this._isTweening = true;

            this._timeoutHandler();

            return this;
        };

        /**
         * Move the state of the animation to a specific point in the tween's
         * timeline.  If the animation is not running, this will cause the `step`
         * handlers to be called.
         * @method seek
         * @param {millisecond} millisecond The millisecond of the animation to seek
         * to.  This must not be less than `0`.
         * @chainable
         */
        Tweenable.prototype.seek = function(millisecond) {
            millisecond = Math.max(millisecond, 0);
            var currentTime = now();

            if ((this._timestamp + millisecond) === 0) {
                return this;
            }

            this._timestamp = currentTime - millisecond;

            if (!this.isPlaying()) {
                this._isTweening = true;
                this._isPaused = false;

                // If the animation is not running, call timeoutHandler to make sure that
                // any step handlers are run.
                timeoutHandler(this,
                    this._timestamp,
                    this._duration,
                    this._delay,
                    this._currentState,
                    this._originalState,
                    this._targetState,
                    this._easing,
                    this._step,
                    this._scheduleFunction,
                    currentTime
                );

                this.pause();
            }

            return this;
        };

        /**
         * Stops and cancels a tween.
         * @param {boolean=} gotoEnd If `false` or omitted, the tween just stops at
         * its current state, and the `finish` handler is not invoked.  If `true`,
         * the tweened object's values are instantly set to the target values, and
         * `finish` is invoked.
         * @method stop
         * @chainable
         */
        Tweenable.prototype.stop = function(gotoEnd) {
            this._isTweening = false;
            this._isPaused = false;
            this._timeoutHandler = noop;

            (root.cancelAnimationFrame ||
                root.webkitCancelAnimationFrame ||
                root.oCancelAnimationFrame ||
                root.msCancelAnimationFrame ||
                root.mozCancelRequestAnimationFrame ||
                root.clearTimeout)(this._scheduleId);

            if (gotoEnd) {
                shallowCopy(this._currentState, this._targetState);
                applyFilter(this, 'afterTweenEnd');
                this._finish.call(this, this._currentState, this._attachment);
            }

            return this;
        };

        /**
         * @method isPlaying
         * @return {boolean} Whether or not a tween is running.
         */
        Tweenable.prototype.isPlaying = function() {
            return this._isTweening && !this._isPaused;
        };

        /**
         * Set a custom schedule function.
         *
         * If a custom function is not set,
         * [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame)
         * is used if available, otherwise
         * [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout)
         * is used.
         * @method setScheduleFunction
         * @param {Function(Function,number)} scheduleFunction The function to be
         * used to schedule the next frame to be rendered.
         */
        Tweenable.prototype.setScheduleFunction = function(scheduleFunction) {
            this._scheduleFunction = scheduleFunction;
        };

        /**
         * `delete` all "own" properties.  Call this when the `Tweenable` instance
         * is no longer needed to free memory.
         * @method dispose
         */
        Tweenable.prototype.dispose = function() {
            var prop;
            for (prop in this) {
                if (this.hasOwnProperty(prop)) {
                    delete this[prop];
                }
            }
        };

        /*!
         * Filters are used for transforming the properties of a tween at various
         * points in a Tweenable's life cycle.  See the README for more info on this.
         */
        Tweenable.prototype.filter = {};

        /**
         * This object contains all of the tweens available to Shifty.  It is
         * extensible - simply attach properties to the `Tweenable.prototype.formula`
         * Object following the same format as `linear`.
         *
         * `pos` should be a normalized `number` (between 0 and 1).
         * @property formula
         * @type {Object(function)}
         */
        Tweenable.prototype.formula = {
            linear: function(pos) {
                return pos;
            }
        };

        formula = Tweenable.prototype.formula;

        shallowCopy(Tweenable, {
            'now': now,
            'each': each,
            'tweenProps': tweenProps,
            'tweenProp': tweenProp,
            'applyFilter': applyFilter,
            'shallowCopy': shallowCopy,
            'defaults': defaults,
            'composeEasingObject': composeEasingObject
        });

        // `root` is provided in the intro/outro files.

        // A hook used for unit testing.
        if (typeof SHIFTY_DEBUG_NOW === 'function') {
            root.timeoutHandler = timeoutHandler;
        }

        // Bootstrap Tweenable appropriately for the environment.
        if (typeof exports === 'object') {
            // CommonJS
            module.exports = Tweenable;
        } else if (typeof define === 'function' && define.amd) {
            // AMD
            define('shifty',[],function() {
                return Tweenable;
            });
        } else if (typeof root.Tweenable === 'undefined') {
            // Browser: Make `Tweenable` globally accessible.
            root.Tweenable = Tweenable;
        }

        return Tweenable;

    }());

    /*!
     * All equations are adapted from Thomas Fuchs'
     * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
     *
     * Based on Easing Equations (c) 2003 [Robert
     * Penner](http://www.robertpenner.com/), all rights reserved. This work is
     * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
     */

    /*!
     *  TERMS OF USE - EASING EQUATIONS
     *  Open source under the BSD License.
     *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
     */

    ;
    (function() {

        Tweenable.shallowCopy(Tweenable.prototype.formula, {
            easeInQuad: function(pos) {
                return Math.pow(pos, 2);
            },

            easeOutQuad: function(pos) {
                return -(Math.pow((pos - 1), 2) - 1);
            },

            easeInOutQuad: function(pos) {
                if ((pos /= 0.5) < 1) {
                    return 0.5 * Math.pow(pos, 2);
                }
                return -0.5 * ((pos -= 2) * pos - 2);
            },

            easeInCubic: function(pos) {
                return Math.pow(pos, 3);
            },

            easeOutCubic: function(pos) {
                return (Math.pow((pos - 1), 3) + 1);
            },

            easeInOutCubic: function(pos) {
                if ((pos /= 0.5) < 1) {
                    return 0.5 * Math.pow(pos, 3);
                }
                return 0.5 * (Math.pow((pos - 2), 3) + 2);
            },

            easeInQuart: function(pos) {
                return Math.pow(pos, 4);
            },

            easeOutQuart: function(pos) {
                return -(Math.pow((pos - 1), 4) - 1);
            },

            easeInOutQuart: function(pos) {
                if ((pos /= 0.5) < 1) {
                    return 0.5 * Math.pow(pos, 4);
                }
                return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
            },

            easeInQuint: function(pos) {
                return Math.pow(pos, 5);
            },

            easeOutQuint: function(pos) {
                return (Math.pow((pos - 1), 5) + 1);
            },

            easeInOutQuint: function(pos) {
                if ((pos /= 0.5) < 1) {
                    return 0.5 * Math.pow(pos, 5);
                }
                return 0.5 * (Math.pow((pos - 2), 5) + 2);
            },

            easeInSine: function(pos) {
                return -Math.cos(pos * (Math.PI / 2)) + 1;
            },

            easeOutSine: function(pos) {
                return Math.sin(pos * (Math.PI / 2));
            },

            easeInOutSine: function(pos) {
                return (-0.5 * (Math.cos(Math.PI * pos) - 1));
            },

            easeInExpo: function(pos) {
                return (pos === 0) ? 0 : Math.pow(2, 10 * (pos - 1));
            },

            easeOutExpo: function(pos) {
                return (pos === 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
            },

            easeInOutExpo: function(pos) {
                if (pos === 0) {
                    return 0;
                }
                if (pos === 1) {
                    return 1;
                }
                if ((pos /= 0.5) < 1) {
                    return 0.5 * Math.pow(2, 10 * (pos - 1));
                }
                return 0.5 * (-Math.pow(2, -10 * --pos) + 2);
            },

            easeInCirc: function(pos) {
                return -(Math.sqrt(1 - (pos * pos)) - 1);
            },

            easeOutCirc: function(pos) {
                return Math.sqrt(1 - Math.pow((pos - 1), 2));
            },

            easeInOutCirc: function(pos) {
                if ((pos /= 0.5) < 1) {
                    return -0.5 * (Math.sqrt(1 - pos * pos) - 1);
                }
                return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
            },

            easeOutBounce: function(pos) {
                if ((pos) < (1 / 2.75)) {
                    return (7.5625 * pos * pos);
                } else if (pos < (2 / 2.75)) {
                    return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
                } else if (pos < (2.5 / 2.75)) {
                    return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
                } else {
                    return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
                }
            },

            easeInBack: function(pos) {
                var s = 1.70158;
                return (pos) * pos * ((s + 1) * pos - s);
            },

            easeOutBack: function(pos) {
                var s = 1.70158;
                return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
            },

            easeInOutBack: function(pos) {
                var s = 1.70158;
                if ((pos /= 0.5) < 1) {
                    return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));
                }
                return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
            },

            elastic: function(pos) {
                // jshint maxlen:90
                return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
            },

            swingFromTo: function(pos) {
                var s = 1.70158;
                return ((pos /= 0.5) < 1) ?
                    0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) :
                    0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
            },

            swingFrom: function(pos) {
                var s = 1.70158;
                return pos * pos * ((s + 1) * pos - s);
            },

            swingTo: function(pos) {
                var s = 1.70158;
                return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
            },

            bounce: function(pos) {
                if (pos < (1 / 2.75)) {
                    return (7.5625 * pos * pos);
                } else if (pos < (2 / 2.75)) {
                    return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
                } else if (pos < (2.5 / 2.75)) {
                    return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
                } else {
                    return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
                }
            },

            bouncePast: function(pos) {
                if (pos < (1 / 2.75)) {
                    return (7.5625 * pos * pos);
                } else if (pos < (2 / 2.75)) {
                    return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
                } else if (pos < (2.5 / 2.75)) {
                    return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
                } else {
                    return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
                }
            },

            easeFromTo: function(pos) {
                if ((pos /= 0.5) < 1) {
                    return 0.5 * Math.pow(pos, 4);
                }
                return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
            },

            easeFrom: function(pos) {
                return Math.pow(pos, 4);
            },

            easeTo: function(pos) {
                return Math.pow(pos, 0.25);
            }
        });

    }());

    // jshint maxlen:100
    /*!
     * The Bezier magic in this file is adapted/copied almost wholesale from
     * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/cubic-bezier.js),
     * which was adapted from Apple code (which probably came from
     * [here](http://opensource.apple.com/source/WebCore/WebCore-955.66/platform/graphics/UnitBezier.h)).
     * Special thanks to Apple and Thomas Fuchs for much of this code.
     */

    /*!
     *  Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
     *
     *  Redistribution and use in source and binary forms, with or without
     *  modification, are permitted provided that the following conditions are met:
     *
     *  1. Redistributions of source code must retain the above copyright notice,
     *  this list of conditions and the following disclaimer.
     *
     *  2. Redistributions in binary form must reproduce the above copyright notice,
     *  this list of conditions and the following disclaimer in the documentation
     *  and/or other materials provided with the distribution.
     *
     *  3. Neither the name of the copyright holder(s) nor the names of any
     *  contributors may be used to endorse or promote products derived from
     *  this software without specific prior written permission.
     *
     *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
     *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     *  POSSIBILITY OF SUCH DAMAGE.
     */
    ;
    (function() {
        // port of webkit cubic bezier handling by http://www.netzgesta.de/dev/
        function cubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
            var ax = 0,
                bx = 0,
                cx = 0,
                ay = 0,
                by = 0,
                cy = 0;

            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx) * t;
            }

            function sampleCurveY(t) {
                return ((ay * t + by) * t + cy) * t;
            }

            function sampleCurveDerivativeX(t) {
                return (3.0 * ax * t + 2.0 * bx) * t + cx;
            }

            function solveEpsilon(duration) {
                return 1.0 / (200.0 * duration);
            }

            function solve(x, epsilon) {
                return sampleCurveY(solveCurveX(x, epsilon));
            }

            function fabs(n) {
                if (n >= 0) {
                    return n;
                } else {
                    return 0 - n;
                }
            }

            function solveCurveX(x, epsilon) {
                var t0, t1, t2, x2, d2, i;
                for (t2 = x, i = 0; i < 8; i++) {
                    x2 = sampleCurveX(t2) - x;
                    if (fabs(x2) < epsilon) {
                        return t2;
                    }
                    d2 = sampleCurveDerivativeX(t2);
                    if (fabs(d2) < 1e-6) {
                        break;
                    }
                    t2 = t2 - x2 / d2;
                }
                t0 = 0.0;
                t1 = 1.0;
                t2 = x;
                if (t2 < t0) {
                    return t0;
                }
                if (t2 > t1) {
                    return t1;
                }
                while (t0 < t1) {
                    x2 = sampleCurveX(t2);
                    if (fabs(x2 - x) < epsilon) {
                        return t2;
                    }
                    if (x > x2) {
                        t0 = t2;
                    } else {
                        t1 = t2;
                    }
                    t2 = (t1 - t0) * 0.5 + t0;
                }
                return t2; // Failure.
            }
            cx = 3.0 * p1x;
            bx = 3.0 * (p2x - p1x) - cx;
            ax = 1.0 - cx - bx;
            cy = 3.0 * p1y;
            by = 3.0 * (p2y - p1y) - cy;
            ay = 1.0 - cy - by;
            return solve(t, solveEpsilon(duration));
        }
        /*!
         *  getCubicBezierTransition(x1, y1, x2, y2) -> Function
         *
         *  Generates a transition easing function that is compatible
         *  with WebKit's CSS transitions `-webkit-transition-timing-function`
         *  CSS property.
         *
         *  The W3C has more information about CSS3 transition timing functions:
         *  http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
         *
         *  @param {number} x1
         *  @param {number} y1
         *  @param {number} x2
         *  @param {number} y2
         *  @return {function}
         */
        function getCubicBezierTransition(x1, y1, x2, y2) {
            return function(pos) {
                return cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
            };
        }
        // End ported code

        /**
         * Create a Bezier easing function and attach it to `{{#crossLink
         * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  This
         * function gives you total control over the easing curve.  Matthew Lein's
         * [Ceaser](http://matthewlein.com/ceaser/) is a useful tool for visualizing
         * the curves you can make with this function.
         * @method setBezierFunction
         * @param {string} name The name of the easing curve.  Overwrites the old
         * easing function on `{{#crossLink
         * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}` if it
         * exists.
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @return {function} The easing function that was attached to
         * Tweenable.prototype.formula.
         */
        Tweenable.setBezierFunction = function(name, x1, y1, x2, y2) {
            var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
            cubicBezierTransition.displayName = name;
            cubicBezierTransition.x1 = x1;
            cubicBezierTransition.y1 = y1;
            cubicBezierTransition.x2 = x2;
            cubicBezierTransition.y2 = y2;

            return Tweenable.prototype.formula[name] = cubicBezierTransition;
        };


        /**
         * `delete` an easing function from `{{#crossLink
         * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  Be
         * careful with this method, as it `delete`s whatever easing formula matches
         * `name` (which means you can delete standard Shifty easing functions).
         * @method unsetBezierFunction
         * @param {string} name The name of the easing function to delete.
         * @return {function}
         */
        Tweenable.unsetBezierFunction = function(name) {
            delete Tweenable.prototype.formula[name];
        };

    })();

    ;
    (function() {

        function getInterpolatedValues(
            from, current, targetState, position, easing, delay) {
            return Tweenable.tweenProps(
                position, current, from, targetState, 1, delay, easing);
        }

        // Fake a Tweenable and patch some internals.  This approach allows us to
        // skip uneccessary processing and object recreation, cutting down on garbage
        // collection pauses.
        var mockTweenable = new Tweenable();
        mockTweenable._filterArgs = [];

        /**
         * Compute the midpoint of two Objects.  This method effectively calculates a
         * specific frame of animation that `{{#crossLink
         * "Tweenable/tween:method"}}{{/crossLink}}` does many times over the course
         * of a full tween.
         *
         *     var interpolatedValues = Tweenable.interpolate({
         *       width: '100px',
         *       opacity: 0,
         *       color: '#fff'
         *     }, {
         *       width: '200px',
         *       opacity: 1,
         *       color: '#000'
         *     }, 0.5);
         *
         *     console.log(interpolatedValues);
         *     // {opacity: 0.5, width: "150px", color: "rgb(127,127,127)"}
         *
         * @static
         * @method interpolate
         * @param {Object} from The starting values to tween from.
         * @param {Object} targetState The ending values to tween to.
         * @param {number} position The normalized position value (between `0.0` and
         * `1.0`) to interpolate the values between `from` and `to` for.  `from`
         * represents `0` and `to` represents `1`.
         * @param {string|Object} easing The easing curve(s) to calculate the
         * midpoint against.  You can reference any easing function attached to
         * `Tweenable.prototype.formula`.  If omitted, this defaults to "linear".
         * @param {number=} opt_delay Optional delay to pad the beginning of the
         * interpolated tween with.  This increases the range of `position` from (`0`
         * through `1`) to (`0` through `1 + opt_delay`).  So, a delay of `0.5` would
         * increase all valid values of `position` to numbers between `0` and `1.5`.
         * @return {Object}
         */
        Tweenable.interpolate = function(
            from, targetState, position, easing, opt_delay) {

            var current = Tweenable.shallowCopy({}, from);
            var delay = opt_delay || 0;
            var easingObject = Tweenable.composeEasingObject(
                from, easing || 'linear');

            mockTweenable.set({});

            // Alias and reuse the _filterArgs array instead of recreating it.
            var filterArgs = mockTweenable._filterArgs;
            filterArgs.length = 0;
            filterArgs[0] = current;
            filterArgs[1] = from;
            filterArgs[2] = targetState;
            filterArgs[3] = easingObject;

            // Any defined value transformation must be applied
            Tweenable.applyFilter(mockTweenable, 'tweenCreated');
            Tweenable.applyFilter(mockTweenable, 'beforeTween');

            var interpolatedValues = getInterpolatedValues(
                from, current, targetState, position, easingObject, delay);

            // Transform values back into their original format
            Tweenable.applyFilter(mockTweenable, 'afterTween');

            return interpolatedValues;
        };

    }());

    /**
     * This module adds string interpolation support to Shifty.
     *
     * The Token extension allows Shifty to tween numbers inside of strings.  Among
     * other things, this allows you to animate CSS properties.  For example, you
     * can do this:
     *
     *     var tweenable = new Tweenable();
     *     tweenable.tween({
     *       from: { transform: 'translateX(45px)' },
     *       to: { transform: 'translateX(90xp)' }
     *     });
     *
     * `translateX(45)` will be tweened to `translateX(90)`.  To demonstrate:
     *
     *     var tweenable = new Tweenable();
     *     tweenable.tween({
     *       from: { transform: 'translateX(45px)' },
     *       to: { transform: 'translateX(90px)' },
     *       step: function (state) {
     *         console.log(state.transform);
     *       }
     *     });
     *
     * The above snippet will log something like this in the console:
     *
     *     translateX(60.3px)
     *     ...
     *     translateX(76.05px)
     *     ...
     *     translateX(90px)
     *
     * Another use for this is animating colors:
     *
     *     var tweenable = new Tweenable();
     *     tweenable.tween({
     *       from: { color: 'rgb(0,255,0)' },
     *       to: { color: 'rgb(255,0,255)' },
     *       step: function (state) {
     *         console.log(state.color);
     *       }
     *     });
     *
     * The above snippet will log something like this:
     *
     *     rgb(84,170,84)
     *     ...
     *     rgb(170,84,170)
     *     ...
     *     rgb(255,0,255)
     *
     * This extension also supports hexadecimal colors, in both long (`#ff00ff`)
     * and short (`#f0f`) forms.  Be aware that hexadecimal input values will be
     * converted into the equivalent RGB output values.  This is done to optimize
     * for performance.
     *
     *     var tweenable = new Tweenable();
     *     tweenable.tween({
     *       from: { color: '#0f0' },
     *       to: { color: '#f0f' },
     *       step: function (state) {
     *         console.log(state.color);
     *       }
     *     });
     *
     * This snippet will generate the same output as the one before it because
     * equivalent values were supplied (just in hexadecimal form rather than RGB):
     *
     *     rgb(84,170,84)
     *     ...
     *     rgb(170,84,170)
     *     ...
     *     rgb(255,0,255)
     *
     * ## Easing support
     *
     * Easing works somewhat differently in the Token extension.  This is because
     * some CSS properties have multiple values in them, and you might need to
     * tween each value along its own easing curve.  A basic example:
     *
     *     var tweenable = new Tweenable();
     *     tweenable.tween({
     *       from: { transform: 'translateX(0px) translateY(0px)' },
     *       to: { transform:   'translateX(100px) translateY(100px)' },
     *       easing: { transform: 'easeInQuad' },
     *       step: function (state) {
     *         console.log(state.transform);
     *       }
     *     });
     *
     * The above snippet will create values like this:
     *
     *     translateX(11.56px) translateY(11.56px)
     *     ...
     *     translateX(46.24px) translateY(46.24px)
     *     ...
     *     translateX(100px) translateY(100px)
     *
     * In this case, the values for `translateX` and `translateY` are always the
     * same for each step of the tween, because they have the same start and end
     * points and both use the same easing curve.  We can also tween `translateX`
     * and `translateY` along independent curves:
     *
     *     var tweenable = new Tweenable();
     *     tweenable.tween({
     *       from: { transform: 'translateX(0px) translateY(0px)' },
     *       to: { transform:   'translateX(100px) translateY(100px)' },
     *       easing: { transform: 'easeInQuad bounce' },
     *       step: function (state) {
     *         console.log(state.transform);
     *       }
     *     });
     *
     * The above snippet will create values like this:
     *
     *     translateX(10.89px) translateY(82.35px)
     *     ...
     *     translateX(44.89px) translateY(86.73px)
     *     ...
     *     translateX(100px) translateY(100px)
     *
     * `translateX` and `translateY` are not in sync anymore, because `easeInQuad`
     * was specified for `translateX` and `bounce` for `translateY`.  Mixing and
     * matching easing curves can make for some interesting motion in your
     * animations.
     *
     * The order of the space-separated easing curves correspond the token values
     * they apply to.  If there are more token values than easing curves listed,
     * the last easing curve listed is used.
     * @submodule Tweenable.token
     */

    // token function is defined above only so that dox-foundation sees it as
    // documentation and renders it.  It is never used, and is optimized away at
    // build time.

    ;
    (function(Tweenable) {

        /*!
         * @typedef {{
         *   formatString: string
         *   chunkNames: Array.<string>
         * }}
         */
        var formatManifest;

        // CONSTANTS

        var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
        var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
        var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
        var R_RGB = new RegExp(
            'rgb\\(' + R_UNFORMATTED_VALUES.source +
            (/,\s*/.source) + R_UNFORMATTED_VALUES.source +
            (/,\s*/.source) + R_UNFORMATTED_VALUES.source + '\\)', 'g');
        var R_RGB_PREFIX = /^.*\(/;
        var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
        var VALUE_PLACEHOLDER = 'VAL';

        // HELPERS

        /*!
         * @param {Array.number} rawValues
         * @param {string} prefix
         *
         * @return {Array.<string>}
         */
        function getFormatChunksFrom(rawValues, prefix) {
            var accumulator = [];

            var rawValuesLength = rawValues.length;
            var i;

            for (i = 0; i < rawValuesLength; i++) {
                accumulator.push('_' + prefix + '_' + i);
            }

            return accumulator;
        }

        /*!
         * @param {string} formattedString
         *
         * @return {string}
         */
        function getFormatStringFrom(formattedString) {
            var chunks = formattedString.match(R_FORMAT_CHUNKS);

            if (!chunks) {
                // chunks will be null if there were no tokens to parse in
                // formattedString (for example, if formattedString is '2').  Coerce
                // chunks to be useful here.
                chunks = ['', ''];

                // If there is only one chunk, assume that the string is a number
                // followed by a token...
                // NOTE: This may be an unwise assumption.
            } else if (chunks.length === 1 ||
                // ...or if the string starts with a number component (".", "-", or a
                // digit)...
                formattedString[0].match(R_NUMBER_COMPONENT)) {
                // ...prepend an empty string here to make sure that the formatted number
                // is properly replaced by VALUE_PLACEHOLDER
                chunks.unshift('');
            }

            return chunks.join(VALUE_PLACEHOLDER);
        }

        /*!
         * Convert all hex color values within a string to an rgb string.
         *
         * @param {Object} stateObject
         *
         * @return {Object} The modified obj
         */
        function sanitizeObjectForHexProps(stateObject) {
            Tweenable.each(stateObject, function(prop) {
                var currentProp = stateObject[prop];

                if (typeof currentProp === 'string' && currentProp.match(R_HEX)) {
                    stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
                }
            });
        }

        /*!
         * @param {string} str
         *
         * @return {string}
         */
        function sanitizeHexChunksToRGB(str) {
            return filterStringChunks(R_HEX, str, convertHexToRGB);
        }

        /*!
         * @param {string} hexString
         *
         * @return {string}
         */
        function convertHexToRGB(hexString) {
            var rgbArr = hexToRGBArray(hexString);
            return 'rgb(' + rgbArr[0] + ',' + rgbArr[1] + ',' + rgbArr[2] + ')';
        }

        var hexToRGBArray_returnArray = [];
        /*!
         * Convert a hexadecimal string to an array with three items, one each for
         * the red, blue, and green decimal values.
         *
         * @param {string} hex A hexadecimal string.
         *
         * @returns {Array.<number>} The converted Array of RGB values if `hex` is a
         * valid string, or an Array of three 0's.
         */
        function hexToRGBArray(hex) {

            hex = hex.replace(/#/, '');

            // If the string is a shorthand three digit hex notation, normalize it to
            // the standard six digit notation
            if (hex.length === 3) {
                hex = hex.split('');
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }

            hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
            hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
            hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));

            return hexToRGBArray_returnArray;
        }

        /*!
         * Convert a base-16 number to base-10.
         *
         * @param {Number|String} hex The value to convert
         *
         * @returns {Number} The base-10 equivalent of `hex`.
         */
        function hexToDec(hex) {
            return parseInt(hex, 16);
        }

        /*!
         * Runs a filter operation on all chunks of a string that match a RegExp
         *
         * @param {RegExp} pattern
         * @param {string} unfilteredString
         * @param {function(string)} filter
         *
         * @return {string}
         */
        function filterStringChunks(pattern, unfilteredString, filter) {
            var pattenMatches = unfilteredString.match(pattern);
            var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);

            if (pattenMatches) {
                var pattenMatchesLength = pattenMatches.length;
                var currentChunk;

                for (var i = 0; i < pattenMatchesLength; i++) {
                    currentChunk = pattenMatches.shift();
                    filteredString = filteredString.replace(
                        VALUE_PLACEHOLDER, filter(currentChunk));
                }
            }

            return filteredString;
        }

        /*!
         * Check for floating point values within rgb strings and rounds them.
         *
         * @param {string} formattedString
         *
         * @return {string}
         */
        function sanitizeRGBChunks(formattedString) {
            return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
        }

        /*!
         * @param {string} rgbChunk
         *
         * @return {string}
         */
        function sanitizeRGBChunk(rgbChunk) {
            var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
            var numbersLength = numbers.length;
            var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];

            for (var i = 0; i < numbersLength; i++) {
                sanitizedString += parseInt(numbers[i], 10) + ',';
            }

            sanitizedString = sanitizedString.slice(0, -1) + ')';

            return sanitizedString;
        }

        /*!
         * @param {Object} stateObject
         *
         * @return {Object} An Object of formatManifests that correspond to
         * the string properties of stateObject
         */
        function getFormatManifests(stateObject) {
            var manifestAccumulator = {};

            Tweenable.each(stateObject, function(prop) {
                var currentProp = stateObject[prop];

                if (typeof currentProp === 'string') {
                    var rawValues = getValuesFrom(currentProp);

                    manifestAccumulator[prop] = {
                        'formatString': getFormatStringFrom(currentProp),
                        'chunkNames': getFormatChunksFrom(rawValues, prop)
                    };
                }
            });

            return manifestAccumulator;
        }

        /*!
         * @param {Object} stateObject
         * @param {Object} formatManifests
         */
        function expandFormattedProperties(stateObject, formatManifests) {
            Tweenable.each(formatManifests, function(prop) {
                var currentProp = stateObject[prop];
                var rawValues = getValuesFrom(currentProp);
                var rawValuesLength = rawValues.length;

                for (var i = 0; i < rawValuesLength; i++) {
                    stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
                }

                delete stateObject[prop];
            });
        }

        /*!
         * @param {Object} stateObject
         * @param {Object} formatManifests
         */
        function collapseFormattedProperties(stateObject, formatManifests) {
            Tweenable.each(formatManifests, function(prop) {
                var currentProp = stateObject[prop];
                var formatChunks = extractPropertyChunks(
                    stateObject, formatManifests[prop].chunkNames);
                var valuesList = getValuesList(
                    formatChunks, formatManifests[prop].chunkNames);
                currentProp = getFormattedValues(
                    formatManifests[prop].formatString, valuesList);
                stateObject[prop] = sanitizeRGBChunks(currentProp);
            });
        }

        /*!
         * @param {Object} stateObject
         * @param {Array.<string>} chunkNames
         *
         * @return {Object} The extracted value chunks.
         */
        function extractPropertyChunks(stateObject, chunkNames) {
            var extractedValues = {};
            var currentChunkName, chunkNamesLength = chunkNames.length;

            for (var i = 0; i < chunkNamesLength; i++) {
                currentChunkName = chunkNames[i];
                extractedValues[currentChunkName] = stateObject[currentChunkName];
                delete stateObject[currentChunkName];
            }

            return extractedValues;
        }

        var getValuesList_accumulator = [];
        /*!
         * @param {Object} stateObject
         * @param {Array.<string>} chunkNames
         *
         * @return {Array.<number>}
         */
        function getValuesList(stateObject, chunkNames) {
            getValuesList_accumulator.length = 0;
            var chunkNamesLength = chunkNames.length;

            for (var i = 0; i < chunkNamesLength; i++) {
                getValuesList_accumulator.push(stateObject[chunkNames[i]]);
            }

            return getValuesList_accumulator;
        }

        /*!
         * @param {string} formatString
         * @param {Array.<number>} rawValues
         *
         * @return {string}
         */
        function getFormattedValues(formatString, rawValues) {
            var formattedValueString = formatString;
            var rawValuesLength = rawValues.length;

            for (var i = 0; i < rawValuesLength; i++) {
                formattedValueString = formattedValueString.replace(
                    VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
            }

            return formattedValueString;
        }

        /*!
         * Note: It's the duty of the caller to convert the Array elements of the
         * return value into numbers.  This is a performance optimization.
         *
         * @param {string} formattedString
         *
         * @return {Array.<string>|null}
         */
        function getValuesFrom(formattedString) {
            return formattedString.match(R_UNFORMATTED_VALUES);
        }

        /*!
         * @param {Object} easingObject
         * @param {Object} tokenData
         */
        function expandEasingObject(easingObject, tokenData) {
            Tweenable.each(tokenData, function(prop) {
                var currentProp = tokenData[prop];
                var chunkNames = currentProp.chunkNames;
                var chunkLength = chunkNames.length;
                var easingChunks = easingObject[prop].split(' ');
                var lastEasingChunk = easingChunks[easingChunks.length - 1];

                for (var i = 0; i < chunkLength; i++) {
                    easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
                }

                delete easingObject[prop];
            });
        }

        /*!
         * @param {Object} easingObject
         * @param {Object} tokenData
         */
        function collapseEasingObject(easingObject, tokenData) {
            Tweenable.each(tokenData, function(prop) {
                var currentProp = tokenData[prop];
                var chunkNames = currentProp.chunkNames;
                var chunkLength = chunkNames.length;
                var composedEasingString = '';

                for (var i = 0; i < chunkLength; i++) {
                    composedEasingString += ' ' + easingObject[chunkNames[i]];
                    delete easingObject[chunkNames[i]];
                }

                easingObject[prop] = composedEasingString.substr(1);
            });
        }

        Tweenable.prototype.filter.token = {
            'tweenCreated': function(currentState, fromState, toState, easingObject) {
                sanitizeObjectForHexProps(currentState);
                sanitizeObjectForHexProps(fromState);
                sanitizeObjectForHexProps(toState);
                this._tokenData = getFormatManifests(currentState);
            },

            'beforeTween': function(currentState, fromState, toState, easingObject) {
                expandEasingObject(easingObject, this._tokenData);
                expandFormattedProperties(currentState, this._tokenData);
                expandFormattedProperties(fromState, this._tokenData);
                expandFormattedProperties(toState, this._tokenData);
            },

            'afterTween': function(currentState, fromState, toState, easingObject) {
                collapseFormattedProperties(currentState, this._tokenData);
                collapseFormattedProperties(fromState, this._tokenData);
                collapseFormattedProperties(toState, this._tokenData);
                collapseEasingObject(easingObject, this._tokenData);
            }
        };

    }(Tweenable));

}).call(null);
define('extensions/ui/accordion2', ['backbone', 'shifty'], function(Backbone, Tweenable) {

    'use strict';

    var openObj, preventTwoDrawers = false;

    var Accordion = Backbone.View.extend({
        stopControl: function() {
            if(this.$drawer.hasClass('open') && !(this.$ul.children().length > 0 || this.$openUl.children().length > 1)){
                this.isForcedOpen = true;
            }
            this.close(null, true);
            this.isStopped = true;
        },
        startControl: function() {
            this.isStopped = false;
            if(this.isForcedOpen){
                this.$(".drawerArrow").hide();
                this.open();
            }
        },
        initialize: function(options) {
            var self = this;
            _.bindAll(this);
            options = options || {};

            this.moveTime = 400;
            this.peekabooTime = 200;

            this.isOpenFromPeekaboo = false;

            if (!options.target) {
                options.target = this.$('.description');
            }

            if (!options.view) {
                throw ('you need to pass the view');
            } else {
                this.view = options.view;
            }

            this.throttledMethod = _.throttle(this.toggle, 1000, {
                trailing: false
            });

            if (options.target) {
                options.target.addClass('target');
                options.target.hammer().on('tap', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    self.throttledMethod.apply(this, arguments);
                });
            }

            this.$drawer = this.view.parentView.$drawerParentView;
            this.$parent = this.$el.parent();

            //if this is a group
            if (this.$parent.hasClass('isGroupMember')) {
                this.$parent = this.$parent.parent();
            }

            this.$ul = this.$parent.parent();
            this.$container = $('#mainContainer');
            this.$scrollWrapper = $("#controller > .widget");
            this.$base = $('.device_list_content');

            this.calculate();

            //put it back to hidden
            this.$drawer[0].style.webkitTransition = 'none';
            this.$drawer[0].style.webkitTransform = 'translate3d(-100%,0,0)';


            setTimeout(function(){
                if(self.$ul.children().length === 1 && !($('.openAccordion').children().length > 0)){
                    self.$btnEl = self.$('.description');
                    self.open();
                }
            }, 100);
        },

        toggle: function(e, tappedPowerBtn) {
            if (typeof tappedPowerBtn === "undefined") {
                tappedPowerBtn = false;
            }
            if (!this.isStopped && !this.isAnimating) {
                //check if there is another peekaboo drawer open, if yes, close it.
                this.checkForOpen();
                //first we need to see if any other drawers are open. we'll just close them up quick.
                this.$btnEl = $(e.currentTarget);
                this.isAnimating = true;

                //tappedPowerBtn: 1 control peekaboo drawer, 0 represent control full drawer
                if (this.$drawer.hasClass('open')) {
                    if (!tappedPowerBtn && this.$drawer.hasClass('isPeekaboo')) {
                        //when peekaboo drawer is opened and drawer been tapped
                        this.openFromPeekaboo();
                        this.isOpenFromPeekaboo = true;
                    } else {
                        //close peekaboo drawer or full drawer
                        this.close(tappedPowerBtn);
                    }
                } else {
                    //when user open peekaboo or full drawer.
                    this.open(tappedPowerBtn);
                }

            }
        },

        checkForOpen: function() {
            if (openObj && openObj.$el !== this.$el) {
                var $btn = openObj.$el.find('.description');
                $btn.removeClass('open');
                openObj.$ul.detach();
                openObj.$base.append(this.$ul);

                openObj.removed.reverse();

                _.each(openObj.removed, function(listItem) {
                    var $listItem = $(listItem);
                    $listItem.detach();
                    openObj.$ul.prepend($listItem);
                });

                openObj.$drawer[0].style.webkitTransition = "none";
                openObj.$drawer[0].style.webkitTransform = 'translate3d(-100%,0,0)';

                openObj.$openUl.remove();
                openObj.$drawer.removeClass('open isPeekaboo');
                preventTwoDrawers = false;
            }
        },
        calculate: function() {
            DEBUG && console.log('SYNC: CALCULATING THE DRAWER');
            var self = this;
            if (!this.$drawer) {
                this.$drawer = this.$el.next();
                this.$parent = this.$el.parent();
            }

            this.$arrow = this.$('.drawerArrow');
            this.$('.description').css('height', parseInt(this.$('.tile1').height(), 10));


            /* accurate drawer height is calculated by height of viewport minus height of tile, top bar, and bottom bar(?) */
            if (!this.windowHeight) { //only need to capture these once
                this.footerHeight = 0;
                this.headerHeight = 0;
                this.windowHeight = $(window).height();
                if ($('.main_header').length > 0) {
                    this.$header = $('.main_header');
                }
            }

            this.headerHeight = parseInt(this.$header.outerHeight(true), 10);

            var $footer = $('.footerTabs');

            /** this needs to change if android footer changes **/
            if ($footer.length > 0 && !$("#footerComponent").hasClass('hideForJarden')) {
                this.footerHeight = parseInt($footer.outerHeight(true), 10);
            } else {
                this.footerHeight = 0;
            }

            this.tileHeight = this.$el.outerHeight(true);

            this.drawerHeight = this.windowHeight - this.tileHeight - this.headerHeight - this.footerHeight;

            DEBUG && console.log('ACCORDION:drawer height: ' + this.drawerHeight + 'TILEHEIGHT:' + this.tileHeight);

            this.totalHeight = this.drawerHeight + this.tileHeight;

            if (this.drawerHeight === 0) {
                setTimeout(function() {
                    self.calculate();
                }, 10);
            }
        },

        open: function(tappedPowerBtn) {
            var self = this;
            this.dfd = $.Deferred();
            var isAvailable = (this.$parent.find('.notAvailableBg').length === 0);

            if (!this.isStopped && !preventTwoDrawers && isAvailable) {
                this.calculate();
                openObj = self;

                this.scrollTop = this.$scrollWrapper.scrollTop();

                var index = this.$ul.find('li').index(this.$parent);
                var children = this.$ul.children();
                var ulTop = parseInt(this.$ul.offset().top, 10);

                this.removed = children.splice(0, (index + 1));
                this.$openUl = $('<ul class="openAccordion" />').css({
                    top: ulTop
                });

                var startHeight = 0;
                this.upHeight = 0;

                _.each(this.removed, function(listItem, index) {
                    var $listItem = $(listItem);
                    var elementHeight = parseInt($listItem.outerHeight());
                    startHeight += elementHeight;
                    if (self.removed[index + 1]) {
                        self.upHeight += elementHeight;
                    }
                    $listItem.detach();
                    $listItem.appendTo(self.$openUl);
                });

                var drawerStartBottom = ulTop + startHeight;
                var drawerStartTop = drawerStartBottom - this.drawerHeight;
                this.drawerEndTop = this.drawerHeight - this.upHeight;
                this.tileTop = (index) * 80 + this.tileHeight;

                this.$drawer[0].style.webkitTransition = "none";
                this.$drawer[0].style.webkitTransform = 'translate3d(0,0,0)';

                if(this.$ul.children().length === 0 && this.$openUl.children().length === 1){
                    self.$arrow.hide();
                }

                this.$container.append(this.$openUl);

                this.$ul.detach();
                this.$drawer.append(this.$ul);

                self.view.sandbox.emit('drawer.open');


                self.view.isDrawerOpen = true;
                preventTwoDrawers = true;

                if (tappedPowerBtn) {
                    this.peekHeight = this.$drawer.find(".smart-drawer").outerHeight();

                    if (this.peekHeight < 70) {
                        this.peekHeight = 72;
                    }
                    DEBUG && console.log('ACCORDION:drawer peekDrawerHeight: ' + this.peekHeight + ' TILEHEIGHT:' + self.tileTop + " ULTOP:" + ulTop);
                    this.$drawer.css({
                        top: self.tileTop + ulTop - self.peekHeight
                    }).find('.content').scrollTop(0);

                    this.openPeekAnimation();
                } else {
                    this.$drawer.css({
                        top: drawerStartTop
                    });
                    self.$arrow.addClass('open');
                    self.$btnEl.addClass('open');
                    this.openAnimation();
                }

            } else {
                this.dfd.reject();
            }
            return this.dfd.promise();
        },

        resizeDrawerForBanner: function() {
           if (this.$drawer.hasClass('open')) {
               this.tileHeight = this.$el.outerHeight(true);

               this.drawerHeight = this.windowHeight - this.tileHeight - this.headerHeight - this.footerHeight;

               var drawerTop =  this.tileHeight + this.headerHeight - this.drawerHeight;
               this.$drawer[0].style.webkitTransition = '-webkit-transform';
               this.$drawer[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ this.drawerHeight + ')';

               this.$drawer.css({
                   top: drawerTop
               });
               this.$drawer[0].style.height =  parseInt(this.drawerHeight, 10) + 'px';
           }
        },


        openFromPeekaboo: function() {
            this.$drawer.removeClass('isPeekaboo');
            this.openFromPeekabooAnimation();
            this.$scrollWrapper.scrollTop(0);
        },

        openFromPeekabooAnimation: function() {
            var self = this;
            this.$drawer[0].style.height =  parseInt(this.drawerHeight, 10) + 'px';
            this.$drawer[0].style.webkitTransition = '-webkit-transform';
            this.$openUl[0].style.webkitTransition = '-webkit-transform';

            var openTileAnimationTween = new Tweenable();

            openTileAnimationTween.tween({
                from: {
                    top: -1 * self.moveTop
                },
                to: {
                    top: self.upHeight * -1 + self.scrollTop
                },
                duration: self.moveTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    var top = shifty.top;
                    self.$openUl[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                },
                finish: function() {

                }
            });



            var openFullDrawerAnimationTween = new Tweenable();

            openFullDrawerAnimationTween.tween({
                from: {
                    top: -1 * self.moveTop
                },
                to: {
                    top: self.upHeight * -1 + self.peekHeight + self.scrollTop
                },
                duration: self.moveTime,
                easing: 'easeOutCubic',

                step: function(shifty) {
                    var top = shifty.top;
                    self.$drawer[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                },
                finish: function() {
                    self.isAnimating = false;
                    self.$arrow.addClass('open');
                }
            });
        },

        openAnimation: function() {
            var self = this;
            this.$drawer[0].style.height =  parseInt(this.drawerHeight, 10) + 'px';
            this.$drawer[0].style.webkitTransition = '-webkit-transform';
            this.$openUl[0].style.webkitTransition = '-webkit-transform';


            var openTileAnimationTween = new Tweenable();

            openTileAnimationTween.tween({
                from: {
                    top: 0,
                    scrollTop: self.scrollTop
                },
                to: {
                    top: self.upHeight * -1,
                    scrollTop: 0
                },
                duration: self.moveTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    self.$scrollWrapper.scrollTop(shifty.scrollTop);
                    var top = shifty.top + self.scrollTop;
                    self.$openUl[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                },
                finish: function() {

                }
            });




            var openDrawerAnimationTween = new Tweenable();

            openDrawerAnimationTween.tween({
                from: {
                    top: 0
                },
                to: {
                    top: self.drawerEndTop
                },
                duration: self.moveTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    var top = shifty.top + self.scrollTop;
                    self.$drawer[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                },
                finish: function() {
                    self.$drawer.addClass('open');
                    $("#wemo_devices").hide();
                    self.isAnimating = false;
                    self.view.sandbox.emit('drawer.finishOpen');
                    if (window.devicelistEvents) {
                        window.devicelistEvents.emit('smartDrawer.afterOpen');
                    }
                    var height = parseInt(self.$drawer.css('height'), 10);
                    // this is a hack for a chromium rendering bug. elements disappear without forcing redraw
                    self.$drawer.css('height', (height + 1));
                    setTimeout(function() {
                        self.$drawer.css('height', (height));
                    }, 0);
                    //self.$drawer.css('height', height);
                    self.dfd.resolve();
                }
            });

        },

        openPeekAnimation: function() {
            var self = this;
            this.$drawer[0].style.style = 'auto';
            this.$drawer[0].style.webkitTransition = '-webkit-transform';
            this.$openUl[0].style.webkitTransition = '-webkit-transform';

            var disToBottom = this.windowHeight - parseInt(this.$parent.offset().top + self.tileHeight, 10);
            if (disToBottom < 200) {
                self.moveTop = 140;
                var shiftTilesAnimationTween = new Tweenable();

                shiftTilesAnimationTween.tween({
                    from: {
                        shift : 0
                    },
                    to: {
                        shift : -1 * self.moveTop
                    },
                    duration: self.peekabooTime,
                    easing: 'easeOutCubic',
                    step: function(shifty) {
                        var top = shifty.shift;
                        self.$openUl[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';

                    },
                    finish: function() {

                    }
                });

            } else {
                self.moveTop = 0;
            }

            var openPeekAnimationTween = new Tweenable();

            openPeekAnimationTween.tween({
                from: {
                    top: 0,
                    shift : 0
                },
                to: {
                    top: self.peekHeight,
                    shift : self.moveTop
                },
                duration: self.peekabooTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    var top = shifty.top - shifty.shift;
                    self.$drawer[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';

                },
                finish: function() {
                    self.$drawer.addClass('open');
                    self.isAnimating = false;
                    self.view.sandbox.emit('drawer.finishOpen');

                    if (window.devicelistEvents) {
                        window.devicelistEvents.emit('smartDrawer.afterOpen');
                    }
                }
            });


        },
        close: function(isPeek, force) {
            this.dfd = $.Deferred();
            if (window.devicelistEvents) {
                window.devicelistEvents.emit('smartDrawer.beforeClose');
            }
            /* only do this if the drawer was open and more than one child */
            var isAvailable = (this.$parent.find('.notAvailableBg').length === 0);

            if (this.$drawer.hasClass('open') && (force || !isAvailable || (this.$ul.children().length > 0 || this.$openUl.children().length > 1))) {
                this.$arrow.show();

                if (this.$drawer.hasClass('isPeekaboo') && isPeek) {
                    this.closePeek();
                } else {
                    this.closeNew();

                }
                this.view.isDrawerOpen = false;
            } else {
                this.dfd.reject();
            }

            if (window.devicelistEvents) {
                window.devicelistEvents.emit('smartDrawer.afterClose');
            }

            preventTwoDrawers = false;
            return this.dfd.promise();
        },
        closeNew: function() {
            var self = this;

            var closeTileAnimationTween = new Tweenable();

            closeTileAnimationTween.tween({
                from: {
                    top: self.upHeight * -1 + self.scrollTop
                },
                to: {
                    top: 0
                },
                duration: self.moveTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    var top = shifty.top;
                    self.$openUl[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                },
                finish: function() {
                    $("#wemo_devices").show();
                }
            });


            this.drawerHeight = self.$drawer.outerHeight();
            var fromTop, toTop;

            if (this.isOpenFromPeekaboo) {
                fromTop = self.upHeight * -1 + self.peekHeight;
                toTop =  self.peekHeight - self.drawerHeight ;
                this.isOpenFromPeekaboo = false;
            } else {
                fromTop = self.drawerEndTop;
                toTop = 0;
            }


            var closeDrawerAnimationTween = new Tweenable();

            closeDrawerAnimationTween.tween({
                from: {
                    top: fromTop,
                    scrollTop: 0
                },
                to: {
                    top: toTop,
                    scrollTop: self.scrollTop
                },
                duration: self.moveTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    var top = shifty.top;
                    self.$drawer[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';

                },
                finish: function() {
                    self.$drawer.removeClass('open');
                    self.finishCloseAnimation();
                    self.$scrollWrapper.scrollTop(self.scrollTop);

                }
            });

        },

        closePeek: function() {
            var self = this;

            var closePeekAnimationTween = new Tweenable();

            closePeekAnimationTween.tween({
                from: {
                    top: self.peekHeight,
                    shift: self.moveTop
                },
                to: {
                    top: 0,
                    shift:0
                },
                duration: self.peekabooTime,
                easing: 'easeOutCubic',
                step: function(shifty) {
                    var top = shifty.top - shifty.shift;
                    self.$drawer[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                },
                finish: function() {
                    self.$drawer.removeClass('open');
                    self.finishCloseAnimation();
                    self.$scrollWrapper.scrollTop(self.scrollTop);
                }
            });

            if (self.moveTop > 0) {
                var shiftTilesBackAnimationTween = new Tweenable();

                shiftTilesBackAnimationTween.tween({
                    from: {
                        shift : -1 * self.moveTop
                    },
                    to: {
                        shift : 0
                    },
                    duration: self.peekabooTime,
                    easing: 'easeOutCubic',
                    step: function(shifty) {
                        var top = shifty.shift;
                        self.$openUl[0].style.webkitTransform = 'matrix(1, 0, 0, 1, 0, '+ top + ')';
                    },
                    finish: function() {

                    }
                });

            }
    },

        finishCloseAnimation: function() {
            var self = this;
            this.dfd = $.Deferred();
            this.$ul.detach();
            this.$base.append(this.$ul);

            if (self.removed) {
                self.removed.reverse();
                _.each(self.removed, function(listItem) {
                    var $listItem = $(listItem);
                    $listItem.detach();
                    self.$ul.prepend($listItem);
                });
            }


            this.$drawer[0].style.webkitTransition = "none";
            this.$drawer[0].style.webkitTransform = 'translate3d(-100%,0,0)';


            if (this.$openUl) {
                this.$openUl.remove();
                self.$btnEl.removeClass('open');
                self.$arrow.removeClass('open');
            }

            this.isAnimating = false;

           self.view.sandbox.emit('drawer.close');
            openObj = null;
            this.dfd.resolve();

            return this.dfd.promise();


        }
    });


    return {
        initialize: function(app) {
            app.core.dom.Accordion2 = Accordion;
        }
    };
});

define('extensions/ui/peekaboo', ['backbone'], function(Backbone) {

    'use strict';

    var Peekaboo = Backbone.View.extend({
        initialize: function(options) {
            var self = this;
            _.bindAll(this);
            this.options = options || {};

            if (!this.options.target) {
                this.options.target = this.$('.powerState');
            }

            if (!this.options.view) {
                throw ('you need to pass the view');
            } else {
                this.view = options.view;
            }

            this.$drawer = this.view.parentView.$drawerParentView;
            this.$btnEl = this.$('.powerState');
            this.$description = this.$btnEl.parents(".smart-tile").find('.description');

        },
        toggle: function() {
            if (this.$drawer.hasClass("isPeekaboo")) {
                this.close();
            } else {
                this.open();
            }
        },

        open: function() {
            this.$drawer.addClass("isPeekaboo");
            this.$description.addClass("open");
            this.updateTimer();
        },

        updateTimer: function() {
            var self = this;
            clearTimeout(this.peekOpenTime);
            this.peekOpenTime =  setTimeout(function(){
                if (self.$drawer.hasClass("isPeekaboo")) {
                    self.options.view.sandbox.emit('close.peekaboo');
                    self.close();
                }
                clearTimeout(self.peekOpenTime);
            },4000);
        },

        close: function() {
            var self = this;
            var closePeekTime = setTimeout(function(){
                self.$drawer.removeClass("isPeekaboo");
                self.$description.removeClass("open");
                clearTimeout(closePeekTime);
            }, 500);
        }
    });

    return {
        initialize: function(app) {
            app.core.dom.Peekaboo = Peekaboo;
        }
    };
});
define('mixins/pickerArrays',[], function() {
    'use strict';

    /**
     * http://stackoverflow.com/questions/4673527/converting-milliseconds-to-a-date-jquery-js
     * @param formatString
     * @returns {XML}
     */

    function customDateFormat(dateObject, formatString) {
        var YYYY, YY, MMMM, MMM, MM, M, DDDD, DDD, DD, D, hhh, hh, h, mm, m, ss, s, ampm, AMPM, dMod, th;
        YY = ((YYYY = dateObject.getFullYear()) + "").slice(-2);
        MM = (M = dateObject.getMonth() + 1) < 10 ? ('0' + M) : M;
        MMM = (MMMM = this.i18n.t('translation:date.months.' + (M - 1))).substring(0, 3);
        DD = (D = dateObject.getDate()) < 10 ? ('0' + D) : D;
        DDD = (DDDD = this.i18n.t('translation:date.days.' + dateObject.getDay())).substring(0, 3);
        th = (D >= 10 && D <= 20) ? 'th' : ((dMod = D % 10) == 1) ? 'st' : (dMod == 2) ? 'nd' : (dMod == 3) ? 'rd' : 'th';
        formatString = formatString.replace("#YYYY#", YYYY).replace("#YY#", YY).replace("#MMMM#", MMMM).replace("#MMM#", MMM).replace("#MM#", MM).replace("#M#", M).replace("#DDDD#", DDDD).replace("#DDD#", DDD).replace("#DD#", DD).replace("#D#", D).replace("#th#", th);

        h = (hhh = dateObject.getHours());
        if (h == 0) h = 24;
        if (h > 12) h -= 12;
        hh = h < 10 ? ('0' + h) : h;
        AMPM = (ampm = hhh < 12 ? 'am' : 'pm').toUpperCase();
        mm = (m = dateObject.getMinutes()) < 10 ? ('0' + m) : m;
        ss = (s = dateObject.getSeconds()) < 10 ? ('0' + s) : s;
        return formatString.replace("#hhh#", hhh).replace("#hh#", hh).replace("#h#", h).replace("#mm#", mm).replace("#m#", m).replace("#ss#", ss).replace("#s#", s).replace("#ampm#", ampm).replace("#AMPM#", AMPM);
    }


    /** function to convert time to seconds **/
    function getSecondsFromTime(time) {
        /* 1. cut off the am/pm */
        var when = time.substring(time.length - 2).toLowerCase();

        /* 2. split on : */

        var hoursAndMinutes = time.substring(0, time.length - 2);
        var arrHoursAndMinutes = hoursAndMinutes.split(':');

        /* 3. convert hours into seconds, minutes into seconds and add */
        var hours = parseInt(arrHoursAndMinutes[0], 10);
        var minutes = parseInt(arrHoursAndMinutes[1], 10);



        if (hours === 12 && when === 'am') {
            hours = 0;
        } else if (hours === 12 && when === 'pm') {
            hours = 12;
        } else if (when === 'pm') {
            hours += 12;
        }



        var hoursToSeconds = hours * 3600;
        var minutesToSeconds = minutes * 60;

        return hoursToSeconds + minutesToSeconds;

    }

    function getWeekday(day) {
        var d = new Date();
        day = day || d.getDay();
        var weekday = new Array(7);
        weekday[0] = "Sunday";
        weekday[1] = "Monday";
        weekday[2] = "Tuesday";
        weekday[3] = "Wednesday";
        weekday[4] = "Thursday";
        weekday[5] = "Friday";
        weekday[6] = "Saturday";

        var n = weekday[day].toLowerCase();
        return n;
    }

    function getSecondsSinceMidnight() {
        var now = new Date();
        var past = new Date(
            now.getFullYear(),
            now.getMonth(),
            now.getDate(),
            0, 0, 0);
        var diff = now.getTime() - past.getTime(); // difference in milliseconds
        return diff / 1000;
    }

    function getRealTime(value) {
        var now = Date.now();
        var ms = value * 1000;
        var realTimeInMS = now + ms;
        var newDate = new Date(realTimeInMS);
        return this.customDateFormat(newDate, '#hh#:#mm# <span>#ampm#</span>');
    }

    function secondsToTime(value) {
        var suffix = 'pm';
        var seconds = Math.floor(value),
            hours = Math.floor(seconds / 3600);
        seconds -= hours * 3600;
        var minutes = Math.floor(seconds / 60);
        seconds -= minutes * 60;

        if (hours < 10) {
            hours = '0' + hours;
        }
        if (minutes < 10) {
            minutes = '0' + minutes;
        }
        //      if (seconds < 10) {seconds = '0'+seconds;}


        if (hours < 12) {
            if (hours === '00' && minutes === '00') {
                suffix = 'pm';
            } else {
                suffix = 'am';
            }
        }
        if (hours === '00') {
            hours = 12;
        }
        if (hours > 12) {
            if (hours === 24 && minutes === '00') {
                suffix = 'pm';
            }
            hours = hours - 12;
        }

        var string = hours + ':' + minutes + '' + suffix;

        return string;
    }

    function secondsToHoursAndMinutes(value, opts) {

        var options = {
            seconds: false,
            hoursString: '<span class="strHours">h</span>',
            minutesString: '<span class="strMinutes">m</span>',
            secondsString: '<span class="strSeconds">s</span>'
        }

        opts = opts || {};

        _.extend(options, opts);


        var output = '';
        var seconds = Math.floor(value),
            hours = Math.floor(seconds / 3600);
        seconds -= hours * 3600;
        var minutes = Math.floor(seconds / 60);
        seconds -= minutes * 60;
        /*
        if (hours < 10) {
            hours = '0' + hours;
        }
        */
        if (options.appendMinuteZeroes && minutes < 10) {
            minutes = '0' + minutes;
        }
        /*
        if (seconds < 10) {
            seconds = '0' + seconds;
        }
      */

        if (hours > 0) {
            output = '<span class="hourNum">' + hours + '</span>' + options.hoursString + ' ';
        }

        output = output + '<span class="minNum">' + minutes + '</span>' + options.minutesString;

        if (options.seconds) {
            output = output + ' ' + seconds + options.secondsString;
        }

        return output;
    }

    function secondsToHoursAndMinutesStr(value, opts) {

        var options = {
            seconds: false,
            hoursString: 'h',
            minutesString: 'm',
            secondsString: 's'
        }

        opts = opts || {};

        _.extend(options, opts);


        var output = '';
        var seconds = Math.floor(value),
            hours = Math.floor(seconds / 3600);
        seconds -= hours * 3600;
        var minutes = Math.floor(seconds / 60);
        seconds -= minutes * 60;
        /*
         if (hours < 10) {
         hours = '0' + hours;
         }
         */
        if (options.appendMinuteZeroes && minutes < 10) {
            minutes = '0' + minutes;
        }
        /*
         if (seconds < 10) {
         seconds = '0' + seconds;
         }
         */

        if (hours > 0) {
            output =  hours + options.hoursString + ' ';
        }

        output = output + minutes + options.minutesString;

        if (options.seconds) {
            output = output + ' ' + seconds + options.secondsString;
        }

        return output;
    }


    function stringToSeconds(value) {
        var a = value.split(':');
        return (+a[0]) * 60 * 60 + (+a[1]) * 60;
    }



    var exports = {
        customDateFormat: customDateFormat,
        secondsToHoursAndMinutes: secondsToHoursAndMinutes,
        secondsToHoursAndMinutesStr: secondsToHoursAndMinutesStr,
        secondsToTime: secondsToTime,
        getRealTime: getRealTime,
        getSecondsFromTime: getSecondsFromTime,
        getSecondsSinceMidnight: getSecondsSinceMidnight,
        getWeekday: getWeekday
    };


    return exports;

});
define('extensions/ui/pickers', ['backbone', 'mixins/pickerArrays'], function(Backbone, PickerArrays) {

    'use strict';

    var aura;

    function Pickers(type, options) {
        this[type].createPickerArray();
        var picker = this[type].createPickerDropdown();
        if (options.id) {
            picker.setAttribute('id', options.id);
            picker.setAttribute('name', options.id);
        }
        if (options.classes) {
            picker.setAttribute('class', options.classes);
        }

        return picker;
    }

    Pickers.prototype = PickerArrays;

    return {
        initialize: function(app) {
            aura = app;
            app.core.dom.Pickers = Pickers;

            _.extend(app.core.util, {
                customDateFormat: function() {
                    return PickerArrays.customDateFormat.apply(app.core, arguments);
                },
                secondsToHoursAndMinutes: function() {
                    return PickerArrays.secondsToHoursAndMinutes.apply(this, arguments);
                },
                secondsToHoursAndMinutesStr: function() {
                    return PickerArrays.secondsToHoursAndMinutesStr.apply(this, arguments);
                },
                secondsToTime: function() {
                    return PickerArrays.secondsToTime.apply(this, arguments);
                },
                getRealTime: function() {
                    return PickerArrays.getRealTime.apply(this, arguments);
                },
                getSecondsFromTime: function() {
                    return PickerArrays.getSecondsFromTime.apply(this, arguments);
                },
                getSecondsSinceMidnight: function() {
                    return PickerArrays.getSecondsSinceMidnight.apply(this, arguments);
                }
            });
            /*
            app.core.util.secondsToHoursAndMinutes = function(){
                return PickerArrays.secondsToHoursAndMinutes.apply(this,arguments);
            };
            app.core.util.secondsToTime = function(){
                return PickerArrays.secondsToTime.apply(this,arguments);
            };
            app.core.util.getRealTime = function(){
                return PickerArrays.getRealTime.apply(this,arguments);
            }; */
        }
    };
});

/*
 constants.js

 Created by Belkin International, Software Engineering on 10/04/2013.
 Copyright (c) 2012-2013 Belkin International, Inc. and/or its affiliates. All rights reserved.

 Belkin International, Inc. retains all right, title and interest (including all
 intellectual property rights) in and to this computer program, which is
 protected by applicable intellectual property laws.  Unless you have obtained
 a separate written license from Belkin International, Inc., you are not authorized
 to utilize all or a part of this computer program for any purpose (including
 reproduction, distribution, modification, and compilation into object code),
 and you must immediately destroy or return to Belkin International, Inc. all copies
 of this computer program.  If you are licensed by Belkin International, Inc., your
 rights to utilize this computer program are limited by the terms of that license.

 To obtain a license, please contact Belkin International, Inc.

 This computer program contains trade secrets owned by Belkin International, Inc.
 and, unless unauthorized by Belkin International, Inc. in writing, you agree to
 maintain the confidentiality of this computer program and related information
 and to not disclose this computer program and related information to any
 other person or entity.

 THIS COMPUTER PROGRAM IS PROVIDED AS IS WITHOUT ANY WARRANTIES, AND BELKIN INTERNATIONAL, INC.
 EXPRESSLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES OF
 MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.
 */
define('libs/constants',[],function(){

    var plugins = {
        SETUP : "SetupPlugin",
        DEVICE : "DevicePlugin",
        MORE_TAB : "MoreTabPlugin",
        CLOUD : "cloud",
        NATIVE_UTIL : "NativeUtilPlugin"
    };

    var actions = {
        INITIALIZE_UPNP : '2000',
        IS_DEVICES_FOUND : "2001",
        GET_WEMO_DEVICE_LIST : "2002",
        STOP_CONTROL_POINT : "2003",
        SET_DEVICE_STATE : "2004",
        START_DEVICE_LISTENERS : "2005",
        STOP_DEVICE_LISTENERS : "2006",
        DEVICE_TAB_SET_FRIENDLY_NAME : "2007",
        DEVICE_TAB_SET_DEVICE_IMAGE : "2008",
        CLEAR_NAME_ICON_RULE : "2009",
        RESET_TO_FACTORY_DEFAULT : "2010",
        GET_WEMO_SSID : "2011",
        GET_NETWORK_TYPE : "2012",
        IS_REMOTE_ENABLED : "2013",
        GET_CURRENT_FIRMWARE : "2014",
        IS_FIRMWARE_AVAILABLE : "2015",
        GET_FIRMWARE_UPDATE_LIST : "2016",
        UPDATE_FIRMWARE : "2017",

        //Rules
        RULES_VERSION:"5001",
        SELECT_SWITCHES:"5002",
        SELECT_SENSORS:"5003",
        READ_DB_FROM_PLUGIN:"5004",
        PUSH_DB_TO_PLUGIN:"5005",
        PUSH_SCH_STR_TO_PLUGIN:"5006",
        READ_DB_FROM_CLOUD:"5007",
        STORE_DB_FROM_CLOUD:"5008",
        COPY_DB_SKELETON:"5009",
        GET_REMOTE_DB_VERSION:"5010",
        SET_REMOTE_DB_VERSION:"5011",
        //SRSS
        GET_LOCATION_INFO:"5015",
        GET_SR_SS_TIME:"5016",
        GET_FIRMWARE_VERSION_SRSS:"5017",
        //SRSS
        DB_UPDATE_ON_CHANGE_NETWORK:"5018",
        //More Tab
        SET_REMOTE_ACCESS : "6001",
        GET_REMOTE_ACCESS : "6002",
        GET_LOCAL_EMAIL_BODY : "6003",
        //Native Util
        PREF_IS_REMOTE_ENABLED : "7001",
        PREF_SET_REMOTE_ENABLED : "7002",
        SEND_EMAIL : "7003",
        GET_PLAY_STORE_URL : "7004",
        GET_APP_VERSION : "7005",
        IS_HOME_NETWORK : "7006",
        GET_TELL_US_MOBILE_INFO : "7007",
        GENERATE_AUTH_CODE : "7008",
        READ_TEXT_FILE : "7009",
        PREF_SET_CONFIG_STATUS : "7010",
        PREF_GET_CONFIG_STATUS : "7011",
        PREF_GET_EMAIL_STATUS : "7012",
        PREF_SET_EMAIL_STATUS : "7013",
        PREF_GET_EMAIL : "7014",
        PREF_SET_EMAIL : "7015",
        GET_BASE64_IMAGE_FROM_DB : "7016",
        GET_NETWORK_TYPE_NEW : '7017',
        PREF_GET_CONFIG_STRING : '7018',
        PREF_SET_GET_STARTED_NEEDED : '7019',
        PREF_GET_GET_STARTED_NEEDED : '7020',

        //LED
        DELETE_WEEKLY_CALENDAR: "8024",

        //Native UI
        SHOW_PROGRESS : "9001",
        HIDE_PROGRESS : "9002",
        OPEN_SOFT_KEYBOARD : "9003",

        //Sunrise Flag
        SUN_TIME : true,

        //Netcam App
        CHECK_NET_CAM : '9004',
        LAUNCH_NET_CAM_APP : '9105'
    };

    var key = {
        DEVICE_FRIENDLY_NAME : "friendlyName",
        DEVICE_TYPE : "type",
        DEVICE_UDN : "udn",
        DEVICE_STATE : "state",
        DEVICE_ICON_URL : "iconUrl",
        DEVICE_PLUGIN_ID : "pluginId",
        DEVICE_MAC_ADDRESS : "macAddress",
        DEVICE_NEW_FIRMWARE_VERSION : "newFirmwareVersion",
        DEVICE_NEW_FIRMWARE_URL : "newFirmwareURL",
        DEVICE_NEW_FIRMWARE_SIGNATURE : "newFirmwareSignature",
        DEVICE_FIRMWARE : "devicefirmware",
        DEVICE_FIRMWARE_COUNTDOWN : 'DEVICE_FIRMWARE_COUNTDOWN',
        DEVICE_FIRMWARE_COUNTDOWN_START_TIME : 'DEVICE_FIRMWARE_COUNTDOWN_START_TIME',
        DEVICE_FIRMWARE_UPGRADE_STARTED : "DEVICE_FIRMWARE_UPGRADE_STARTED",
        DEVICE_FIRMWARE_UPGRADE_DOWNLOADING : "DEVICE_FIRMWARE_UPGRADE_DOWNLOADING",
        DEVICE_STATUS_TIMESTAMP : "statusTimestamp",
        DEVICE_SECURITY_STRENGTH : "SecurityStrength",
        DEVICE_SECURITY_SSID : "SSID",
        DEVICE_SECURITY_SIGNALSTRENGTH : "SignalStrength",
        DEVICE_SECURITY_CHANNEL : "Channel",
        NOTIFY_TYPE : "notifyType",

        //setup
        SETUP_TYPE : 'SETUP_TYPE',

        //Location
        LOCATION_ID : 'locationID',
        COUNTRY : 'country',
        REGION : 'region',
        CITY : 'city',
        LATITUDE : 'latitude',
        LONGITUDE : 'longitude'

    };

    var smartKey = {
        SMART_DEVICE_ID : "deviceId",
        SMART_DEVICE_DESC : "deviceDesc",
        SMART_DEVICE_UNIQUEID : "deviceUniqueId",
        SMART_DEVICE_STATUS : "deviceState"
    };

    var sessionStore = {

        DEVICE_EDIT_WEMO_FRIENDLY_NAME : "DEVICE_EDIT_WEMO_FRIENDLY_NAME",
        DEVICE_EDIT_WEMO_ICON_URL : "DEVICE_EDIT_WEMO_ICON_URL",
        DEVICE_EDIT_WEMO_UDN : "DEVICE_EDIT_WEMO_UDN",
        DEVICE_EDIT_WEMO_ICON_URI : "DEVICE_EDIT_WEMO_ICON_URI",
        DEVICE_EDIT_WEMO_DEVICE_TYPE : "DEVICE_EDIT_WEMO_DEVICE_TYPE",
        DEVICE_EDIT_WEMO_DEVICE_SSID : "DEVICE_EDIT_WEMO_DEVICE_SSID",

        REMOTE_MODE : "REMOTE_MODE",

        FIRMWARE_AVAILABLE : "FIRMWARE_AVAILABLE",

        RULE_NEW:"NEW_RULE",

        SIMPLE_SWITCH:"Simple Switch",
        TIME_INTERVAL:"Time Interval",
        MOTION_CONTROLLED:"Motion Controlled",

        RULES_DATA:"RULES_DATA",
        CURRENT_DEVICE:"CURRENT_DEVICE",
        CURRENT_DEVICE_NAME:"FRIENDLY_NAME",

        RULES_DATA:"RULES_DATA",
        SELECTED_RULEID:"SELECTED_RULEID",
        EDIT_FLAG:"EDIT_FLAG",
        ALLDAY_STARTTIME:"60",
        ALLDAY_ENDTIME:"86340",
        SENSOR_ALLDAY:"All Day",
        //SRSS
        SR_SS:"SRSS",
        SRSS_SELECTED_DAYS:"SRSSSelectedDays",
        LOCATION_INFO:"locationInfo",
        CURRENT_LOCATION:"currentLocation",
        //SRSS

        //Setup
        SETUP_REMOTE_STATUS : "SETUP_REMOTE_STATUS",
        SETUP_HOME_ID : "SETUP_HOME_ID",
        WEEK_DAYS : "Weekdays",
        WEEK_END : "Weekends",
        DAILY : "Daily",
        WEEK_DAYS_VAL : "Mon-Tue-Wed-Thu-Fri",
        WEEK_END_VAL : "Sat-Sun",
        DAILY_VAL : "Mon-Tue-Wed-Thu-Fri-Sat-Sun",
        AP_LIST : "AP_LIST",
        STARTUP_MODE : "STARTUP_MODE",
        // Rule Type
        RULE_TYPE: "WEMO_RULE",
        RULE_DAYS: "WEMO_RULE_DAYS",
        RULE_TIMES : "WEMO_RULE_TIMES",

        //Firmware
        FIRMWARE_DATA : "FIRMWARE_DATA",
        FIRMWARE_UPDATE_DATA : 'FIRMWARE_UPDATE_DATA',
        SWITCH_DATA : "SWITCH_DATA",
        SENSOR_DATA : "SENSOR_DATA",
        REMOTE_CALL_GETDB : "GETDB",
        REMOTE_CALL_SETDB : "SETDB",
        REMOTE_CALL_ENABLE : "SET_REMOTE_ENABLE",
        REMOTE_CALL_NETWORKTYPE : "SET_REMOTE_NETWORKTYPE",
        FIRMWARE_VERSION_DATA : "FIRMWARE_VERSION",

        //More
        HELP_URL : 'HELP_URL',
        MORE_LOCATION_SETTINGS : 'moreTab',
        RULES_LOCATION_SETTINGS : 'rulesTab'

    };

    var startupMode = {
        MANUAL_CONNECT : "MANUAL_CONNECT",
        HIDDEN_MANUAL_CONNECT : "HIDDEN_MANUAL_CONNECT",
        RETRY_REMOTE_ENABLE : 'RETRY_REMOTE_ENABLE'
    };

    var wemoDeviceType = {

        SWITCH : "urn:Belkin:device:controllee:1",
        MOTION_SENSOR : "urn:Belkin:device:sensor:1"

    };

    var defaultIcon = {
        SENSOR_THUMB_URI : "file:///android_asset/www/img/belkin_sensor_small.png",
        SWITCH_THUMB_URI : "file:///android_asset/www/img/belkin_switch_small.png"

    };

    var wemoRemoteDeviceType = {
        MOTION_SENSOR : "Sensor",
        SWITCH : "Socket"
    };

    var timeout = {
        SHORT : 20,
        MEDIUM : 50,
        LONG : 100,
        AUTO_REFRESH : 60000,
        URL_TIMEOUT: 180000,
        FIRMWARE_CHECK : 10000,
        ONE_SECOND : 1000,
        WIFI_REFRESH : 10000,
        SETUP_EXIT : 20000,
        AP_CLOSE : 10000,
        CONTROL_POINT_DELAY : 3000,
        NETWORK_RETRY : 1000,
        ENABLE_REMOTE_ACCESS_DELAY : 5000,
        URL_TIMEOUT_SMARTDEVICE_LIST: 15000

    };

    var timestamp = {
        ONE_MINUTE : 60000,
        MAX_HOUR : 86400,
        ONE_MINUTE : 3600
    };

//Navigation
    var navigationUrlOptions={loadUrlTimeoutValue: timeout.URL_TIMEOUT};
    var name ={
        SWITCH: "WeMo Switch",
        SENSOR: "WeMo Sensor"
    };

    var networkType ={
        NO_NETWORK : 'No_Network',
        HOME_NETWORK : 'Home',
        REMOTE_WIFI : 'Remote_WiFi',
        REMOTE_MOBILE : 'Remote_Mobile',
        WEMO : 'WEMO'
    };

    var cloudEnvironment = {
    	STAGING : "https://stagapi.xbcs.net:8443",
    	PRODUCTION: "https://api.xbcs.net:8443",
        MONOLITHIC: "https://devtest-1373897041.us-east-1.elb.amazonaws.com:8443"
    };


    var firmwareCloudEnvironment = {
    	STAGING : "http://fw.stag1.xbcs.net",
    	PRODUCTION : "https://fw.xbcs.net",
        MONOLITHIC: "https://fw.xbcs.net"
    };

    var cloud = cloudEnvironment.PRODUCTION;
    var firmwareCloud = firmwareCloudEnvironment.PRODUCTION;
    var isBetaApp = 0;
    var minimumFirmware = "1296";

    var cloudAPI = {
        DEVICE_LIST : cloud + "/apis/http/plugin/plugins/",
        STATE_CHANGE : cloud + "/apis/http/plugin/message/",
        REGISTER_EMAIL : cloud + "/apis/http/plugin/registerEmail/",
        FIRMWARE_URL : cloud + "/apis/http/plugin/fwUpgradeInfo/",
        SMARTDEVICE_DISABLE : cloud + "/apis/http/plugin/updateRemoteAccess/",
        SMARTDEVICE_LIST : cloud + "/apis/http/plugin/smartDevices/",
        GENERATE_IFTTT_PIN : cloud + "/apis/http/plugin/generatePin/",
        DEVICE_MESSAGE : cloud + '/apis/http/plugin/message/',
        FIRMWARE_UPGRADE : cloud + '/apis/http/plugin/upgradeFwVersion',
        GET_DB_FILE : cloud + '/apis/http/plugin/dbfile/',
        LOCATION_SEARCH : cloud + '/apis/http/plugin/geoInfo/cityLocations?cityName='
    };

    var firmwareTextFile = {
        PATH : firmwareCloud + "/wemo/firmware.txt"
    };

    var SQLColumns={
        DB_NAME:"pluginrules2",
        DB_VERSION:"2",
        RULE_DEVICE_PK:"RuleDevicePK",
        RULE_ID:"RuleID",
        DEVICE_ID:"DeviceID",
        GROUP_ID:"GroupID",
        DAY_ID:"DayID",
        START_TIME:"StartTime",
        RULE_DURATION:"RuleDuration",
        START_ACTION:"StartAction",
        END_ACTION:"EndAction",
        SENSOR_DURATION:"SensorDuration",
        TYPE:"Type",
        VALUE:"Value",
        LEVEL:"Level"
    };

    var networkSecurity = {

        CHANNEL : "255",

        OPEN : "Open",
        AUTH_OPEN : "OPEN",
        ENCRYPT_OPEN : "NONE",

        WEP : "WEP",
        AUTH_WEP : "WEP",
        ENCRYPT_WEP : "WEP",

        WPA : "WPA",
        AUTH_WPA : "WPA1PSKWPA2PSK",
        ENCRYPT_WPA : "AES",

        WPA2 : "WPA2",
        AUTH_WPA2 : "WPA1PSKWPA2PSK",
        ENCRYPT_WPA2 : "AES"
    };

    var email = {
        help : "wemohelp@belkin.com"
    };

    var firmwareUpgradeProcess = {
        Interval : 5
    };

    var notificationType = {
        BINARY_STATE : 'BinaryState',
        FIRMWARE_STATE : 'FirmwareUpdateStatus'
    };

    var buildXML = {
        PLUGIN_STATE : 'PLUGIN_STATE',
        FIRMWARE_VERSION : 'FIRMWARE_VERSION',
        FIRMWARE_UPGRADE : 'FIRMWARE_UPGRADE'
    };

    var wemoSwitch = {
        TYPE : 'urn:Belkin:device:controllee:1',
        REMOTE_TYPE : 'Socket',
        ICON : 'file:///android_asset/www/img/belkin_switch_small.png',
        NAME : 'DefaultName_WeMoSwitch',  //key from language file
        SETUP_TITLE : 'WeMoSwitchSetUp',  //key from language file
        SETUP_SUCCESS_MESSAGE : 'SetupSuccessful_SwitchSetupInstructions' //key from language file
    };

    var wemoSensor = {
        TYPE : 'urn:Belkin:device:sensor:1',
        REMOTE_TYPE : 'Sensor',
        ICON : 'file:///android_asset/www/img/belkin_sensor_small.png',
        NAME : 'DefaultName_WeMoMotion', //key from language file
        SETUP_TITLE : 'WeMoSensorSetup',  //key from language file
        SETUP_SUCCESS_MESSAGE : 'SetupSuccessful_SensorSetupInstructions' //key from language file
    };

    var wemoLightSwitch = {
        TYPE : 'urn:Belkin:device:lightswitch:1',
        REMOTE_TYPE : 'Lightswitch',
        ICON : 'file:///android_asset/www/img/belkin_light_switch_small.png',
        NAME : 'DefaultName_WeMoLightSwitch', //key from language file
        SETUP_TITLE : 'WeMoLightSwitchSetup', //key from language file
        SETUP_SUCCESS_MESSAGE : 'SetupSuccessful_SwitchSetupInstructions' //key from language file
    };

    var wemoDevice = {
        SWITCH : wemoSwitch,
        SENSOR : wemoSensor,
        LIGHT_SWITCH : wemoLightSwitch
    };

    return {
        actions: actions,
        networkType: networkType,
        plugins:plugins,
        SQLColumns : SQLColumns,
        isBetaApp: isBetaApp,
        cloudLink: cloud,
        cloudAPI: cloudAPI,
        timeout: timeout
    }
});


/**
 * cordova plugin mixins for use throughout app where needed.
 */

define('features/cordova/app',['libs/constants', 'feature!appSettings'], function(constants, appSettings) {
    'use strict';

    var globalIsRemoteEnabled;
    var globalNetworkType;

    var resetNetworkVars = function() {
        globalIsRemoteEnabled = null;
        globalNetworkType = null;
    };

    if (window.devicelistEvents) {
        window.devicelistEvents.on('onAppResume', resetNetworkVars);
    }

    function makeCordovaCall(plugin, action, callback, data) {

        data = data || [];

        return $.Deferred(function(dfd) {

            var callMeMaybe = function(resp) {
                dfd.resolve(resp);
            };

            if (callback) {
                callMeMaybe = callback;
            }

            cordova.exec(callMeMaybe, callMeMaybe, plugin, action, data);

        }).promise();
    }

    return {
        makeCordovaCall: makeCordovaCall,
        getNetworkType: function() {
            return $.Deferred(function(dfd) {
                var callMeMaybe = function(resp) {
                    globalNetworkType = resp;
                    dfd.resolve(resp);
                };
                if (!globalNetworkType)
                    cordova.exec(callMeMaybe, callMeMaybe, constants.plugins.DEVICE, constants.actions.GET_NETWORK_TYPE, []);
                else
                    callMeMaybe(globalNetworkType);
            }).promise();
        },
        isRemoteEnabled: function() {
            return $.Deferred(function(dfd) {
                var callMeMaybe = function(resp) {
                    globalIsRemoteEnabled = resp;
                    window.sessionStorage.setItem('isRemoteEnabled', resp);
                    DEBUG && console.log('REMOTE ENABLED:' + JSON.stringify(resp));
                    dfd.resolve(resp);
                };
                if (!globalIsRemoteEnabled)
                    cordova.exec(callMeMaybe, callMeMaybe, 'DevicePlugin', constants.actions.IS_REMOTE_ENABLED, []);
                else
                    callMeMaybe(globalIsRemoteEnabled);
            }).promise();
        },
        getDeviceList: function() {
            var self = this;

            var dfd = $.Deferred();

            var callMeMaybe = function(resp) {
                dfd.resolve(resp);
            };

            var dontCallMe = function() {
                dfd.reject(arguments);
            };

            $.when(this.isRemoteEnabled(), this.getNetworkType())
                .then(function(isRemoteEnabled, networkType) {
                    isRemoteEnabled = false;
                    if (isRemoteEnabled && networkType.match(/remote/gi)) {

                        //need to do a remote call.
                        self.getAuthorizationCode().then(function(resp) {
                            $.ajax({
                                beforeSend: function(xhr) {
                                    xhr.setRequestHeader('Content-Type', 'application/json');
                                    xhr.setRequestHeader('Authorization', resp[0]);

                                },
                                type: 'get',
                                success: callMeMaybe,
                                error: dontCallMe,
                                url: appSettings.cloudIpAddress + 'plugins/' + resp[1]
                            });
                        });
                    } else {
                        cordova.exec(callMeMaybe, dontCallMe, 'WeMoSMARTDevicePlugin', 'getAllDevices', []);
                    }
                });

            return dfd.promise();
        },
        getImageFromDB: function(model) {
            return makeCordovaCall(constants.plugins.NATIVE_UTIL, constants.actions.GET_BASE64_IMAGE_FROM_DB, null, [model.get('udn')]);
        },
        downloadDBFromDevice: function() {
            return makeCordovaCall(constants.plugins.DEVICE, constants.actions.READ_DB_FROM_PLUGIN);
        }
    };

});
define('features/database/sqlite-notIos',['libs/constants','feature!cordova'],function(constants,cordovaMixins){
    'use strict';


    /** create the rules database. it will get its version number from the version database **/
    var createRulesSql = [
        'CREATE TABLE IF NOT EXISTS RULES (RuleID unique, Name, Type, RuleOrder, StartDate, EndDate,State, Sync)',
        'CREATE TABLE IF NOT EXISTS RULEDEVICES (RuleDevicePK unique, RuleID INTEGER, DeviceID, GroupID, DayID INTEGER, StartTime,RuleDuration, StartAction INTEGER, EndAction INTEGER, SensorDuration,Type,Value,Level)',
        'CREATE TABLE IF NOT EXISTS DEVICECOMBINATION (DeviceCombinationPK, RuleID, SensorID, SensorGroupID, DeviceID, DeviceGroupID)',
        'CREATE TABLE IF NOT EXISTS GROUPDEVICES (GroupDevicePK, GroupID, DeviceID)',
        'CREATE TABLE IF NOT EXISTS LOCATIONINFO (LocationPK, cityName, countryName, latitude, longitude, countryCode, region)',
        'CREATE TABLE IF NOT EXISTS BLOCKEDRULES (Primarykey, ruleId)'
    ];

    /**
     * Database Object
     * @param options {Object}
     * @constructor Database
     */
    var Database = function(options){
        var self = this;
        this.options = options || {};


        this.getVersionDB();
        //
    };

    /**
     * Database Object prototype
     * @type {{constructor: Function, dbName: string, dbVersion: string, transaction: Function, getVersionDB: Function, insertRule: Function, deleteRule: Function, updateRule: Function, getRulesDB: Function, _throwError: Function}}
     */
    Database.prototype = {
        constructor: Database,
        dbName: 'wemoTestDB',
        dbVersion: '1.0',
        /**
         * Base transaction interface. Uses promises to flatten callbacks
         * @param sql {string} {array} - the sql statement string, or an array of sql statements to execute as part of the transaction
         * @param values {array} - array of values to replace ? with in sql statements
         * @returns {JQueryDeferred}
         */
        transaction: function(sql, values){
            var self = this;
            var db = this.db;

            values = values || [];

            if(!this.responseObj){
                this.responseObj = {};
            }
            /*
                returns a promise for the db download. once the db download is resolved, then it will run the transaction.
                if there is an error downloading the DB, none of it will happen
             */
            return this.downloadDB().then(function(){
                /*
                    the promise for the transaction. it will be resolved or rejected.
                 */
                return $.Deferred(function (dfd) {

                    var errorFunc = function(){
                        console.error('errorfunc',arguments)
                        dfd.reject(arguments);
                    };

                    var transactionFunc = function(tx){
                        tx.executeSql(sql, values,function(tx,results){
                            console.log(sql,values,results.rows)
                            if(results.rows.length > 0){
                                results.attributes = [];
                                for(var i=0;i<results.rows.length;i++){
                                    results.attributes.push(results.rows.item(i));
                                }
                            }
                            else{
                                results.noResults = true;
                            }

                            self.responseObj[sql] = results;
                            dfd.resolve(results);
                        }, function(tx,results){
                            console.error('error',results,sql,values)
                            dfd.reject(results);
                        });
                    };

                    var successFunc = function(){};

                    if(!_.isArray(sql) && sql.match(/DBVERSION/)){
                        db = self.versionDB;
                    }

                    if(_.isArray(sql)){
                        transactionFunc = function(tx){
                            sql.forEach(function(command){
                                tx.executeSql(command);
                            });
                        };

                        successFunc = function(){
                            dfd.resolve(arguments);
                        };
                    }

                    db.transaction(transactionFunc,errorFunc, successFunc);

                }).promise();

            }).fail(function(resp){
                self._throwError(resp);
            });

        },
        /**
         *  Gets the version from the version database to be able to grab most recent version ... this is not correct for WEMO right now
         *  WEMO uses pragmas, which aren't supported in browser, so this is just to test.
         */
        getVersionDB: function(){
            var self = this;

            this.versionDB = window.openDatabase('wemo-dbversions',1.0,'wemo-dbversions',10000000);

            this.transaction('CREATE TABLE IF NOT EXISTS DBVERSION (id INTEGER PRIMARY KEY ASC, name, version)').then(function(){
                    return self.transaction('select * from DBVERSION where name=="'+self.dbName+'"');
                })
                .done(function(resp){
                    if(resp.rows.length === 0){
                       // we aren't tracking version yet, use the version from the android app or something, or create our own
                        self.transaction('INSERT INTO DBVERSION (version, name) VALUES (?,?)',[self.dbVersion,self.dbName])
                           .done(function(){
                                self.getVersionDB(); //recurse back around to get to the positive response
                            })
                           .fail(self._throwError);
                    }
                    else{
                        this.dbVersion = resp.attributes[0].version;
                        self.getRulesDB();
                    }
                })
                .fail(self._throwError);

        },
        /**
         * checks to see if we need to download a new copy of the database, decides where to download based on network type
         * and if remote is enabled
         * @returns {JQueryDeferred}
         */
        downloadDB: function(){
            var self = this;
            /*
                returns a promise that is resolved or rejected based on the outcome of a parallel async operation
                to get the network type, and see if we are remote
             */
            return $.Deferred(function (dfd) {

                $.when(
                        self.getNetworkType(),
                        self.isRemoteEnabled()
                    ).then(function(getNetworkTypeResponse,isRemoteEnabledResponse){
                        console.log('RESPONSE',arguments)
                        if(getNetworkTypeResponse === constants.networkType.NO_NETWORK){
                            // TODO: throw some kind of no network error to somebody. Global emit?
                            console.error('NO NETWORK FOUND');
                            dfd.reject(getNetworkTypeResponse)
                        } else if(getNetworkTypeResponse.match(/remote/i)) {

                            if(isRemoteEnabledResponse){
                                // TODO: do download db from cloud
                                /* returns another promise that fulfills either the rejected or resolved for this promise
                                 * loaded via cloud connector (once it is written)
                                */
                                //return self.downloadDBFromCloud();
                                return self.downloadDBFromDevice();
                            }
                            else{
                                dfd.reject(isRemoteEnabledResponse);
                                // TODO: error handling for remote but not enabled
                            }

                        } else {
                            /* returns another promise that fulfills either the rejected or resolved for this promise
                            *  loaded via cordovaMixins
                            */
                            return self.downloadDBFromDevice();
                        }
                    }).done(function(resp){
                        // TODO: may need to put version control functionality here

                        dfd.resolve(resp);
                    }).fail(function(resp){
                        dfd.reject(resp);
                    });

            }).promise();
        },
        /**
         * Get the devices rules from the database, wrapped in a promise for internal and external use
         * Version 1 - Only handle simple rules, 1 rule per device
         * @param options
         */
        getRules: function(options){

            options = options || {};
            var sqlStatement = 'SELECT * from RULES a inner join RULEDEVICES b on a.RuleID=b.RuleID and b.DeviceID==? order by b.RuleID';
            var values = [options.id];
            var self = this;



            return $.Deferred(function (dfd) {

                self.transaction(sqlStatement, values).done(function(resp){
                    console.log('GET RULES',resp.attributes)




                    if(!options.internal && options.callback){
                        if(resp.rows.length === 0){
                            resp = [{}];
                        }
                        else{
                            resp = resp.attributes;
                        }

                        options.callback(resp);
                    }
                    else if(options.internal){

                    }

                    dfd.resolve(resp);

                }).fail(function(resp){
                    dfd.reject(resp);
                    self._throwError();
                    if(options.errorCallback){
                        options.errorCallback('Database Error');
                    }
                });

            }).promise();
        },
        /**
         * Insert a rule into the database
         * Version 1 - Only handles simple rules
         * @param options {Object}
         */
        insertRule: function(options){

            options = options || {};

            var self = this;
            var ruleId = 1;
            var deviceId = [options.id];
            var rule = options.rule;



            // 1. get the existing rules so we can get the next ID (this is so wrong.. why didnt they do auto increment??)

            this.transaction('SELECT RuleID from RULES').then(function(resp){

                if(resp.rows.length > 0){
                    ruleId = parseInt(resp.attributes[(resp.attributes.length-1)].RuleID,10) + 1; //get the last id, and add to it
                }

                var sqlStatements = [
                    'INSERT INTO RULES (RuleID, Name, Type, RuleOrder, StartDate, EndDate,State, Sync) VALUES ("'+ruleId+'","'+rule.switchArray[0].FRIENDLYNAME+'", "'+rule.type+'", "1", "12201983", "12201983", "'+rule.state+'", "NOSYNC")',
                    'INSERT INTO RULEDEVICES (RuleID, DeviceID, GroupID, DayID, StartTime,RuleDuration, StartAction, EndAction, SensorDuration,Type,Value,Level) VALUES ('+ruleId+',"'+deviceId+'", "0", "'+rule.dayId+'", "'+rule.startTime+'","'+rule.ruleDuration+'", '+rule.switchArray[0].STARTACTION+', '+rule.switchArray[0].ENDACTION+', "0","-1","0","-1")'
                ];

                self.transaction(sqlStatements).done(function(resp){
                    console.log(resp)
                    if(options.callback){
                        options.callback(resp);
                    }
                }).fail(self._throwError);

            });



            /*
             From wemo hybrid - wemo_util.js 282
             tx.executeSql('INSERT INTO RULES (RuleID, Name, Type, RuleOrder, StartDate, EndDate,State, Sync) VALUES ("'+len+'","'+rule.RuleName+'", "'+rule.RuleType+'", "2", "12201983", "12201983", "'+rule.State+'", "NOSYNC")');

             From wemo hybrid - wemo_util.js 291 (rule contains multiple devices being controlled, so its in a loop. can do this anyway for one device)
             tx.executeSql('INSERT INTO RULEDEVICES (RuleID, DeviceID, GroupID, DayID, StartTime,RuleDuration, StartAction, EndAction, SensorDuration,Type,Value,Level) VALUES ('+len+',"'+device+'", "0", "'+deCodeDays(arrDays[daysCount1])+'", "'+rule.When.StartTime+'","'+rule.When.RuleDuration+'", '+rule.Devices[device].StartAction+', '+rule.Devices[device].EndAction+', "'+rule.Devices[device].SensorDuration+'","-1","'+rule.SelectedSensorsValue+'","-1")');

             From wemo hybrid - wemo_util.js 303 (if the device is a sensor, which can control other devices)
             tx.executeSql('INSERT INTO RULEDEVICES (RuleID, DeviceID, GroupID, DayID, StartTime,RuleDuration, StartAction, EndAction, SensorDuration,Type,Value,Level) VALUES ('+len+',"'+arrSensors[sensors]+'", "0", "-1", "'+rule.When.StartTime+'","'+rule.When.RuleDuration+'", "-1", "-1", "-1","0",'+rule.SelectedSensorsValue+',"2")');

             From wemo hybrid - wemo_util.js 305 (the devices being added to the sensor)
             tx.executeSql('INSERT INTO DEVICECOMBINATION (RuleID, SensorID, SensorGroupID, DeviceID, DeviceGroupID) VALUES ('+len+',"'+arrSensors[sensors]+'", "0", "'+Object.keys(rule.Devices)[device]+'", "0")');

             */

        },
        /**
         * delete a rule
         * @param options {Object}
         */
        deleteRule: function(options){

            /*   from wemo hybrid - wemo_util.js 278
             tx.executeSql("DELETE FROM RULES WHERE RuleID='"+ruleObj.id+"'", [], function(){console.log("Rule with ID : "+ruleObj.id+" is deleted");}, errorCB);
             tx.executeSql("DELETE FROM RULEDEVICES WHERE RuleID="+ruleObj.id, [], function(){console.log("Rule with ID : "+ruleObj.id+" is deleted");}, errorCB);
             */

            var sqlStatements = [
                'DELETE FROM RULES WHERE RuleID="'+options.id+'"',
                'DELETE FROM RULEDEVICES WHERE RuleID="'+options.id+'"'
            ];
            var self = this;

            return $.Deferred(function (dfd) {

                self.transaction(sqlStatements).done(function(resp){

                    dfd.resolve();
                }).fail(function(){
                        self._throwError();
                        dfd.reject();
                    });
            }).promise();

        },
        /**
         * Update a rule - we will always update a rule by deleting and re-inserting, so this
         * method sees if the rule exists, then deletes it, and adds it back.
         * @param options {Object}
         */
        updateRule: function(options){
            var self = this;
            this.getRules({
                id:options.id,
                internal:true
            }).then(function(resp){
                    console.log(resp.rows);
                if(resp.rows.length === 0){
                   //we can go right to insert
                    self.insertRule(options);
                }
                else{
                   //we need to delete the rule first
                    var def = (new $.Deferred()).resolve();
                    var calls = [];

                    resp.attributes.forEach(function(row){
                        calls.push({id:row.RuleID});
                    });

                    calls.forEach(function(call){
                        def = def.pipe(function() {
                            return self.deleteRule(call);
                        });
                    });

                    def.done(function(){
                        self.insertRule(options);
                    });

                }
            });
        },
        /**
         * Get/Create the rules database tables if they don't already exist
         */
        getRulesDB: function(){
            this.db = window.openDatabase(this.dbName, this.dbVersion, this.dbName, 4500000);
            this.transaction(createRulesSql).done(function(){

            }).fail(this._throwError);
        },
        /**
         * Error handling. Emits a database error message to the rest of the sandbox.
         * TODO: possibly send this to a more generic handler?
         * @private
         */
        _throwError: function(){
            console.error('DATABASE ERROR:',arguments);
            //this.sandbox.emit('databaseError',arguments);
        }
    };


    /**
     * cordova mixins are loaded by feature, so they are essentially no-ops in browser, but have functionality on android
     */
    _.extend(Database.prototype,cordovaMixins);



    return Database;

});
/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

define('plugins/xml2json',[],function(){
    'use strict';

    function X2JS(config) {


        var VERSION = "1.1.2";

        config = config || {};
        initConfigDefaults();

        function initConfigDefaults() {
            if(config.escapeMode === undefined)
                config.escapeMode = true;
            if(config.attributePrefix === undefined)
                config.attributePrefix = "_";
            if(config.arrayAccessForm === undefined)
                config.arrayAccessForm = "none";
            if(config.emptyNodeForm === undefined)
                config.emptyNodeForm = "text";
        }

        var DOMNodeTypes = {
            ELEMENT_NODE 	   : 1,
            TEXT_NODE    	   : 3,
            CDATA_SECTION_NODE : 4,
            DOCUMENT_NODE 	   : 9
        };

        function getNodeLocalName( node ) {
            var nodeLocalName = node.localName;
            if(nodeLocalName == null) // Yeah, this is IE!!
                nodeLocalName = node.baseName;
            if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
                nodeLocalName = node.nodeName;
            return nodeLocalName;
        }

        function getNodePrefix(node) {
            return node.prefix;
        }

        function escapeXmlChars(str) {
            if(typeof(str) == "string")
                return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
            else
                return str;
        }

        function unescapeXmlChars(str) {
            return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, '\/');
        }

        function toArrayAccessForm(obj, childName) {
            switch(config.arrayAccessForm) {
                case "property":
                    if(!(obj[childName] instanceof Array))
                        obj[childName+"_asArray"] = [obj[childName]];
                    else
                        obj[childName+"_asArray"] = obj[childName];
                    break;
                /*case "none":
                 break;*/
            }
        }

        function parseDOMChildren( node ) {
            if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
                var result = new Object;
                var child = node.firstChild;
                var childName = getNodeLocalName(child);
                result[childName] = parseDOMChildren(child);
                return result;
            }
            else
            if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
                var result = new Object;
                result.__cnt=0;

                var nodeChildren = node.childNodes;

                // Children nodes
                for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                    var child = nodeChildren.item(cidx); // nodeChildren[cidx];
                    var childName = getNodeLocalName(child);

                    result.__cnt++;
                    if(result[childName] == null) {
                        result[childName] = parseDOMChildren(child);
                        toArrayAccessForm(result, childName);
                    }
                    else {
                        if(result[childName] != null) {
                            if( !(result[childName] instanceof Array)) {
                                result[childName] = [result[childName]];
                                toArrayAccessForm(result, childName);
                            }
                        }
                        var aridx = 0;
                        while(result[childName][aridx]!=null) aridx++;
                        (result[childName])[aridx] = parseDOMChildren(child);
                    }
                }

                // Attributes
                for(var aidx=0; aidx <node.attributes.length; aidx++) {
                    var attr = node.attributes.item(aidx); // [aidx];
                    result.__cnt++;
                    result[config.attributePrefix+attr.name]=attr.value;
                }

                // Node namespace prefix
                var nodePrefix = getNodePrefix(node);
                if(nodePrefix!=null && nodePrefix!="") {
                    result.__cnt++;
                    result.__prefix=nodePrefix;
                }

                if(result["#text"]!=null) {
                    result.__text = result["#text"];
                    if(result.__text instanceof Array) {
                        result.__text = result.__text.join("\n");
                    }
                    if(config.escapeMode)
                        result.__text = unescapeXmlChars(result.__text);
                    delete result["#text"];
                    if(config.arrayAccessForm=="property")
                        delete result["#text_asArray"];
                }
                if(result["#cdata-section"]!=null) {
                    result.__cdata = result["#cdata-section"];
                    delete result["#cdata-section"];
                    if(config.arrayAccessForm=="property")
                        delete result["#cdata-section_asArray"];
                }

                if( result.__cnt == 1 && result.__text!=null  ) {
                    result = result.__text;
                }
                else
                if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
                    result = '';
                }
                delete result.__cnt;

                if(result.__text!=null || result.__cdata!=null) {
                    result.toString = function() {
                        return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
                    };
                }
                return result;
            }
            else
            if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
                return node.nodeValue;
            }
        }

        function startTag(jsonObj, element, attrList, closed) {
            var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
            if(attrList!=null) {
                for(var aidx = 0; aidx < attrList.length; aidx++) {
                    var attrName = attrList[aidx];
                    var attrVal = jsonObj[attrName];
                    resultStr+=" "+attrName.substr(config.attributePrefix.length)+"='"+attrVal+"'";
                }
            }
            if(!closed)
                resultStr+=">";
            else
                resultStr+="/>";
            return resultStr;
        }

        function endTag(jsonObj,elementName) {
            return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
        }

        function endsWith(str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }

        function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
            if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray")))
                || jsonObjField.toString().indexOf(config.attributePrefix)==0
                || jsonObjField.toString().indexOf("__")==0
                || (jsonObj[jsonObjField] instanceof Function) )
                return true;
            else
                return false;
        }

        function jsonXmlElemCount ( jsonObj ) {
            var elementsCnt = 0;
            if(jsonObj instanceof Object ) {
                for( var it in jsonObj  ) {
                    if(jsonXmlSpecialElem ( jsonObj, it) )
                        continue;
                    elementsCnt++;
                }
            }
            return elementsCnt;
        }

        function parseJSONAttributes ( jsonObj ) {
            var attrList = [];
            if(jsonObj instanceof Object ) {
                for( var ait in jsonObj  ) {
                    if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
                        attrList.push(ait);
                    }
                }
            }
            return attrList;
        }

        function parseJSONTextAttrs ( jsonTxtObj ) {
            var result ="";

            if(jsonTxtObj.__cdata!=null) {
                result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";
            }

            if(jsonTxtObj.__text!=null) {
                if(config.escapeMode)
                    result+=escapeXmlChars(jsonTxtObj.__text);
                else
                    result+=jsonTxtObj.__text;
            }
            return result;
        }

        function parseJSONTextObject ( jsonTxtObj ) {
            var result ="";

            if( jsonTxtObj instanceof Object ) {
                result+=parseJSONTextAttrs ( jsonTxtObj );
            }
            else
            if(jsonTxtObj!=null) {
                if(config.escapeMode)
                    result+=escapeXmlChars(jsonTxtObj);
                else
                    result+=jsonTxtObj;
            }

            return result;
        }

        function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {
            var result = "";
            if(jsonArrRoot.length == 0) {
                result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
            }
            else {
                for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
                    result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
                    result+=parseJSONObject(jsonArrRoot[arIdx]);
                    result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
                }
            }
            return result;
        }

        function parseJSONObject ( jsonObj ) {
            var result = "";

            var elementsCnt = jsonXmlElemCount ( jsonObj );

            if(elementsCnt > 0) {
                for( var it in jsonObj ) {

                    if(jsonXmlSpecialElem ( jsonObj, it) )
                        continue;

                    var subObj = jsonObj[it];

                    var attrList = parseJSONAttributes( subObj )

                    if(subObj == null || subObj == undefined) {
                        result+=startTag(subObj, it, attrList, true);
                    }
                    else
                    if(subObj instanceof Object) {

                        if(subObj instanceof Array) {
                            result+=parseJSONArray( subObj, it, attrList );
                        }
                        else {
                            var subObjElementsCnt = jsonXmlElemCount ( subObj );
                            if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
                                result+=startTag(subObj, it, attrList, false);
                                result+=parseJSONObject(subObj);
                                result+=endTag(subObj,it);
                            }
                            else {
                                result+=startTag(subObj, it, attrList, true);
                            }
                        }
                    }
                    else {
                        result+=startTag(subObj, it, attrList, false);
                        result+=parseJSONTextObject(subObj);
                        result+=endTag(subObj,it);
                    }
                }
            }
            result+=parseJSONTextObject(jsonObj);

            return result;
        }

        this.parseXmlString = function(xmlDocStr) {
            if (xmlDocStr === undefined) {
                return null;
            }
            var xmlDoc;
            if (window.DOMParser) {
                var parser=new window.DOMParser();
                xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
            }
            else {
                // IE :(
                if(xmlDocStr.indexOf("<?")==0) {
                    xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
                }
                xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async="false";
                xmlDoc.loadXML(xmlDocStr);
            }
            return xmlDoc;
        };

        this.asArray = function(prop) {
            if(prop instanceof Array)
                return prop;
            else
                return [prop];
        }

        this.xml2json = function (xmlDoc) {
            return parseDOMChildren ( xmlDoc );
        };

        this.xml_str2json = function (xmlDocStr) {
            var xmlDoc = this.parseXmlString(xmlDocStr);
            return this.xml2json(xmlDoc);
        };

        this.json2xml_str = function (jsonObj) {
            return parseJSONObject ( jsonObj );
        };

        this.json2xml = function (jsonObj) {
            var xmlDocStr = this.json2xml_str (jsonObj);
            return this.parseXmlString(xmlDocStr);
        };

        this.getVersion = function () {
            return VERSION;
        };

    }

    return X2JS;

});


/** a common API for devices and the browser. the browser version returns mock data for testing, will be used as part of an extension to mixin with the sandbox  **/
define('features/dataInterface/android',['feature!database', 'feature!appSettings', 'feature!cordova', 'plugins/xml2json'], function(Database, appSettings, cordovaMixins, XJ) {
    'use strict';

    var dataInterface = function() {};
    var timeout = setTimeout(function() {}, 0);

    /**
     * parses device data to proper format for cloud
     * @param options:model {Backbone Model} - the model for the device
     * @param options:parsedData {JSON} - data being sent to cloud, already packaged for specific action
     * @returns {JSON}
     */
    function parseDataToRemote(options) {
        DEBUG && console.log('REMOTE: PARSING DATA');
        var x = new XJ();
        var parsedData = {
            plugins: {
                plugin: {
                    recipientId: '',
                    macAddress: options.model.get('macAddress'),
                    content: {
                        __cdata: x.json2xml_str(options.parsedData)
                    }
                }
            }
        }
        return x.json2xml_str(parsedData);
    }

    function xmlToString($xmlObj) {
        var xmlString = "";
        $xmlObj.children().each(function() {
            xmlString += "<" + this.nodeName + ">";
            if ($(this).children().length > 0) {
                xmlString += xmlToString($(this));
            } else
                xmlString += $(this).text();
            xmlString += "</" + this.nodeName + ">";
        });
        return xmlString;
    }

    //var database = new Database();

    dataInterface.prototype.devicePlugin = {
        /**
         * sees if we are on a remote connection, and sets a timeout to fetch.
         * @param  {Backbone.Model} model the model for the device
         * @return {deferred}       promise
         */
        checkIfRemote: function(model) {

            var self = this;
            return $.Deferred(function(dfd) {

                $.when(self.isRemoteEnabled(), self.getNetworkType())
                    .then(function(isRemoteEnabled, networkType) {
                        DEBUG && console.log('DATAINTERFACE:CHECKING IF REMOTE:isRemoteEnabled=' + isRemoteEnabled + ':networkType=' + networkType);
                        if (isRemoteEnabled && networkType.match(/remote/gi)) {
                            model.isRemoteEnabled = true;
                        } else {
                            model.isRemoteEnabled = false;
                        }
                        if (model.fetchInterval) {
                            clearInterval(model.fetchInterval);
                        }

                        DEBUG && console.log('DATAINTERFACE:CHECKING IF REMOTE:SETTING INTERVAL');
                        /** need interval fetch for crockpot in all cases, due to faulty FW on release */
                        if (model.isRemoteEnabled || model.get('udn').match(/Crockpot/i)) {
                            model.fetchInterval = setInterval(function() {
                                DEBUG && console.log('DATAINTERFACE:CHECKING IF REMOTE:INTERVAL FETCH');
                                model.fetch();
                            }, 60000);
                        }
                        dfd.resolve(model.isRemoteEnabled);

                    }).fail(function() {
                        alert('failed');
                        dfd.reject();
                    });

            }).promise();

        },
        /**
         * gets the most basic device information.
         * @callback callback [callback] - optional callback
         * @param model {Backbone Model} - the device's model
         * @returns {JQueryDeferred}
         */
        getBaseDevice: function(callback, model) {
            var self = this;
            /* different from dataInterface/browser.js, because we already have this data from devicelist on Android, and it can't be edited while remote */
            if (model.isRemoteEnabled) {
                return $.Deferred(function(dfd) {
                    DEBUG && console.log('REMOTE GET BASE DEVICE SUCCESS');
                    if (callback) {
                        callback({});
                    }
                    dfd.resolve({});
                }).promise();
            } else {
                /** return the deferred **/
                return $.Deferred(function(dfd) {

                    function callMeMaybe(resp) {

                        if (typeof resp === 'string') {
                            dfd.reject(resp);
                        } else {
                            console.log('GET BASE DEVICE', resp)
                            if (callback) {
                                callback(resp);
                            }
                            dfd.resolve(resp);
                        }
                    }

                    cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'getDevice', [model.get('udn')]);

                }).promise();
            }
        },
        setDevice: function(callback, model, data) {
            var options = {
                model: model,
                command: model.setCommand,
                data: data,
                callback: callback
            }

            return this.callAction(options);
        },
        getDevice: function(callback, model, options) {
            var self = this;

            var dfd = $.Deferred();
            var done = function(resp) {
                // DEBUG && console.log('DATAINTERFACE:REMOTE GET DEVICE SUCCESS:' + JSON.stringify(resp));

                dfd.resolve(resp);
            };

            var fail = function(resp) {
                // DEBUG && console.log('DATAINTERFACE:REMOTE GET DEVICE FAIL:' + JSON.stringify(resp));
                dfd.reject(resp);
                //window.app.events.emit('error', resp);
            };

            var callActionOptions = {
                model: model,
                command: model.getCommand,
                callback: callback,
                data: {}
            };

            $.when(this.isRemoteEnabled(), this.getNetworkType())
                .then(function(isRemoteEnabled, networkType) {
                    DEBUG && console.log('REMOTE ENABLED:' + isRemoteEnabled + ':NETWORK TYPE:' + networkType);
                    if (isRemoteEnabled && networkType.match(/remote/gi)) {
                        model.isRemoteEnabled = true;
                    } else {
                        model.isRemoteEnabled = false;
                    }

                    if (!options.getBaseDevice || (model.isRemoteEnabled && !model.hasRules)) {
                        $.when(
                            dataInterface.prototype.devicePlugin.callAction(callActionOptions)
                        ).done(done).fail(fail);
                    } else if (!model.hasRules) {
                        $.when(
                            dataInterface.prototype.devicePlugin.getBaseDevice(callback, model)
                        ).done(done).fail(fail);
                    } else {
                        $.when(
                            dataInterface.prototype.devicePlugin.getBaseDevice(callback, model),
                            dataInterface.prototype.devicePlugin.callAction(callActionOptions)
                        ).then(function() {
                            dataInterface.prototype.devicePlugin.fetchRules(callback, model, {});
                        }).done(done).fail(fail);
                    }

                });
            return dfd.promise();
        },

        /**
         * is used for much of the device interation. calls made to this can be 'get' or 'set', through getDevice or setDevice
         * @param options {Object} - options for the callAction method
         * @param options:model {Backbone Model} - the model calling the action
         * @param options:command {string} - the set or get command for the model
         * @param options:data {JSON} - data being saved to the device
         * @callback options:callback [callback] - an optional callback function
         * @returns {JQueryDeferred}
         */
        callAction: function(options) {
            var self = this;
            return $.when(this.isRemoteEnabled(), this.getNetworkType())
                .then(function(isRemoteEnabled, networkType) {
                    if (isRemoteEnabled && networkType.match(/remote/gi)) {
                        return self._callActionRemote(options);
                    } else {
                        return self._callActionLocal(options);
                    }
                });
        },
        _callActionLocal: function(options) {
            var self = this;
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    if (typeof resp === 'string') {
                        DEBUG && console.log('DATAINTERFACE:callActionLocal:ERROR');
                        clearTimeout(options.model.callActionTimeout);

                        if (options.model.callActionRetry < 1) {
                            options.model.trigger('loseConnection', false);
                            options.model.callActionTimeout = setTimeout(function() {
                                options.model.callActionRetry++;
                                self._callActionLocal(options);
                            }, 15000);
                        } else {
                            options.model.callActionRetry = 0;
                            options.model.trigger('syncError', 'callActionLocal');
                            options.model.trigger('loseConnection', true);
                            dfd.reject(resp);


                            // Trigger event to check for FW upgrade when devices are in Not-Detected state
                            if (window.devicelistEvents) {
                                window.devicelistEvents.emit('checkFirmware', {
                                    udn: options.model.id
                                })
                            }
                        }

                    } else {
                        options.model.callActionRetry = 0;
                        options.model.trigger('loseConnection', true);
                        DEBUG && console.log('DATAINTERFACE:callActionLocal:SUCCESS:' + JSON.stringify(resp));
                        /* if (_.size(resp) === 0) {
                         options.model.trigger('syncError');
                         dfd.reject(resp);
                         } else {*/
                        //clearTimeout(options.model.callActionTimeout);
                        if (options.callback) {
                            options.callback(resp);
                        }

                        dfd.resolve(resp);
                        // }
                    }
                }

                DEBUG && console.log('DATAINTERFACE:callActionLocal:sending');
                /* set a timeout. it should not take more than 5 seconds for this thing to come back */
                /*options.model.callActionTimeout = setTimeout(function() {
                 options.model.trigger('syncError');
                 dfd.reject('ERROR: TIMEOUT');
                 //try again
                 setTimeout(function() {
                 options.model.fetch();
                 }, 15000);

                 }, 15000);*/
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [options.model.get('udn'), options.model.eventService, options.command, {
                    data: options.data
                }]);


            }).promise();
        },
        _callActionRemote: function(options) {
            var self = this;
            var baseData = {};
            var finalData;
            var data = {
                plugin: options.data
            };

            var tempAttributes = {};

            DEBUG && console.log('REMOTE: options model?' + options.model + ':options command?' + options.command);
            console.log(options.model);

            if (options.model && options.model.mapToRemote) {
                data.plugin = options.model.mapToRemote(data.plugin);
            }

            if (options.model.setCommand === 'SetAttributes') {
                _.each(data.plugin, function(value, key) {
                    if (options.model.validation[key]) {
                        tempAttributes[key] = value;
                    }
                });

                delete data.plugin;
                data.plugin = {
                    attributeLists: {
                        _action: 'SetAttributes',
                        attribute: []
                    }
                }

                _.each(tempAttributes, function(value, key) {
                    data.plugin.attributeLists.attribute.push({
                        name: key,
                        value: value
                    });
                })

            }

            data.plugin.pluginId = options.model.get('pluginId');
            data.plugin.macAddress = options.model.get('macAddress');

            DEBUG && console.log('REMOTE: call action data?' + JSON.stringify(data) + " mac: " + (data.plugin.macAddress));
            var isGet = false;
            if (options.command.match(/set/i)) {
                baseData = {
                    pluginSetDeviceStatus: data
                };
            } else {
                isGet = true;
                baseData = {
                    pluginDeviceStatus: data
                };
            }

            if (data.plugin.BinaryState !== undefined && !isGet) {
                data.plugin.status = data.plugin.BinaryState;
                delete data.plugin.BinaryState;
            }

            options.parsedData = baseData;
            finalData = parseDataToRemote(options);

            console.log('REMOTE FINAL DATA:' + JSON.stringify(finalData) + " isGet: " + isGet);


            return $.Deferred(function(dfd) {

                var callMeMaybe = function(resp) {

                    DEBUG && console.log('REMOTE CALL ACTION SUCCESS:' + resp + " status: " + ($(resp).find('status').text()));

                    if (parseInt($(resp).find('status').text(), 10) === 3) {
                        options.model.trigger('syncError', 'callActionRemote');
                        dfd.reject(resp);
                    } else {
                        if (options.callback) {
                            options.callback(resp);
                        }
                        dfd.resolve(resp);
                    }
                };

                var dontCallMe = function(err) {
                    options.model.trigger('syncError', 'callActionRemote');
                    console.log('REMOTE CALL ACTION ERROR:' + err);
                    dfd.reject(err);
                };
                var mac = data.plugin.macAddress;
                //Added following if block for leveraging cloud response already polled by the main app
                if (isGet && remoteResult != undefined && remoteResult != null) {
                    $(remoteResult).find('device').each(function(i) {
                        var tmac = $(this).find("macAddress").text();
                        if (tmac == mac) {
                            if ($(this).find('modelCode').text().match(/insight/i)) {

                                var macInsight = $(this).find('macAddress').text(),
                                    pluginId = $(this).find('pluginId').text(),
                                    xmlString = '<plugins><plugin>' +
                                    '<recipientId>' + pluginId + '</recipientId><macAddress>' + macInsight + '</macAddress>' + '<content>' +
                                    '<![CDATA[<getPluginDetails><plugin><macAddress>' + macInsight + '</macAddress></plugin></getPluginDetails>]]>' +
                                    '</content></plugin></plugins>',
                                    insight = this;

                                self.getAuthorizationCode().then(function(resp) {
                                    $.ajax({
                                        url: appSettings.cloudIpAddress + '/apis/http/plugin/insight/message',
                                        data: xmlString,
                                        type: "POST",
                                        beforeSend: function(xhr) {
                                            xhr.setRequestHeader('Content-Type', 'application/xml');
                                            xhr.setRequestHeader('Authorization', resp[0]);
                                        },
                                        success: function(data) {
                                            var fName = $(insight).find('friendlyName').text()
                                            fAttrList = xmlToString($(insight).find('attributeLists')),
                                            pluginXML = '<plugins><plugin>' + '<macAddress>' + $(data).find('macAddress').text() + '</macAddress>' +
                                                '<recipientId>' + $(data).find('pluginId').text() + '</recipientId>' + '<friendlyName>' + fName + '</friendlyName>' +
                                                '<status>' + $(data).find('status').text() + '</status>' + '<BinaryState>' + $(data).find('status').text() + '</BinaryState>' +
                                                '<refreshTimer>' + $(data).find('refreshTimer').text() + '</refreshTimer>' + '<dayOfConsumption>' + $(data).find('dayOfConsumption').text() + '</dayOfConsumption>' +
                                                '<powerNow>' + $(data).find('instantaneousPower').text() + '</powerNow>' + '<tttOn>' + $(data).find('todayTotalTimeOn').text() + '</tttOn>' +
                                                '<hrsConnected>' + $(data).find('timeConnected').text() + '</hrsConnected>' + '<stateChangeTS>' + $(data).find('stateChangeTS').text() + '</stateChangeTS>' +
                                                '<avgPowerON>' + $(data).find('avgPowerON').text() + '</avgPowerON>' + '<powerThreshold>' + $(data).find('powerThreshold').text() + '</powerThreshold>' +
                                                '<todayTotalKwh>' + $(data).find('todayTotalKWH').text() + '</todayTotalKwh>' + '<onFor>' + $(data).find('lastONFor').text() + '</onFor>' +
                                                '<past14DaysKwh>' + $(data).find('past14DaysKWH').text() + '</past14DaysKwh>' + '<past14TotalTime>' + $(data).find('past14TotalTime').text() + '</past14TotalTime>' +
                                                '<EnergyPerUnitCost>' + $(data).find('energyPerUnitCost').text() + '</EnergyPerUnitCost>' + '<Currency>' + $(data).find('currency').text() + '</Currency>' +
                                                '<attributeLists>' + fAttrList + '</attributeLists></plugin></plugins>';

                                            DEBUG && console.log('REMOTE pluginXML from device_list::' + pluginXML);
                                            callMeMaybe($.parseXML(pluginXML));
                                        },
                                        error: function() {
                                            DEBUG && console.log('REMOTE: ERROR:');
                                            dontCallMe(arguments);
                                        }
                                    });

                                });

                            } else {
                                var fName = $(this).find('friendlyName').text(),
                                    fAttrList = xmlToString($(this).find('attributeLists')),
                                    pluginXML = '<plugins><plugin><recipientId>' + $(this).find('pluginId').text() + '</recipientId><macAddress>' + $(this).find('macAddress').text() + '</macAddress>' +
                                    '<status>' + $(this).find('status').text() + '</status><BinaryState>' + $(this).find('status').text() + '</BinaryState><statusTS>' + $(this).find('statusTS').text() + '</statusTS><dbVersion>' + $(this).find('dbVersion').text() + '</dbVersion>' +
                                    '<friendlyName>' + fName + '</friendlyName><rOverriden/><modelCode>' + $(this).find('modelCode').text() + '</modelCode>' +
                                    '<firmwareVersion>' + $(this).find('firmwareVersion').text() + '</firmwareVersion><signalStrength>' + $(this).find('signalStrength').text() + '</signalStrength>' +
                                    '<fwUpgradeStatus>' + $(this).find('fwUpgradeStatus').text() + '</fwUpgradeStatus><eventDuration>' + $(this).find('eventDuration').text() + '</eventDuration>' +
                                    '<cookedTime>' + $(this).find('cookedTime').text() + '</cookedTime><attributeLists>' + fAttrList + '</attributeLists></plugin></plugins>';
                                DEBUG && console.log('REMOTE pluginXML from device_list::' + pluginXML);
                                callMeMaybe($.parseXML(pluginXML));
                            }

                        }



                    });
                } else {
                    self.getAuthorizationCode().then(function(resp) {
                        DEBUG && console.log('REMOTE:' + JSON.stringify(resp) + ':CLOUD IP:' + appSettings.cloudIpAddress + 'PK:' + resp[0]);
                        $.ajax({
                            url: appSettings.cloudIpAddress + '/apis/http/plugin/message',
                            type: 'POST',
                            data: finalData,
                            beforeSend: function(xhr) {
                                xhr.setRequestHeader('Content-Type', 'application/xml');
                                xhr.setRequestHeader('Authorization', resp[0]);
                            },
                            success: function(data) {
                                DEBUG && console.log('REMOTE: SUCCESS:' + data);
                                callMeMaybe(data);
                            },
                            error: function() {
                                DEBUG && console.log('REMOTE: ERROR:');
                                dontCallMe(arguments);
                            }
                        });

                    });

                }
            }).promise();
        },

        /**
         * is used for Blob storage. calls . Can be 'get' or 'set', through getBlobStorage or setBlobStorage
         * @param options {Object} - options for the blobStorage method
         * @param options:model {Backbone Model} - the model calling the action
         * @param options:action {string} - the set or get command for the model
         * @param options:data {JSON} - data being saved to the device
         * @callback options:callback [callback] - an optional callback function
         * @returns {JQueryDeferred}
         */
        blobStorage: function(options) {
            var self = this;
            return $.when(this.isRemoteEnabled(), this.getNetworkType())
                .then(function(isRemoteEnabled, networkType) {
                    if (isRemoteEnabled && networkType.match(/remote/gi)) {
                        return self._blobStorageRemote(options);
                    } else {
                        return self._blobStorageLocal(options);
                    }
                });
        },
        _blobStorageLocal: function(options) {
            var self = this;
            return $.Deferred(function(dfd) {
                function callMeMaybe(resp) {
                    if (typeof resp === 'string') {
                        dfd.reject(resp);
                    } else {
                        DEBUG && console.log('RESPONSE FROM GetBlobStorage:' + JSON.stringify(resp));
                        if (options.action.match(/get/i) && options.callback) {
                            //for backward compatibility with older air purifiers
                            if (isNaN(resp.FilterType)) {
                                options.callback(resp.filterType);
                            } else {
                                options.callback(resp.FilterType);
                            }
                        }
                        dfd.resolve(resp);
                    }
                }
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', options.action, [options.model.get('udn'), null, options.action, {
                    data: options.data
                }]);
            }).promise();
        },
        _blobStorageRemote: function(options) {
            DEBUG && console.log("In _blobStorageRemote");
            var self = this;
            DEBUG && console.log('REMOTE: options model: ' + JSON.stringify(options.model) + ' REMOTE: data: ' + JSON.stringify(options.data) + ' options action: ' + options.action);
            var isGet = false,
                action = "setBlobStorage";
            if (options.action.match(/get/i)) {
                isGet = true;
                action = "getBlobStorage";
            }
            var pluginXML = "<plugins><plugin><recipientId>" + options.model.get('plugId') + "</recipientId><macAddress>" + options.model.get('macAddress') + "</macAddress><content><![CDATA[<" + action + "><plugin><pluginId>" + options.model.get('plugId') + "</pluginId><macAddress>" + options.model.get('macAddress') + "</macAddress><attributeLists action = \"" + options.action + "\"><attribute><name>FilterType</name><value>" + options.data.FilterType + "</value></attribute></attributeLists></plugin></" + action + ">]]></content></plugin></plugins>";
            DEBUG && console.log('REMOTE pluginXML from BlobStorage::' + pluginXML);
            return $.Deferred(function(dfd) {
                var callMeMaybe = function(resp) {
                    DEBUG && console.log('REMOTE BLOB STORAGE SUCCESS: RESPONSE: ' + resp + " STATUS: " + ($(resp).find('status').text()));
                    if (parseInt($(resp).find('status').text(), 10) === 3) {
                        options.model.trigger('syncError', 'blobStorageRemote');
                        dfd.reject(resp);
                    } else {
                        DEBUG && console.log("Remote Blob Storage success Response: " + resp);
                        var filterType;
                        if (options.action.match(/get/i) && options.callback) {
                            var result = (new XMLSerializer().serializeToString(resp));
                            DEBUG && console.log("Remote Blob Storage result: " + result);
                            $(result).find('attribute').each(function(i) {
                                var name = $(this).find("name").text();
                                if (name == "FilterType") {
                                    filterType = parseInt($(this).find("value").text(), 10);
                                }
                            });
                            DEBUG && console.log("Remote Blob Storage response, filterType: " + filterType);
                            options.callback(filterType);
                        }
                        dfd.resolve(resp);
                    }
                };
                var dontCallMe = function(err) {
                    options.model.trigger('syncError', 'blobStorageRemote');
                    DEBUG && console.log('REMOTE BLOB CALL ERROR: ' + err);
                    dfd.reject(err);
                };
                self.getAuthorizationCode().then(function(resp) {
                    DEBUG && console.log('REMOTE: ' + JSON.stringify(resp) + ' CLOUD IP: ' + appSettings.cloudIpAddress + ' PK: ' + resp[0]);
                    $.ajax({
                        url: appSettings.cloudIpAddress + '/apis/http/plugin/message',
                        type: 'POST',
                        data: pluginXML,
                        beforeSend: function(xhr) {
                            xhr.setRequestHeader('Content-Type', 'application/xml');
                            xhr.setRequestHeader('Authorization', resp[0]);
                        },
                        success: function(data) {
                            DEBUG && console.log('REMOTE: SUCCESS: ' + (new XMLSerializer().serializeToString(data)));
                            callMeMaybe(data);
                        },
                        error: function() {
                            DEBUG && console.log('REMOTE: ERROR');
                            dontCallMe(arguments);
                        }
                    });
                });
            }).promise();
        },

        sendRemoteMessage: function(message, argsObj, callback) {
            cordova.exec(callback, callback, 'WeMoSMARTDevicePlugin', 'sendRemoteMessage', [message, argsObj]);
        },

        fetchRules: function(callback, model) {

            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    if (typeof resp === 'string') {
                        dfd.reject(resp);
                    } else {
                        dfd.resolve(resp);
                        if (callback) {
                            callback(resp);
                        }
                    }

                }

                // cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', model.rulesUrl, []);
                database.getRules({
                    callback: callMeMaybe,
                    errorCallback: callMeMaybe,
                    id: model.get('udn'),
                    model: model
                });

            }).promise();

        },
        updateRuleAndCalendar: function(rule, string, callback, model) {
            /* this way, we only add it to the database if it goes into the device first */
            return dataInterface.prototype.devicePlugin.updateWeeklyCalendar(string, callback, model).then(function() {
                dataInterface.prototype.devicePlugin.updateRule(rule, callback, model);
            }).done(function() {
                model.trigger('saveRule');
            }).fail(function(resp) {
                window.app.events.emit('error', resp);
            });

        },

        updateRule: function(rule, callback, model) {

            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    if (typeof resp === 'string') {
                        dfd.reject(resp);
                    } else {
                        dfd.resolve(resp);
                        if (callback) {
                            callback(resp);
                        }
                    }
                }

                database.updateRule({
                    rule: rule,
                    callback: callMeMaybe,
                    errorCallback: callMeMaybe,
                    id: model.get('udn'),
                    model: model
                });

                //    cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', model.rulesUrl, [rule]);


            }).promise();

        },

        updateWeeklyCalendar: function(string, callback, model) {

            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    if (typeof resp === 'string') {
                        dfd.reject(resp);
                    } else {
                        dfd.resolve(resp);
                        if (callback) {
                            callback(resp);
                        }
                    }
                }

                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', model.url, [model.get('udn'), 'urn:Belkin:service:rules:1', 'UpdateWeeklyCalendar', string]);


            }).promise();

        },

        subscribeDeviceChange: function(callback, model) {
            var self = this;
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    if (typeof resp === 'string') {
                        dfd.reject(resp);
                    } else {
                        clearTimeout(timeout);
                        if (!model.subscriptionChanges) {
                            model.subscriptionChanges = {};
                        }

                        DEBUG && console.log('ANDROID:DATAINTERFACE:DEVICE SUBSCRIPTION:received device change:' + JSON.stringify(resp));

                        var value = resp.state;
                        var key = resp.notifyType;

                        if (typeof resp.attributeList === "object") {
                            var jsonObj = resp.attributeList;
                            $.each(jsonObj, function(key, val) {
                                model.subscriptionChanges[key] = val;
                            });
                        } else if (typeof resp.attributeList === "string") {
                            var jsonObj = JSON.parse(resp.attributeList);
                            $.each(jsonObj, function(key, val) {
                                model.subscriptionChanges[key] = val.value;
                            });
                        } else {
                            model.subscriptionChanges[key] = value;
                        }

                        timeout = setTimeout(function() {
                            DEBUG && console.log('ANDROID:DATAINTERFACE:DEVICE SUBSCRIPTION:MODEL SAVING:' + JSON.stringify(model.subscriptionChanges));
                            var oldModel = new Backbone.Model();
                            oldModel.set(model.attributes);
                            model.set(model.subscriptionChanges);
                            delete model.subscriptionChanges;
                            self.checkIfRemote(model); //reset the interval
                            model.saveToCache().then(function() {
                                // self.notifyUserEvent('save', model);
                                DEBUG && console.log('TIMER:SYNC:FROM SUBSCRIPTION');
                                model.trigger('syncFromSubscription', oldModel, model);

                            });

                            dfd.resolve(resp);
                        }, 100);


                        //model.trigger('changePushedFromDevice');
                    }
                }

                DEBUG && console.log('ANDROID: DATAINTERFACE: SUBSCRIBING TO DEVICE CHANGE');
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'subscribeDeviceChange', [model.get('udn')]);


            }).promise();

        },

        unsubscribeDeviceChange: function(model) {
            cordova.exec(null, null, 'WeMoSMARTDevicePlugin', 'subscribeDeviceChange', [model.get('udn')]);
        },
        subscribeUserEvents: function(callback, model) {
            console.log('Android event subscription is a no-op');
        },
        notifyUserEvent: function(event, model) {
            model = model || this;
            DEBUG && console.log('EVENT: triggering nativeUserEvent:' + event);
            model.trigger('nativeUserEvent', event);
        },
        cloudInterface: function(xml, callback, model) {

            /* first get an auth code, then do some ajax, then do something else */
            $.when(this.getAuthorizationCode()).then(function(authCode) {
                return $.ajax({
                    beforeSend: function(xhr) {
                        xhr.setRequestHeader('Content-Type', 'application/xml');
                        xhr.setRequestHeader('Authorization', authCode);
                    },
                    type: 'post',
                    data: xml,
                    url: model.cloudUrl //maybe have this as an object with multiple urls, depending on call.
                });
            }).done(function(authCode, resp) {
                if (callback) {
                    callback(resp);
                }
            }).fail(function(resp) {
                window.app.events.emit('error', resp);
            });
        },
        getAuthorizationCode: function() {
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    if (_.isArray(resp)) {
                        dfd.resolve(resp);
                    } else {
                        dfd.reject(resp);
                    }

                }

                cordova.exec(callMeMaybe, callMeMaybe, 'WebServicePlugin', 'getAuthCode', []);

            }).promise();

        }
    };

    dataInterface.prototype.firmwareUpdate = {
        getAvailableRemoteUpdates: function(deviceList) {

            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    dfd.resolve(resp);
                }

                if (window.cordova) {
                    window.cordova.exec(callMeMaybe, callMeMaybe, 'FirmwareupdatePlugin', 'getAvailableRemoteUpdates', [deviceList]);
                } else {
                    callMeMaybe([{
                        UDN: 'test'
                    }]);
                }

            }).promise();
        },
        getAvailableUpdates: function() {

            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    dfd.resolve(resp);
                }

                if (window.cordova) {
                    window.cordova.exec(callMeMaybe, callMeMaybe, 'FirmwareupdatePlugin', 'getAvailableUpdates', []);
                } else {
                    callMeMaybe([{
                        UDN: 'test'
                    }]);
                }

            }).promise();
        },
        doFirmwareUpdate: function() {
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    dfd.resolve(resp);
                }

                function dontCallMe(resp) {
                    dfd.reject(resp);
                }

                if (window.cordova) {
                    window.cordova.exec(callMeMaybe, dontCallMe, 'FirmwareupdatePlugin', 'doUpdate', []);
                } else {
                    callMeMaybe();
                }

            }).promise();
        },
        getFirmwareUpdateReleaseNotes: function() {
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    dfd.resolve(resp);
                }

                if (window.cordova) {
                    window.cordova.exec(callMeMaybe, callMeMaybe, 'FirmwareupdatePlugin', 'getReleaseNotes', []);
                } else {
                    callMeMaybe('notes');
                }

            }).promise();

        }
    }
    _.extend(dataInterface.prototype.devicePlugin, cordovaMixins);


    return dataInterface;

});

! function(e) {
    if ("object" == typeof exports) module.exports = e();
    else if ("function" == typeof define && define.amd) define('pouchDB',e);
    else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.PouchDB = e()
    }
}(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'")
                }
                var f = n[o] = {
                    exports: {}
                };
                t[o][0].call(f.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, f, f.exports, e, t, n, r)
            }
            return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    })({
        1: [
            function(_dereq_, module, exports) {
                "use strict";

                var utils = _dereq_('./utils');
                var merge = _dereq_('./merge');
                var errors = _dereq_('./deps/errors');
                var EventEmitter = _dereq_('events').EventEmitter;

                /*
                 * A generic pouch adapter
                 */

                // returns first element of arr satisfying callback predicate
                function arrayFirst(arr, callback) {
                    for (var i = 0; i < arr.length; i++) {
                        if (callback(arr[i], i) === true) {
                            return arr[i];
                        }
                    }
                    return false;
                }

                // Wrapper for functions that call the bulkdocs api with a single doc,
                // if the first result is an error, return an error
                function yankError(callback) {
                    return function(err, results) {
                        if (err || results[0].error) {
                            callback(err || results[0]);
                        } else {
                            callback(null, results[0]);
                        }
                    };
                }

                // for every node in a revision tree computes its distance from the closest
                // leaf
                function computeHeight(revs) {
                    var height = {};
                    var edges = [];
                    merge.traverseRevTree(revs, function(isLeaf, pos, id, prnt) {
                        var rev = pos + "-" + id;
                        if (isLeaf) {
                            height[rev] = 0;
                        }
                        if (prnt !== undefined) {
                            edges.push({
                                from: prnt,
                                to: rev
                            });
                        }
                        return rev;
                    });

                    edges.reverse();
                    edges.forEach(function(edge) {
                        if (height[edge.from] === undefined) {
                            height[edge.from] = 1 + height[edge.to];
                        } else {
                            height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
                        }
                    });
                    return height;
                }

                utils.inherits(AbstractPouchDB, EventEmitter);
                module.exports = AbstractPouchDB;

                function AbstractPouchDB() {
                    var self = this;
                    EventEmitter.call(this);
                    self.autoCompact = function(callback) {
                        if (!self.auto_compaction) {
                            return callback;
                        }
                        return function(err, res) {
                            if (err) {
                                callback(err);
                            } else {
                                var count = res.length;
                                var decCount = function() {
                                    count--;
                                    if (!count) {
                                        callback(null, res);
                                    }
                                };
                                res.forEach(function(doc) {
                                    if (doc.ok) {
                                        // TODO: we need better error handling
                                        self.compactDocument(doc.id, 1, decCount);
                                    } else {
                                        decCount();
                                    }
                                });
                            }
                        };
                    };

                    var listeners = 0,
                        changes;
                    var eventNames = ['change', 'delete', 'create', 'update'];
                    this.on('newListener', function(eventName) {
                        if (~eventNames.indexOf(eventName)) {
                            if (listeners) {
                                listeners++;
                                return;
                            } else {
                                listeners++;
                            }
                        } else {
                            return;
                        }
                        var lastChange = 0;
                        changes = this.changes({
                            conflicts: true,
                            include_docs: true,
                            continuous: true,
                            since: 'latest',
                            onChange: function(change) {
                                if (change.seq <= lastChange) {
                                    return;
                                }
                                lastChange = change.seq;
                                self.emit('change', change);
                                if (change.doc._deleted) {
                                    self.emit('delete', change);
                                } else if (change.doc._rev.split('-')[0] === '1') {
                                    self.emit('create', change);
                                } else {
                                    self.emit('update', change);
                                }
                            }
                        });
                    });
                    this.on('removeListener', function(eventName) {
                        if (~eventNames.indexOf(eventName)) {
                            listeners--;
                            if (listeners) {
                                return;
                            }
                        } else {
                            return;
                        }
                        changes.cancel();
                    });
                }

                AbstractPouchDB.prototype.post = utils.adapterFun('post', function(doc, opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    if (typeof doc !== 'object' || Array.isArray(doc)) {
                        return callback(errors.NOT_AN_OBJECT);
                    }
                    return this.bulkDocs({
                            docs: [doc]
                        }, opts,
                        this.autoCompact(yankError(callback)));
                });

                AbstractPouchDB.prototype.put = utils.adapterFun('put', utils.getArguments(function(args) {
                    var temp, temptype, opts, callback;
                    var doc = args.shift();
                    var id = '_id' in doc;
                    if (typeof doc !== 'object' || Array.isArray(doc)) {
                        callback = args.pop();
                        return callback(errors.NOT_AN_OBJECT);
                    }
                    doc = utils.extend(true, {}, doc);
                    while (true) {
                        temp = args.shift();
                        temptype = typeof temp;
                        if (temptype === "string" && !id) {
                            doc._id = temp;
                            id = true;
                        } else if (temptype === "string" && id && !('_rev' in doc)) {
                            doc._rev = temp;
                        } else if (temptype === "object") {
                            opts = temp;
                        } else if (temptype === "function") {
                            callback = temp;
                        }
                        if (!args.length) {
                            break;
                        }
                    }
                    opts = opts || {};
                    var error = utils.invalidIdError(doc._id);
                    if (error) {
                        return callback(error);
                    }
                    return this.bulkDocs({
                            docs: [doc]
                        }, opts,
                        this.autoCompact(yankError(callback)));
                }));

                AbstractPouchDB.prototype.putAttachment = utils.adapterFun('putAttachment', function(docId, attachmentId, rev, blob, type, callback) {
                    var api = this;
                    if (typeof type === 'function') {
                        callback = type;
                        type = blob;
                        blob = rev;
                        rev = null;
                    }
                    if (typeof type === 'undefined') {
                        type = blob;
                        blob = rev;
                        rev = null;
                    }

                    function createAttachment(doc) {
                        doc._attachments = doc._attachments || {};
                        doc._attachments[attachmentId] = {
                            content_type: type,
                            data: blob
                        };
                        api.put(doc, callback);
                    }

                    api.get(docId, function(err, doc) {
                        // create new doc
                        if (err && err.error === errors.MISSING_DOC.error) {
                            createAttachment({
                                _id: docId
                            });
                            return;
                        }
                        if (err) {
                            callback(err);
                            return;
                        }

                        if (doc._rev !== rev) {
                            callback(errors.REV_CONFLICT);
                            return;
                        }

                        createAttachment(doc);
                    });
                });

                AbstractPouchDB.prototype.removeAttachment = utils.adapterFun('removeAttachment', function(docId, attachmentId, rev, callback) {
                    var self = this;
                    self.get(docId, function(err, obj) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        if (obj._rev !== rev) {
                            callback(errors.REV_CONFLICT);
                            return;
                        }
                        if (!obj._attachments) {
                            return callback();
                        }
                        delete obj._attachments[attachmentId];
                        if (Object.keys(obj._attachments).length === 0) {
                            delete obj._attachments;
                        }
                        self.put(obj, callback);
                    });
                });

                AbstractPouchDB.prototype.remove = utils.adapterFun('remove', function(doc, opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    if (opts === undefined) {
                        opts = {};
                    }
                    opts = utils.extend(true, {}, opts);
                    opts.was_delete = true;
                    var newDoc = {
                        _id: doc._id,
                        _rev: doc._rev
                    };
                    newDoc._deleted = true;
                    return this.bulkDocs({
                        docs: [newDoc]
                    }, opts, yankError(callback));
                });

                AbstractPouchDB.prototype.revsDiff = utils.adapterFun('revsDiff', function(req, opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    opts = utils.extend(true, {}, opts);
                    var ids = Object.keys(req);
                    var count = 0;
                    var missing = {};

                    function addToMissing(id, revId) {
                        if (!missing[id]) {
                            missing[id] = {
                                missing: []
                            };
                        }
                        missing[id].missing.push(revId);
                    }

                    function processDoc(id, rev_tree) {
                        // Is this fast enough? Maybe we should switch to a set simulated by a map
                        var missingForId = req[id].slice(0);
                        merge.traverseRevTree(rev_tree, function(isLeaf, pos, revHash, ctx,
                            opts) {
                            var rev = pos + '-' + revHash;
                            var idx = missingForId.indexOf(rev);
                            if (idx === -1) {
                                return;
                            }

                            missingForId.splice(idx, 1);
                            if (opts.status !== 'available') {
                                addToMissing(id, rev);
                            }
                        });

                        // Traversing the tree is synchronous, so now `missingForId` contains
                        // revisions that were not found in the tree
                        missingForId.forEach(function(rev) {
                            addToMissing(id, rev);
                        });
                    }

                    ids.map(function(id) {
                        this._getRevisionTree(id, function(err, rev_tree) {
                            if (err && err.name === 'not_found' && err.message === 'missing') {
                                missing[id] = {
                                    missing: req[id]
                                };
                            } else if (err) {
                                return callback(err);
                            } else {
                                processDoc(id, rev_tree);
                            }

                            if (++count === ids.length) {
                                return callback(null, missing);
                            }
                        });
                    }, this);
                });

                // compact one document and fire callback
                // by compacting we mean removing all revisions which
                // are further from the leaf in revision tree than max_height
                AbstractPouchDB.prototype.compactDocument = function(docId, max_height, callback) {
                    var self = this;
                    this._getRevisionTree(docId, function(err, rev_tree) {
                        if (err) {
                            return callback(err);
                        }
                        var height = computeHeight(rev_tree);
                        var candidates = [];
                        var revs = [];
                        Object.keys(height).forEach(function(rev) {
                            if (height[rev] > max_height) {
                                candidates.push(rev);
                            }
                        });

                        merge.traverseRevTree(rev_tree, function(isLeaf, pos, revHash, ctx, opts) {
                            var rev = pos + '-' + revHash;
                            if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {
                                opts.status = 'missing';
                                revs.push(rev);
                            }
                        });
                        self._doCompaction(docId, rev_tree, revs, callback);
                    });
                };

                // compact the whole database using single document
                // compaction
                AbstractPouchDB.prototype.compact = utils.adapterFun('compact', function(opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    var self = this;
                    this.changes({
                        complete: function(err, res) {
                            if (err) {
                                callback(); // TODO: silently fail
                                return;
                            }
                            var count = res.results.length;
                            if (!count) {
                                callback();
                                return;
                            }
                            res.results.forEach(function(row) {
                                self.compactDocument(row.id, 0, function() {
                                    count--;
                                    if (!count) {
                                        callback();
                                    }
                                });
                            });
                        }
                    });
                });

                /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */
                AbstractPouchDB.prototype.get = utils.adapterFun('get', function(id, opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    if (typeof id !== 'string') {
                        return callback(errors.INVALID_ID);
                    }
                    var leaves = [],
                        self = this;

                    function finishOpenRevs() {
                        var result = [];
                        var count = leaves.length;
                        if (!count) {
                            return callback(null, result);
                        }
                        // order with open_revs is unspecified
                        leaves.forEach(function(leaf) {
                            self.get(id, {
                                rev: leaf,
                                revs: opts.revs,
                                attachments: opts.attachments
                            }, function(err, doc) {
                                if (!err) {
                                    result.push({
                                        ok: doc
                                    });
                                } else {
                                    result.push({
                                        missing: leaf
                                    });
                                }
                                count--;
                                if (!count) {
                                    callback(null, result);
                                }
                            });
                        });
                    }

                    if (opts.open_revs) {
                        if (opts.open_revs === "all") {
                            this._getRevisionTree(id, function(err, rev_tree) {
                                if (err) {
                                    // if there's no such document we should treat this
                                    // situation the same way as if revision tree was empty
                                    rev_tree = [];
                                }
                                leaves = merge.collectLeaves(rev_tree).map(function(leaf) {
                                    return leaf.rev;
                                });
                                finishOpenRevs();
                            });
                        } else {
                            if (Array.isArray(opts.open_revs)) {
                                leaves = opts.open_revs;
                                for (var i = 0; i < leaves.length; i++) {
                                    var l = leaves[i];
                                    // looks like it's the only thing couchdb checks
                                    if (!(typeof(l) === "string" && /^\d+-/.test(l))) {
                                        return callback(errors.error(errors.BAD_REQUEST,
                                            "Invalid rev format"));
                                    }
                                }
                                finishOpenRevs();
                            } else {
                                return callback(errors.error(errors.UNKNOWN_ERROR,
                                    'function_clause'));
                            }
                        }
                        return; // open_revs does not like other options
                    }

                    return this._get(id, opts, function(err, result) {
                        opts = utils.extend(true, {}, opts);
                        if (err) {
                            return callback(err);
                        }

                        var doc = result.doc;
                        var metadata = result.metadata;
                        var ctx = result.ctx;

                        if (opts.conflicts) {
                            var conflicts = merge.collectConflicts(metadata);
                            if (conflicts.length) {
                                doc._conflicts = conflicts;
                            }
                        }

                        if (opts.revs || opts.revs_info) {
                            var paths = merge.rootToLeaf(metadata.rev_tree);
                            var path = arrayFirst(paths, function(arr) {
                                return arr.ids.map(function(x) {
                                    return x.id;
                                })
                                    .indexOf(doc._rev.split('-')[1]) !== -1;
                            });

                            path.ids.splice(path.ids.map(function(x) {
                                    return x.id;
                                })
                                .indexOf(doc._rev.split('-')[1]) + 1);
                            path.ids.reverse();

                            if (opts.revs) {
                                doc._revisions = {
                                    start: (path.pos + path.ids.length) - 1,
                                    ids: path.ids.map(function(rev) {
                                        return rev.id;
                                    })
                                };
                            }
                            if (opts.revs_info) {
                                var pos = path.pos + path.ids.length;
                                doc._revs_info = path.ids.map(function(rev) {
                                    pos--;
                                    return {
                                        rev: pos + '-' + rev.id,
                                        status: rev.opts.status
                                    };
                                });
                            }
                        }

                        if (opts.local_seq) {
                            doc._local_seq = result.metadata.seq;
                        }

                        if (opts.attachments && doc._attachments) {
                            var attachments = doc._attachments;
                            var count = Object.keys(attachments).length;
                            if (count === 0) {
                                return callback(null, doc);
                            }
                            Object.keys(attachments).forEach(function(key) {
                                this._getAttachment(attachments[key], {
                                    encode: true,
                                    ctx: ctx
                                }, function(err, data) {
                                    doc._attachments[key].data = data;
                                    if (!--count) {
                                        callback(null, doc);
                                    }
                                });
                            }, self);
                        } else {
                            if (doc._attachments) {
                                for (var key in doc._attachments) {
                                    if (doc._attachments.hasOwnProperty(key)) {
                                        doc._attachments[key].stub = true;
                                    }
                                }
                            }
                            callback(null, doc);
                        }
                    });
                });

                AbstractPouchDB.prototype.getAttachment = utils.adapterFun('getAttachment', function(docId, attachmentId, opts, callback) {
                    var self = this;
                    if (opts instanceof Function) {
                        callback = opts;
                        opts = {};
                    }
                    opts = utils.extend(true, {}, opts);
                    this._get(docId, opts, function(err, res) {
                        if (err) {
                            return callback(err);
                        }
                        if (res.doc._attachments && res.doc._attachments[attachmentId]) {
                            opts.ctx = res.ctx;
                            self._getAttachment(res.doc._attachments[attachmentId], opts, callback);
                        } else {
                            return callback(errors.MISSING_DOC);
                        }
                    });
                });

                AbstractPouchDB.prototype.allDocs = utils.adapterFun('allDocs', function(opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    opts = utils.extend(true, {}, opts);
                    if ('keys' in opts) {
                        var incompatibleOpt = ['startkey', 'endkey', 'key'].filter(function(incompatibleOpt) {
                            return incompatibleOpt in opts;
                        })[0];
                        if (incompatibleOpt) {
                            callback(errors.error(errors.QUERY_PARSE_ERROR,
                                'Query parameter `' + incompatibleOpt + '` is not compatible with multi-get'
                            ));
                            return;
                        }
                    }
                    if (typeof opts.skip === 'undefined') {
                        opts.skip = 0;
                    }

                    return this._allDocs(opts, callback);
                });

                function processChange(doc, metadata, opts) {
                    var changeList = [{
                        rev: doc._rev
                    }];
                    if (opts.style === 'all_docs') {
                        changeList = merge.collectLeaves(metadata.rev_tree)
                            .map(function(x) {
                                return {
                                    rev: x.rev
                                };
                            });
                    }
                    var change = {
                        id: metadata.id,
                        changes: changeList,
                        doc: doc
                    };

                    if (utils.isDeleted(metadata, doc._rev)) {
                        change.deleted = true;
                    }
                    if (opts.conflicts) {
                        change.doc._conflicts = merge.collectConflicts(metadata);
                        if (!change.doc._conflicts.length) {
                            delete change.doc._conflicts;
                        }
                    }
                    return change;
                }

                function doChanges(api, opts, promise) {

                    var callback = opts.complete;

                    opts = utils.extend(true, {}, opts);
                    if ('live' in opts && !('continuous' in opts)) {
                        opts.continuous = opts.live;
                    }
                    opts.processChange = processChange;

                    if (!opts.since) {
                        opts.since = 0;
                    }
                    if (opts.since === 'latest') {
                        api.info(function(err, info) {
                            if (promise.isCancelled) {
                                callback(null, {
                                    status: 'cancelled'
                                });
                                return;
                            }
                            if (err) {
                                callback(err);
                                return;
                            }
                            opts.since = info.update_seq - 1;
                            doChanges(api, opts, promise, callback);
                        });
                        return;
                    }

                    if (api.type() !== 'http' && opts.filter && typeof opts.filter === 'string') {
                        if (opts.filter === '_view') {
                            if (opts.view && typeof opts.view === 'string') {
                                // fetch a view from a design doc, make it behave like a filter
                                var viewName = opts.view.split('/');
                                api.get('_design/' + viewName[0], function(err, ddoc) {
                                    if (promise.isCancelled) {
                                        callback(null, {
                                            status: 'cancelled'
                                        });
                                        return;
                                    }
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    if (ddoc && ddoc.views && ddoc.views[viewName[1]]) {
                                        /*jshint evil: true */
                                        var filter = eval('(function () {' +
                                            '  return function (doc) {' +
                                            '    var emitted = false;' +
                                            '    var emit = function (a, b) {' +
                                            '      emitted = true;' +
                                            '    };' +
                                            '    var view = ' + ddoc.views[viewName[1]].map + ';' +
                                            '    view(doc);' +
                                            '    if (emitted) {' +
                                            '      return true;' +
                                            '    }' +
                                            '  }' +
                                            '})()');
                                        opts.filter = filter;
                                        doChanges(api, opts, promise, callback);
                                        return;
                                    } else {
                                        var msg = ddoc.views ? 'missing json key: ' + viewName[1] :
                                            'missing json key: views';
                                        err = err || errors.error(errors.MISSING_DOC, msg);
                                        callback(err);
                                        return;
                                    }
                                });
                            } else {
                                var err = errors.error(errors.BAD_REQUEST,
                                    '`view` filter parameter is not provided.');
                                callback(err);
                                return;
                            }
                        } else {
                            // fetch a filter from a design doc
                            var filterName = opts.filter.split('/');
                            api.get('_design/' + filterName[0], function(err, ddoc) {
                                if (promise.isCancelled) {
                                    callback(null, {
                                        status: 'cancelled'
                                    });
                                    return;
                                }
                                if (err) {
                                    callback(err);
                                    return;
                                }
                                if (ddoc && ddoc.filters && ddoc.filters[filterName[1]]) {
                                    /*jshint evil: true */
                                    var filter = eval('(function () { return ' +
                                        ddoc.filters[filterName[1]] + ' })()');
                                    opts.filter = filter;
                                    doChanges(api, opts, promise, callback);
                                    return;
                                } else {
                                    var msg = (ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1] : 'missing json key: filters';
                                    err = err || errors.error(errors.MISSING_DOC, msg);
                                    callback(err);
                                    return;
                                }
                            });
                        }
                        return;
                    }

                    if (!('descending' in opts)) {
                        opts.descending = false;
                    }

                    // 0 and 1 should return 1 document
                    opts.limit = opts.limit === 0 ? 1 : opts.limit;
                    opts.complete = callback;
                    var newPromise = api._changes(opts);
                    if (newPromise && typeof newPromise.cancel === 'function') {
                        var cancel = promise.cancel;
                        promise.cancel = utils.getArguments(function(args) {
                            newPromise.cancel();
                            cancel.apply(this, args);
                        });
                    }
                }

                AbstractPouchDB.prototype.changes = function(opts) {
                    return utils.cancellableFun(doChanges, this, opts);
                };

                AbstractPouchDB.prototype.close = utils.adapterFun('close', function(callback) {
                    return this._close(callback);
                });

                AbstractPouchDB.prototype.info = utils.adapterFun('info', function(callback) {
                    var self = this;
                    this._info(function(err, info) {
                        if (err) {
                            return callback(err);
                        }
                        var len = self.prefix.length;
                        if (info.db_name.length > len && info.db_name.slice(0, len) === self.prefix) {
                            info.db_name = info.db_name.slice(len);
                        }
                        callback(null, info);
                    });
                });

                AbstractPouchDB.prototype.id = utils.adapterFun('id', function(callback) {
                    return this._id(callback);
                });

                AbstractPouchDB.prototype.type = function() {
                    return (typeof this._type === 'function') ? this._type() : this.adapter;
                };

                AbstractPouchDB.prototype.bulkDocs = utils.adapterFun('bulkDocs', function(req, opts, callback) {
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    if (!opts) {
                        opts = {};
                    } else {
                        opts = utils.extend(true, {}, opts);
                    }

                    if (!req || !req.docs) {
                        return callback(errors.MISSING_BULK_DOCS);
                    }

                    if (!Array.isArray(req.docs)) {
                        return callback(errors.QUERY_PARSE_ERROR);
                    }

                    for (var i = 0; i < req.docs.length; ++i) {
                        if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
                            return callback(errors.NOT_AN_OBJECT);
                        }
                    }

                    req = utils.extend(true, {}, req);
                    if (!('new_edits' in opts)) {
                        if ('new_edits' in req) {
                            opts.new_edits = req.new_edits;
                        } else {
                            opts.new_edits = true;
                        }
                    }

                    return this._bulkDocs(req, opts, this.autoCompact(callback));
                });

            }, {
                "./deps/errors": 8,
                "./merge": 14,
                "./utils": 18,
                "events": 21
            }
        ],
        2: [
            function(_dereq_, module, exports) {
                "use strict";

                var utils = _dereq_('../utils');
                var errors = _dereq_('../deps/errors');
                // parseUri 1.2.2
                // (c) Steven Levithan <stevenlevithan.com>
                // MIT License
                function parseUri(str) {
                    var o = parseUri.options;
                    var m = o.parser[o.strictMode ? "strict" : "loose"].exec(str);
                    var uri = {};
                    var i = 14;

                    while (i--) {
                        uri[o.key[i]] = m[i] || "";
                    }

                    uri[o.q.name] = {};
                    uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
                        if ($1) {
                            uri[o.q.name][$1] = $2;
                        }
                    });

                    return uri;
                }

                function encodeDocId(id) {
                    if (/^_(design|local)/.test(id)) {
                        return id;
                    }
                    return encodeURIComponent(id);
                }

                parseUri.options = {
                    strictMode: false,
                    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host",
                        "port", "relative", "path", "directory", "file", "query", "anchor"
                    ],
                    q: {
                        name: "queryKey",
                        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                    },
                    parser: {
                        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                    }
                };

                // Get all the information you possibly can about the URI given by name and
                // return it as a suitable object.
                function getHost(name, opts) {
                    // If the given name contains "http:"
                    if (/http(s?):/.test(name)) {
                        // Prase the URI into all its little bits
                        var uri = parseUri(name);

                        // Store the fact that it is a remote URI
                        uri.remote = true;

                        // Store the user and password as a separate auth object
                        if (uri.user || uri.password) {
                            uri.auth = {
                                username: uri.user,
                                password: uri.password
                            };
                        }

                        // Split the path part of the URI into parts using '/' as the delimiter
                        // after removing any leading '/' and any trailing '/'
                        var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');

                        // Store the first part as the database name and remove it from the parts
                        // array
                        uri.db = parts.pop();

                        // Restore the path by joining all the remaining parts (all the parts
                        // except for the database name) with '/'s
                        uri.path = parts.join('/');
                        opts = opts || {};
                        opts = utils.extend(true, {}, opts);
                        uri.headers = opts.headers || {};

                        if (opts.auth || uri.auth) {
                            var nAuth = opts.auth || uri.auth;
                            var token = utils.btoa(nAuth.username + ':' + nAuth.password);
                            uri.headers.Authorization = 'Basic ' + token;
                        }

                        if (opts.headers) {
                            uri.headers = opts.headers;
                        }

                        return uri;
                    }

                    // If the given name does not contain 'http:' then return a very basic object
                    // with no host, the current path, the given name as the database name and no
                    // username/password
                    return {
                        host: '',
                        path: '/',
                        db: name,
                        auth: false
                    };
                }

                // Generate a URL with the host data given by opts and the given path
                function genDBUrl(opts, path) {
                    return genUrl(opts, opts.db + '/' + path);
                }

                // Generate a URL with the host data given by opts and the given path
                function genUrl(opts, path) {
                    if (opts.remote) {
                        // If the host already has a path, then we need to have a path delimiter
                        // Otherwise, the path delimiter is the empty string
                        var pathDel = !opts.path ? '' : '/';

                        // If the host already has a path, then we need to have a path delimiter
                        // Otherwise, the path delimiter is the empty string
                        return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + opts.path + pathDel + path;
                    }

                    return '/' + path;
                }
                // Implements the PouchDB API for dealing with CouchDB instances over HTTP
                function HttpPouch(opts, callback) {
                    // The functions that will be publicly available for HttpPouch
                    var api = this;
                    api.getHost = opts.getHost ? opts.getHost : getHost;

                    // Parse the URI given by opts.name into an easy-to-use object
                    var host = api.getHost(opts.name, opts);

                    // Generate the database URL based on the host
                    var dbUrl = genDBUrl(host, '');

                    api.getUrl = function() {
                        return dbUrl;
                    };

                    var ajaxOpts = opts.ajax || {};
                    opts = utils.extend(true, {}, opts);

                    function ajax(options, callback) {
                        return utils.ajax(utils.extend({}, ajaxOpts, options), callback);
                    }
                    var uuids = {
                        list: [],
                        get: function(opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {
                                    count: 10
                                };
                            }
                            var cb = function(err, body) {
                                if (err || !('uuids' in body)) {
                                    callback(err || errors.UNKNOWN_ERROR);
                                } else {
                                    uuids.list = uuids.list.concat(body.uuids);
                                    callback(null, "OK");
                                }
                            };
                            var params = '?count=' + opts.count;
                            ajax({
                                headers: host.headers,
                                method: 'GET',
                                url: genUrl(host, '_uuids') + params
                            }, cb);
                        }
                    };

                    // Create a new CouchDB database based on the given opts
                    var createDB = function() {
                        ajax({
                            headers: host.headers,
                            method: 'PUT',
                            url: dbUrl
                        }, function(err, ret) {
                            // If we get an "Unauthorized" error
                            if (err && err.status === 401) {
                                // Test if the database already exists
                                ajax({
                                    headers: host.headers,
                                    method: 'HEAD',
                                    url: dbUrl
                                }, function(err, ret) {
                                    // If there is still an error
                                    if (err) {
                                        // Give the error to the callback to deal with
                                        callback(err);
                                    } else {
                                        // Continue as if there had been no errors
                                        callback(null, api);
                                    }
                                });
                                // If there were no errros or if the only error is "Precondition Failed"
                                // (note: "Precondition Failed" occurs when we try to create a database
                                // that already exists)
                            } else if (!err || err.status === 412) {
                                // Continue as if there had been no errors
                                callback(null, api);
                            } else {
                                callback(err);
                            }
                        });
                    };
                    if (!opts.skipSetup) {
                        ajax({
                            headers: host.headers,
                            method: 'GET',
                            url: dbUrl
                        }, function(err, ret) {
                            //check if the db exists
                            if (err) {
                                if (err.status === 404) {
                                    //if it doesn't, create it
                                    createDB();
                                } else {
                                    callback(err);
                                }
                            } else {
                                //go do stuff with the db
                                callback(null, api);
                            }
                        });
                    }

                    api.type = function() {
                        return 'http';
                    };

                    api.id = utils.adapterFun('id', function(callback) {
                        ajax({
                            headers: host.headers,
                            method: 'GET',
                            url: genUrl(host, '')
                        }, function(err, result) {
                            if (err) {
                                callback(err);
                            } else {
                                var uuid = (result && result.uuid) ?
                                    result.uuid + host.db : genDBUrl(host, '');
                                callback(null, uuid);
                            }
                        });
                    });

                    api.request = utils.adapterFun('request', function(options, callback) {
                        options.headers = host.headers;
                        options.url = genDBUrl(host, options.url);
                        ajax(options, callback);
                    });

                    // Sends a POST request to the host calling the couchdb _compact function
                    //    version: The version of CouchDB it is running
                    api.compact = utils.adapterFun('compact', function(opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = utils.extend(true, {}, opts);
                        ajax({
                            headers: host.headers,
                            url: genDBUrl(host, '_compact'),
                            method: 'POST'
                        }, function() {
                            function ping() {
                                api.info(function(err, res) {
                                    if (!res.compact_running) {
                                        callback();
                                    } else {
                                        setTimeout(ping, opts.interval || 200);
                                    }
                                });
                            }
                            // Ping the http if it's finished compaction
                            if (typeof callback === "function") {
                                ping();
                            }
                        });
                    });

                    // Calls GET on the host, which gets back a JSON string containing
                    //    couchdb: A welcome string
                    //    version: The version of CouchDB it is running
                    api._info = function(callback) {
                        ajax({
                            headers: host.headers,
                            method: 'GET',
                            url: genDBUrl(host, '')
                        }, function(err, res) {
                            if (err) {
                                callback(err);
                            } else {
                                res.host = genDBUrl(host, '');
                                callback(null, res);
                            }
                        });
                    };

                    // Get the document with the given id from the database given by host.
                    // The id could be solely the _id in the database, or it may be a
                    // _design/ID or _local/ID path
                    api.get = utils.adapterFun('get', function(id, opts, callback) {
                        // If no options were given, set the callback to the second parameter
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = utils.extend(true, {}, opts);
                        if (opts.auto_encode === undefined) {
                            opts.auto_encode = true;
                        }

                        // List of parameters to add to the GET request
                        var params = [];

                        // If it exists, add the opts.revs value to the list of parameters.
                        // If revs=true then the resulting JSON will include a field
                        // _revisions containing an array of the revision IDs.
                        if (opts.revs) {
                            params.push('revs=true');
                        }

                        // If it exists, add the opts.revs_info value to the list of parameters.
                        // If revs_info=true then the resulting JSON will include the field
                        // _revs_info containing an array of objects in which each object
                        // representing an available revision.
                        if (opts.revs_info) {
                            params.push('revs_info=true');
                        }

                        if (opts.local_seq) {
                            params.push('local_seq=true');
                        }
                        // If it exists, add the opts.open_revs value to the list of parameters.
                        // If open_revs=all then the resulting JSON will include all the leaf
                        // revisions. If open_revs=["rev1", "rev2",...] then the resulting JSON
                        // will contain an array of objects containing data of all revisions
                        if (opts.open_revs) {
                            if (opts.open_revs !== "all") {
                                opts.open_revs = JSON.stringify(opts.open_revs);
                            }
                            params.push('open_revs=' + opts.open_revs);
                        }

                        // If it exists, add the opts.attachments value to the list of parameters.
                        // If attachments=true the resulting JSON will include the base64-encoded
                        // contents in the "data" property of each attachment.
                        if (opts.attachments) {
                            params.push('attachments=true');
                        }

                        // If it exists, add the opts.rev value to the list of parameters.
                        // If rev is given a revision number then get the specified revision.
                        if (opts.rev) {
                            params.push('rev=' + opts.rev);
                        }

                        // If it exists, add the opts.conflicts value to the list of parameters.
                        // If conflicts=true then the resulting JSON will include the field
                        // _conflicts containing all the conflicting revisions.
                        if (opts.conflicts) {
                            params.push('conflicts=' + opts.conflicts);
                        }

                        // Format the list of parameters into a valid URI query string
                        params = params.join('&');
                        params = params === '' ? '' : '?' + params;

                        if (opts.auto_encode) {
                            id = encodeDocId(id);
                        }

                        // Set the options for the ajax call
                        var options = {
                            headers: host.headers,
                            method: 'GET',
                            url: genDBUrl(host, id + params)
                        };

                        // If the given id contains at least one '/' and the part before the '/'
                        // is NOT "_design" and is NOT "_local"
                        // OR
                        // If the given id contains at least two '/' and the part before the first
                        // '/' is "_design".
                        // TODO This second condition seems strange since if parts[0] === '_design'
                        // then we already know that parts[0] !== '_local'.
                        var parts = id.split('/');
                        if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||
                            (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {
                            // Binary is expected back from the server
                            options.binary = true;
                        }

                        // Get the document
                        ajax(options, function(err, doc, xhr) {
                            // If the document does not exist, send an error to the callback
                            if (err) {
                                return callback(err);
                            }

                            // Send the document to the callback
                            callback(null, doc, xhr);
                        });
                    });

                    // Delete the document given by doc from the database given by host.
                    api.remove = utils.adapterFun('remove', function(doc, opts, callback) {
                        // If no options were given, set the callback to be the second parameter
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }

                        // Delete the document
                        ajax({
                            headers: host.headers,
                            method: 'DELETE',
                            url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + doc._rev
                        }, callback);
                    });

                    // Get the attachment
                    api.getAttachment = utils.adapterFun('getAttachment', function(docId, attachmentId, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = utils.extend(true, {}, opts);
                        if (opts.auto_encode === undefined) {
                            opts.auto_encode = true;
                        }
                        if (opts.auto_encode) {
                            docId = encodeDocId(docId);
                        }
                        opts.auto_encode = false;
                        api.get(docId + '/' + attachmentId, opts, callback);
                    });

                    // Remove the attachment given by the id and rev
                    api.removeAttachment = utils.adapterFun('removeAttachment', function(docId, attachmentId, rev, callback) {
                        ajax({
                            headers: host.headers,
                            method: 'DELETE',
                            url: genDBUrl(host, encodeDocId(docId) + '/' + attachmentId) + '?rev=' + rev
                        }, callback);
                    });

                    // Add the attachment given by blob and its contentType property
                    // to the document with the given id, the revision given by rev, and
                    // add it to the database given by host.
                    api.putAttachment = utils.adapterFun('putAttachment', function(docId, attachmentId, rev, blob, type, callback) {
                        if (typeof type === 'function') {
                            callback = type;
                            type = blob;
                            blob = rev;
                            rev = null;
                        }
                        if (typeof type === 'undefined') {
                            type = blob;
                            blob = rev;
                            rev = null;
                        }
                        var id = encodeDocId(docId) + '/' + attachmentId;
                        var url = genDBUrl(host, id);
                        if (rev) {
                            url += '?rev=' + rev;
                        }

                        var opts = {
                            headers: host.headers,
                            method: 'PUT',
                            url: url,
                            processData: false,
                            body: blob,
                            timeout: 60000
                        };
                        opts.headers['Content-Type'] = type;
                        // Add the attachment
                        ajax(opts, callback);
                    });

                    // Add the document given by doc (in JSON string format) to the database
                    // given by host. This fails if the doc has no _id field.
                    api.put = utils.adapterFun('put', utils.getArguments(function(args) {
                        var temp, temptype, opts, callback;
                        var doc = args.shift();
                        var id = '_id' in doc;
                        if (typeof doc !== 'object' || Array.isArray(doc)) {
                            callback = args.pop();
                            return callback(errors.NOT_AN_OBJECT);
                        }
                        doc = utils.extend(true, {}, doc);
                        while (true) {
                            temp = args.shift();
                            temptype = typeof temp;
                            if (temptype === "string" && !id) {
                                doc._id = temp;
                                id = true;
                            } else if (temptype === "string" && id && !('_rev' in doc)) {
                                doc._rev = temp;
                            } else if (temptype === "object") {
                                opts = utils.extend(true, {}, temp);
                            } else if (temptype === "function") {
                                callback = temp;
                            }
                            if (!args.length) {
                                break;
                            }
                        }
                        opts = opts || {};
                        var error = utils.invalidIdError(doc._id);
                        if (error) {
                            return callback(error);
                        }

                        // List of parameter to add to the PUT request
                        var params = [];

                        // If it exists, add the opts.new_edits value to the list of parameters.
                        // If new_edits = false then the database will NOT assign this document a
                        // new revision number
                        if (opts && typeof opts.new_edits !== 'undefined') {
                            params.push('new_edits=' + opts.new_edits);
                        }

                        // Format the list of parameters into a valid URI query string
                        params = params.join('&');
                        if (params !== '') {
                            params = '?' + params;
                        }

                        // Add the document
                        ajax({
                            headers: host.headers,
                            method: 'PUT',
                            url: genDBUrl(host, encodeDocId(doc._id)) + params,
                            body: doc
                        }, callback);
                    }));

                    // Add the document given by doc (in JSON string format) to the database
                    // given by host. This does not assume that doc is a new document (i.e. does not
                    // have a _id or a _rev field.
                    api.post = utils.adapterFun('post', function(doc, opts, callback) {
                        // If no options were given, set the callback to be the second parameter
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = utils.extend(true, {}, opts);
                        if (typeof doc !== 'object') {
                            return callback(errors.NOT_AN_OBJECT);
                        }
                        if (!("_id" in doc)) {
                            if (uuids.list.length > 0) {
                                doc._id = uuids.list.pop();
                                api.put(doc, opts, callback);
                            } else {
                                uuids.get(function(err, resp) {
                                    if (err) {
                                        return callback(errors.UNKNOWN_ERROR);
                                    }
                                    doc._id = uuids.list.pop();
                                    api.put(doc, opts, callback);
                                });
                            }
                        } else {
                            api.put(doc, opts, callback);
                        }
                    });

                    // Update/create multiple documents given by req in the database
                    // given by host.
                    api.bulkDocs = utils.adapterFun('bulkDocs', function(req, opts, callback) {
                        // If no options were given, set the callback to be the second parameter
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        if (!opts) {
                            opts = {};
                        }
                        if (!Array.isArray(req.docs)) {
                            return callback(errors.error(errors.NOT_AN_OBJECT, "Missing JSON list of 'docs'"));
                        }
                        var bad = req.docs.filter(function(doc) {
                            return typeof doc !== 'object' || Array.isArray(doc);
                        });
                        if (bad.length) {
                            return callback(errors.NOT_AN_OBJECT);
                        }
                        req = utils.extend(true, {}, req);
                        opts = utils.extend(true, {}, opts);
                        // If opts.new_edits exists add it to the document data to be
                        // send to the database.
                        // If new_edits=false then it prevents the database from creating
                        // new revision numbers for the documents. Instead it just uses
                        // the old ones. This is used in database replication.
                        if (typeof opts.new_edits !== 'undefined') {
                            req.new_edits = opts.new_edits;
                        }

                        // Update/create the documents
                        ajax({
                            headers: host.headers,
                            method: 'POST',
                            url: genDBUrl(host, '_bulk_docs'),
                            body: req
                        }, callback);
                    });

                    // Get a listing of the documents in the database given
                    // by host and ordered by increasing id.
                    api.allDocs = utils.adapterFun('allDocs', function(opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = utils.extend(true, {}, opts);
                        // List of parameters to add to the GET request
                        var params = [];
                        var body;
                        var method = 'GET';

                        // TODO I don't see conflicts as a valid parameter for a
                        // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)
                        if (opts.conflicts) {
                            params.push('conflicts=true');
                        }

                        // If opts.descending is truthy add it to params
                        if (opts.descending) {
                            params.push('descending=true');
                        }

                        // If opts.include_docs exists, add the include_docs value to the
                        // list of parameters.
                        // If include_docs=true then include the associated document with each
                        // result.
                        if (opts.include_docs) {
                            params.push('include_docs=true');
                        }

                        if (opts.key) {
                            params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));
                        }

                        // If opts.startkey exists, add the startkey value to the list of
                        // parameters.
                        // If startkey is given then the returned list of documents will
                        // start with the document whose id is startkey.
                        if (opts.startkey) {
                            params.push('startkey=' +
                                encodeURIComponent(JSON.stringify(opts.startkey)));
                        }

                        // If opts.endkey exists, add the endkey value to the list of parameters.
                        // If endkey is given then the returned list of docuemnts will
                        // end with the document whose id is endkey.
                        if (opts.endkey) {
                            params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));
                        }

                        // If opts.limit exists, add the limit value to the parameter list.
                        if (typeof opts.limit !== 'undefined') {
                            params.push('limit=' + opts.limit);
                        }

                        if (typeof opts.skip !== 'undefined') {
                            params.push('skip=' + opts.skip);
                        }

                        // Format the list of parameters into a valid URI query string
                        params = params.join('&');
                        if (params !== '') {
                            params = '?' + params;
                        }

                        if (typeof opts.keys !== 'undefined') {

                            var MAX_URL_LENGTH = 2000;
                            // according to http://stackoverflow.com/a/417184/680742,
                            // the de factor URL length limit is 2000 characters

                            var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
                            if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
                                // If the keys are short enough, do a GET. we do this to work around
                                // Safari not understanding 304s on POSTs (see issue #1239)
                                params += (params.indexOf('?') !== -1 ? '&' : '?') + keysAsString;
                            } else {
                                // If keys are too long, issue a POST request to circumvent GET query string limits
                                // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
                                method = 'POST';
                                body = JSON.stringify({
                                    keys: opts.keys
                                });
                            }
                        }

                        // Get the document listing
                        ajax({
                            headers: host.headers,
                            method: method,
                            url: genDBUrl(host, '_all_docs' + params),
                            body: body
                        }, callback);
                    });

                    // Get a list of changes made to documents in the database given by host.
                    // TODO According to the README, there should be two other methods here,
                    // api.changes.addListener and api.changes.removeListener.
                    api._changes = function(opts) {
                        // We internally page the results of a changes request, this means
                        // if there is a large set of changes to be returned we can start
                        // processing them quicker instead of waiting on the entire
                        // set of changes to return and attempting to process them at once
                        var CHANGES_LIMIT = 25;

                        opts = utils.extend(true, {}, opts);
                        opts.timeout = opts.timeout || 0;

                        // set timeout to 20s to prevent aborting via Ajax timeout
                        var params = {
                            timeout: 20 * 1000
                        };
                        var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
                        if (limit === 0) {
                            limit = 1;
                        }
                        //
                        var leftToFetch = limit;

                        if (opts.style) {
                            params.style = opts.style;
                        }

                        if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
                            params.include_docs = true;
                        }

                        if (opts.continuous) {
                            params.feed = 'longpoll';
                        }

                        if (opts.conflicts) {
                            params.conflicts = true;
                        }

                        if (opts.descending) {
                            params.descending = true;
                        }

                        if (opts.filter && typeof opts.filter === 'string') {
                            params.filter = opts.filter;
                            if (opts.filter === '_view' && opts.view && typeof opts.view === 'string') {
                                params.view = opts.view;
                            }
                        }

                        // If opts.query_params exists, pass it through to the changes request.
                        // These parameters may be used by the filter on the source database.
                        if (opts.query_params && typeof opts.query_params === 'object') {
                            for (var param_name in opts.query_params) {
                                if (opts.query_params.hasOwnProperty(param_name)) {
                                    params[param_name] = opts.query_params[param_name];
                                }
                            }
                        }

                        var xhr;
                        var lastFetchedSeq;

                        // Get all the changes starting wtih the one immediately after the
                        // sequence number given by since.
                        var fetch = function(since, callback) {
                            if (opts.aborted) {
                                return;
                            }
                            params.since = since;
                            if (opts.descending) {
                                if (limit) {
                                    params.limit = leftToFetch;
                                }
                            } else {
                                params.limit = (!limit || leftToFetch > CHANGES_LIMIT) ?
                                    CHANGES_LIMIT : leftToFetch;
                            }

                            var paramStr = '?' + Object.keys(params).map(function(k) {
                                return k + '=' + params[k];
                            }).join('&');

                            // Set the options for the ajax call
                            var xhrOpts = {
                                headers: host.headers,
                                method: 'GET',
                                url: genDBUrl(host, '_changes' + paramStr),
                                // _changes can take a long time to generate, especially when filtered
                                timeout: opts.timeout
                            };
                            lastFetchedSeq = since;

                            if (opts.aborted) {
                                return;
                            }

                            // Get the changes
                            xhr = ajax(xhrOpts, callback);
                        };

                        // If opts.since exists, get all the changes from the sequence
                        // number given by opts.since. Otherwise, get all the changes
                        // from the sequence number 0.
                        var fetchTimeout = 10;
                        var fetchRetryCount = 0;

                        var results = {
                            results: []
                        };

                        var fetched = function(err, res) {
                            if (opts.aborted) {
                                return;
                            }
                            var raw_results_length = 0;
                            // If the result of the ajax call (res) contains changes (res.results)
                            if (res && res.results) {
                                raw_results_length = res.results.length;
                                results.last_seq = res.last_seq;
                                // For each change
                                var req = {};
                                req.query = opts.query_params;
                                res.results = res.results.filter(function(c) {
                                    leftToFetch--;
                                    var ret = utils.filterChange(opts)(c);
                                    if (ret) {
                                        results.results.push(c);
                                        utils.call(opts.onChange, c);
                                    }
                                    return ret;
                                });
                            } else if (err) {
                                // In case of an error, stop listening for changes and call opts.complete
                                opts.aborted = true;
                                utils.call(opts.complete, err);
                                return;
                            }

                            // The changes feed may have timed out with no results
                            // if so reuse last update sequence
                            if (res && res.last_seq) {
                                lastFetchedSeq = res.last_seq;
                            }

                            var finished = (limit && leftToFetch <= 0) ||
                                (res && raw_results_length < CHANGES_LIMIT) ||
                                (opts.descending);

                            if (opts.continuous || !finished) {
                                // Increase retry delay exponentially as long as errors persist
                                if (err) {
                                    fetchRetryCount += 1;
                                } else {
                                    fetchRetryCount = 0;
                                }
                                var timeoutMultiplier = 1 << fetchRetryCount;
                                var retryWait = fetchTimeout * timeoutMultiplier;
                                var maximumWait = opts.maximumWait || 30000;

                                if (retryWait > maximumWait) {
                                    utils.call(opts.complete, err || errors.UNKNOWN_ERROR);
                                    return;
                                }

                                // Queue a call to fetch again with the newest sequence number
                                setTimeout(function() {
                                    fetch(lastFetchedSeq, fetched);
                                }, retryWait);
                            } else {
                                // We're done, call the callback
                                utils.call(opts.complete, null, results);
                            }
                        };

                        fetch(opts.since || 0, fetched);

                        // Return a method to cancel this method from processing any more
                        return {
                            cancel: function() {
                                opts.aborted = true;
                                xhr.abort();
                            }
                        };
                    };

                    // Given a set of document/revision IDs (given by req), tets the subset of
                    // those that do NOT correspond to revisions stored in the database.
                    // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
                    api.revsDiff = utils.adapterFun('revsDif', function(req, opts, callback) {
                        // If no options were given, set the callback to be the second parameter
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }

                        // Get the missing document/revision IDs
                        ajax({
                            headers: host.headers,
                            method: 'POST',
                            url: genDBUrl(host, '_revs_diff'),
                            body: req
                        }, function(err, res) {
                            callback(err, res);
                        });
                    });

                    api.close = utils.adapterFun('close', function(callback) {
                        callback();
                    });

                    function replicateOnServer(target, opts, promise, targetHostUrl) {
                        opts = utils.extend(true, {}, opts);
                        var targetHost = api.getHost(targetHostUrl);
                        var params = {
                            source: host.db,
                            target: targetHost.protocol === host.protocol &&
                                targetHost.authority === host.authority ? targetHost.db : targetHost.source
                        };

                        if (opts.continuous) {
                            params.continuous = true;
                        }

                        if (opts.create_target) {
                            params.create_target = true;
                        }

                        if (opts.doc_ids) {
                            params.doc_ids = opts.doc_ids;
                        }

                        if (opts.filter && typeof opts.filter === 'string') {
                            params.filter = opts.filter;
                        }

                        if (opts.query_params) {
                            params.query_params = opts.query_params;
                        }

                        var result = {};
                        var repOpts = {
                            headers: host.headers,
                            method: 'POST',
                            url: genUrl(host, '_replicate'),
                            body: params
                        };

                        var xhr;
                        promise.cancel = function() {
                            this.cancelled = true;
                            if (xhr && !result.ok) {
                                xhr.abort();
                            }
                            if (result._local_id) {
                                repOpts.body = {
                                    replication_id: result._local_id
                                };
                            }
                            repOpts.body.cancel = true;
                            ajax(repOpts, function(err, resp, xhr) {
                                // If the replication cancel request fails, send an error to the callback
                                if (err) {
                                    return callback(err);
                                }
                                // Send the replication cancel result to the complete callback
                                utils.call(opts.complete, null, result, xhr);
                            });
                        };

                        if (promise.cancelled) {
                            return;
                        }

                        xhr = ajax(repOpts, function(err, resp, xhr) {
                            // If the replication fails, send an error to the callback
                            if (err) {
                                return callback(err);
                            }

                            result.ok = true;

                            // Provided by CouchDB from 1.2.0 onward to cancel replication
                            if (resp._local_id) {
                                result._local_id = resp._local_id;
                            }

                            // Send the replication result to the complete callback
                            utils.call(opts.complete, null, resp, xhr);
                        });
                    }

                    api.replicateOnServer = function(target, opts, promise) {
                        if (!api.taskqueue.isReady) {
                            api.taskqueue.addTask('replicateOnServer', [target, opts, promise]);
                            return promise;
                        }
                        target.info(function(err, info) {
                            replicateOnServer(target, opts, promise, info.host);
                        });
                    };
                    api.destroy = utils.adapterFun('destroy', function(callback) {
                        ajax({
                            url: genDBUrl(host, ''),
                            method: 'DELETE',
                            headers: host.headers
                        }, function(err, resp) {
                            if (err) {
                                api.emit('error', err);
                                callback(err);
                            } else {
                                api.emit('destroyed');
                                callback(null, resp);
                            }
                        });
                    });
                }

                // Delete the HttpPouch specified by the given name.
                HttpPouch.destroy = utils.toPromise(function(name, opts, callback) {
                    var host = getHost(name, opts);
                    opts = opts || {};
                    if (typeof opts === 'function') {
                        callback = opts;
                        opts = {};
                    }
                    opts = utils.extend(true, {}, opts);
                    opts.headers = host.headers;
                    opts.method = 'DELETE';
                    opts.url = genDBUrl(host, '');
                    var ajaxOpts = opts.ajax || {};
                    opts = utils.extend({}, opts, ajaxOpts);
                    utils.ajax(opts, callback);
                });

                // HttpPouch is a valid adapter.
                HttpPouch.valid = function() {
                    return true;
                };

                module.exports = HttpPouch;

            }, {
                "../deps/errors": 8,
                "../utils": 18
            }
        ],
        3: [
            function(_dereq_, module, exports) {
                (function(global) {
                    'use strict';

                    var utils = _dereq_('../utils');
                    var merge = _dereq_('../merge');
                    var errors = _dereq_('../deps/errors');

                    function idbError(callback) {
                        return function(event) {
                            callback(errors.error(errors.IDB_ERROR, event.target, event.type));
                        };
                    }

                    function isModernIdb() {
                        // check for outdated implementations of IDB
                        // that rely on the setVersion method instead of onupgradeneeded (issue #1207)

                        // cache based on appVersion, in case the browser is updated
                        var cacheKey = "_pouch__checkModernIdb_" +
                            (global.navigator && global.navigator.appVersion);
                        var cached = utils.hasLocalStorage() && global.localStorage[cacheKey];
                        if (cached) {
                            return JSON.parse(cached);
                        }

                        var dbName = '_pouch__checkModernIdb';
                        var result = global.indexedDB.open(dbName, 1).onupgradeneeded === null;

                        if (global.indexedDB.deleteDatabase) {
                            global.indexedDB.deleteDatabase(dbName); // db no longer needed
                        }
                        if (utils.hasLocalStorage()) {
                            global.localStorage[cacheKey] = JSON.stringify(result); // cache
                        }
                        return result;
                    }

                    function IdbPouch(opts, callback) {

                        // IndexedDB requires a versioned database structure, so we use the
                        // version here to manage migrations.
                        var ADAPTER_VERSION = 2;

                        // The object stores created for each database
                        // DOC_STORE stores the document meta data, its revision history and state
                        var DOC_STORE = 'document-store';
                        // BY_SEQ_STORE stores a particular version of a document, keyed by its
                        // sequence id
                        var BY_SEQ_STORE = 'by-sequence';
                        // Where we store attachments
                        var ATTACH_STORE = 'attach-store';
                        // Where we store meta data
                        var META_STORE = 'meta-store';
                        // Where we detect blob support
                        var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

                        var name = opts.name;
                        var req = global.indexedDB.open(name, ADAPTER_VERSION);

                        if (!('openReqList' in IdbPouch)) {
                            IdbPouch.openReqList = {};
                        }
                        IdbPouch.openReqList[name] = req;

                        var blobSupport = null;
                        var instanceId = null;
                        var api = this;
                        var idb = null;

                        req.onupgradeneeded = function(e) {
                            var db = e.target.result;
                            if (e.oldVersion < 1) {
                                // initial schema
                                createSchema(db);
                            }
                            if (e.oldVersion < 2) {
                                // version 2 adds the deletedOrLocal index
                                addDeletedOrLocalIndex(e);
                            }
                        };

                        function createSchema(db) {
                            db.createObjectStore(DOC_STORE, {
                                keyPath: 'id'
                            })
                                .createIndex('seq', 'seq', {
                                    unique: true
                                });
                            db.createObjectStore(BY_SEQ_STORE, {
                                autoIncrement: true
                            })
                                .createIndex('_doc_id_rev', '_doc_id_rev', {
                                    unique: true
                                });
                            db.createObjectStore(ATTACH_STORE, {
                                keyPath: 'digest'
                            });
                            db.createObjectStore(META_STORE, {
                                keyPath: 'id',
                                autoIncrement: false
                            });
                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                        }

                        function addDeletedOrLocalIndex(e) {
                            var docStore = e.currentTarget.transaction.objectStore(DOC_STORE);

                            docStore.openCursor().onsuccess = function(event) {
                                var cursor = event.target.result;
                                if (cursor) {
                                    var metadata = cursor.value;
                                    var deleted = utils.isDeleted(metadata);
                                    var local = utils.isLocalId(metadata.id);
                                    metadata.deletedOrLocal = (deleted || local) ? "1" : "0";
                                    docStore.put(metadata);
                                    cursor['continue']();
                                } else {
                                    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {
                                        unique: false
                                    });
                                }
                            };
                        }

                        req.onsuccess = function(e) {

                            idb = e.target.result;

                            idb.onversionchange = function() {
                                idb.close();
                            };

                            var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],
                                'readwrite');

                            var req = txn.objectStore(META_STORE).get(META_STORE);

                            req.onsuccess = function(e) {

                                var idStored = false;
                                var checkSetupComplete = function() {
                                    if (blobSupport === null || !idStored) {
                                        return;
                                    } else {
                                        callback(null, api);
                                    }
                                };

                                var meta = e.target.result || {
                                    id: META_STORE
                                };
                                if (name + '_id' in meta) {
                                    instanceId = meta[name + '_id'];
                                    idStored = true;
                                    checkSetupComplete();
                                } else {
                                    instanceId = utils.uuid();
                                    meta[name + '_id'] = instanceId;
                                    txn.objectStore(META_STORE).put(meta).onsuccess = function() {
                                        idStored = true;
                                        checkSetupComplete();
                                    };
                                }

                                // detect blob support
                                try {
                                    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(utils.createBlob(), "key");
                                    blobSupport = true;
                                } catch (err) {
                                    blobSupport = false;
                                } finally {
                                    checkSetupComplete();
                                }
                            };
                        };

                        req.onerror = idbError(callback);

                        api.type = function() {
                            return 'idb';
                        };

                        api._id = utils.toPromise(function(callback) {
                            callback(null, instanceId);
                        });

                        api._bulkDocs = function idb_bulkDocs(req, opts, callback) {
                            var newEdits = opts.new_edits;
                            var userDocs = req.docs;
                            // Parse the docs, give them a sequence number for the result
                            var docInfos = userDocs.map(function(doc, i) {
                                var newDoc = utils.parseDoc(doc, newEdits);
                                newDoc._bulk_seq = i;
                                return newDoc;
                            });

                            var docInfoErrors = docInfos.filter(function(docInfo) {
                                return docInfo.error;
                            });
                            if (docInfoErrors.length) {
                                return callback(docInfoErrors[0]);
                            }

                            var results = [];
                            var docsWritten = 0;

                            function writeMetaData(e) {
                                var meta = e.target.result;
                                meta.updateSeq = (meta.updateSeq || 0) + docsWritten;
                                txn.objectStore(META_STORE).put(meta);
                            }

                            function processDocs() {
                                if (!docInfos.length) {
                                    txn.objectStore(META_STORE).get(META_STORE).onsuccess = writeMetaData;
                                    return;
                                }
                                var currentDoc = docInfos.shift();
                                var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);
                                req.onsuccess = function process_docRead(event) {
                                    var oldDoc = event.target.result;
                                    if (!oldDoc) {
                                        insertDoc(currentDoc);
                                    } else {
                                        updateDoc(oldDoc, currentDoc);
                                    }
                                };
                            }

                            function complete(event) {
                                var aresults = [];
                                results.sort(sortByBulkSeq);
                                results.forEach(function(result) {
                                    delete result._bulk_seq;
                                    if (result.error) {
                                        aresults.push(result);
                                        return;
                                    }
                                    var metadata = result.metadata;
                                    var rev = merge.winningRev(metadata);

                                    aresults.push({
                                        ok: true,
                                        id: metadata.id,
                                        rev: rev
                                    });

                                    if (utils.isLocalId(metadata.id)) {
                                        return;
                                    }

                                    IdbPouch.Changes.notify(name);
                                    IdbPouch.Changes.notifyLocalWindows(name);
                                });
                                callback(null, aresults);
                            }

                            function preprocessAttachment(att, finish) {
                                if (att.stub) {
                                    return finish();
                                }
                                if (typeof att.data === 'string') {
                                    var data;
                                    try {
                                        data = atob(att.data);
                                    } catch (e) {
                                        var err = errors.error(errors.BAD_ARG,
                                            "Attachments need to be base64 encoded");
                                        return callback(err);
                                    }
                                    att.digest = 'md5-' + utils.Crypto.MD5(data);
                                    if (blobSupport) {
                                        var type = att.content_type;
                                        data = utils.fixBinary(data);
                                        att.data = utils.createBlob([data], {
                                            type: type
                                        });
                                    }
                                    return finish();
                                }
                                var reader = new FileReader();
                                reader.onloadend = function(e) {
                                    var binary = utils.arrayBufferToBinaryString(this.result);
                                    att.digest = 'md5-' + utils.Crypto.MD5(binary);
                                    if (!blobSupport) {
                                        att.data = btoa(binary);
                                    }
                                    finish();
                                };
                                reader.readAsArrayBuffer(att.data);
                            }

                            function preprocessAttachments(callback) {
                                if (!docInfos.length) {
                                    return callback();
                                }

                                var docv = 0;
                                docInfos.forEach(function(docInfo) {
                                    var attachments = docInfo.data && docInfo.data._attachments ?
                                        Object.keys(docInfo.data._attachments) : [];

                                    if (!attachments.length) {
                                        return done();
                                    }

                                    var recv = 0;

                                    function attachmentProcessed() {
                                        recv++;
                                        if (recv === attachments.length) {
                                            done();
                                        }
                                    }

                                    for (var key in docInfo.data._attachments) {
                                        if (docInfo.data._attachments.hasOwnProperty(key)) {
                                            preprocessAttachment(docInfo.data._attachments[key], attachmentProcessed);
                                        }
                                    }
                                });

                                function done() {
                                    docv++;
                                    if (docInfos.length === docv) {
                                        callback();
                                    }
                                }
                            }

                            function writeDoc(docInfo, callback) {
                                var err = null;
                                var recv = 0;
                                docInfo.data._id = docInfo.metadata.id;
                                docInfo.data._rev = docInfo.metadata.rev;

                                docsWritten++;

                                if (utils.isDeleted(docInfo.metadata, docInfo.metadata.rev)) {
                                    docInfo.data._deleted = true;
                                }

                                var attachments = docInfo.data._attachments ?
                                    Object.keys(docInfo.data._attachments) : [];

                                function collectResults(attachmentErr) {
                                    if (!err) {
                                        if (attachmentErr) {
                                            err = attachmentErr;
                                            callback(err);
                                        } else if (recv === attachments.length) {
                                            finish();
                                        }
                                    }
                                }

                                function attachmentSaved(err) {
                                    recv++;
                                    collectResults(err);
                                }

                                for (var key in docInfo.data._attachments) {
                                    if (!docInfo.data._attachments[key].stub) {
                                        var data = docInfo.data._attachments[key].data;
                                        delete docInfo.data._attachments[key].data;
                                        var digest = docInfo.data._attachments[key].digest;
                                        saveAttachment(docInfo, digest, data, attachmentSaved);
                                    } else {
                                        recv++;
                                        collectResults();
                                    }
                                }

                                function finish() {

                                    docInfo.data._doc_id_rev = docInfo.data._id + "::" + docInfo.data._rev;
                                    var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');

                                    index.getKey(docInfo.data._doc_id_rev).onsuccess = function(e) {

                                        var dataReq = e.target.result ?
                                            txn.objectStore(BY_SEQ_STORE).put(docInfo.data, e.target.result) :
                                            txn.objectStore(BY_SEQ_STORE).put(docInfo.data);

                                        dataReq.onsuccess = function(e) {
                                            docInfo.metadata.seq = e.target.result;
                                            // Current _rev is calculated from _rev_tree on read
                                            delete docInfo.metadata.rev;
                                            var deleted = utils.isDeleted(docInfo.metadata);
                                            var local = utils.isLocalId(docInfo.metadata.id);
                                            var metadata = utils.extend(true, {
                                                deletedOrLocal: (deleted || local) ? "1" : "0"
                                            }, docInfo.metadata);
                                            var metaDataReq = txn.objectStore(DOC_STORE).put(metadata);
                                            metaDataReq.onsuccess = function() {
                                                results.push(docInfo);
                                                utils.call(callback);
                                            };
                                        };
                                    };
                                }

                                if (!attachments.length) {
                                    finish();
                                }
                            }

                            function updateDoc(oldDoc, docInfo) {
                                var merged = merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);
                                var wasPreviouslyDeleted = utils.isDeleted(oldDoc);
                                var inConflict = (wasPreviouslyDeleted &&
                                    utils.isDeleted(docInfo.metadata)) ||
                                    (!wasPreviouslyDeleted && newEdits && merged.conflicts !== 'new_leaf');

                                if (inConflict) {
                                    results.push(makeErr(errors.REV_CONFLICT, docInfo._bulk_seq));
                                    return processDocs();
                                }

                                docInfo.metadata.rev_tree = merged.tree;
                                writeDoc(docInfo, processDocs);
                            }

                            function insertDoc(docInfo) {
                                // Cant insert new deleted documents
                                if ('was_delete' in opts && utils.isDeleted(docInfo.metadata)) {
                                    results.push(errors.MISSING_DOC);
                                    return processDocs();
                                }
                                writeDoc(docInfo, processDocs);
                            }

                            // Insert sequence number into the error so we can sort later
                            function makeErr(err, seq) {
                                err._bulk_seq = seq;
                                return err;
                            }

                            function saveAttachment(docInfo, digest, data, callback) {
                                var objectStore = txn.objectStore(ATTACH_STORE);
                                objectStore.get(digest).onsuccess = function(e) {
                                    var originalRefs = e.target.result && e.target.result.refs || {};
                                    var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');
                                    var newAtt = {
                                        digest: digest,
                                        body: data,
                                        refs: originalRefs
                                    };
                                    newAtt.refs[ref] = true;
                                    objectStore.put(newAtt).onsuccess = function(e) {
                                        utils.call(callback);
                                    };
                                };
                            }

                            var txn;
                            preprocessAttachments(function() {
                                txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE],
                                    'readwrite');
                                txn.onerror = idbError(callback);
                                txn.ontimeout = idbError(callback);
                                txn.oncomplete = complete;

                                processDocs();
                            });
                        };

                        function sortByBulkSeq(a, b) {
                            return a._bulk_seq - b._bulk_seq;
                        }

                        // First we look up the metadata in the ids database, then we fetch the
                        // current revision(s) from the by sequence store
                        api._get = function idb_get(id, opts, callback) {
                            var doc;
                            var metadata;
                            var err;
                            var txn;
                            opts = utils.extend(true, {}, opts);
                            if (opts.ctx) {
                                txn = opts.ctx;
                            } else {
                                txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
                            }

                            function finish() {
                                callback(err, {
                                    doc: doc,
                                    metadata: metadata,
                                    ctx: txn
                                });
                            }

                            txn.objectStore(DOC_STORE).get(id).onsuccess = function(e) {
                                metadata = e.target.result;
                                // we can determine the result here if:
                                // 1. there is no such document
                                // 2. the document is deleted and we don't ask about specific rev
                                // When we ask with opts.rev we expect the answer to be either
                                // doc (possibly with _deleted=true) or missing error
                                if (!metadata) {
                                    err = errors.MISSING_DOC;
                                    return finish();
                                }
                                if (utils.isDeleted(metadata) && !opts.rev) {
                                    err = errors.error(errors.MISSING_DOC, "deleted");
                                    return finish();
                                }

                                var rev = merge.winningRev(metadata);
                                var key = metadata.id + '::' + (opts.rev ? opts.rev : rev);
                                var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');

                                index.get(key).onsuccess = function(e) {
                                    doc = e.target.result;
                                    if (doc && doc._doc_id_rev) {
                                        delete(doc._doc_id_rev);
                                    }
                                    if (!doc) {
                                        err = errors.MISSING_DOC;
                                        return finish();
                                    }
                                    finish();
                                };
                            };
                        };

                        api._getAttachment = function(attachment, opts, callback) {
                            var result;
                            var txn;
                            opts = utils.extend(true, {}, opts);
                            if (opts.ctx) {
                                txn = opts.ctx;
                            } else {
                                txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
                            }
                            var digest = attachment.digest;
                            var type = attachment.content_type;

                            txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function(e) {
                                var data = e.target.result.body;
                                if (opts.encode) {
                                    if (blobSupport) {
                                        var reader = new FileReader();
                                        reader.onloadend = function(e) {
                                            var binary = utils.arrayBufferToBinaryString(this.result);
                                            result = btoa(binary);
                                            callback(null, result);
                                        };
                                        reader.readAsArrayBuffer(data);
                                    } else {
                                        result = data;
                                        callback(null, result);
                                    }
                                } else {
                                    if (blobSupport) {
                                        result = data;
                                    } else {
                                        data = utils.fixBinary(atob(data));
                                        result = utils.createBlob([data], {
                                            type: type
                                        });
                                    }
                                    callback(null, result);
                                }
                            };
                        };

                        function allDocsKeysQuery(totalRows, opts, callback) {
                            var keys = opts.keys;
                            var descending = 'descending' in opts ? opts.descending : false;

                            if (!keys.length) { // empty list is okay
                                callback(null, {
                                    offset: opts.skip,
                                    rows: [],
                                    total_rows: totalRows
                                });
                            } else {
                                // do a separate "key" query for each key in the keys array
                                var resultsToCollate = [];
                                keys.forEach(function(key) {
                                    var subOpts = utils.extend(true, {}, opts);
                                    subOpts.keys_request = true; // internal param, says this is a "keys" request
                                    subOpts.key = key;
                                    delete subOpts.keys;
                                    delete subOpts.skip;
                                    delete subOpts.limit;

                                    allDocsNormalQuery(totalRows, subOpts, function(err, res) {
                                        resultsToCollate.push({
                                            err: err,
                                            res: res,
                                            key: key
                                        });
                                        if (resultsToCollate.length === keys.length) {
                                            // all done, time to collate
                                            var keysToResults = {};
                                            for (var i = 0; i < resultsToCollate.length; i++) {
                                                var result = resultsToCollate[i];
                                                if (result.err) {
                                                    callback(err);
                                                    return;
                                                } else {
                                                    keysToResults[result.key] = result;
                                                }
                                            }
                                            var results = [];
                                            keys.forEach(function(key) {
                                                var result = keysToResults[key];
                                                if (result.res.rows.length) {
                                                    results.push(result.res.rows[0]); // only one result ever
                                                } else {
                                                    results.push({
                                                        "key": key,
                                                        "error": "not_found"
                                                    });
                                                }
                                            });
                                            if (descending) {
                                                results = results.reverse();
                                            }
                                            callback(null, {
                                                total_rows: totalRows,
                                                offset: opts.skip,
                                                rows: ('limit' in opts) ? results.slice(opts.skip, opts.limit + opts.skip) : (opts.skip > 0) ? results.slice(opts.skip) : results
                                            });
                                        }
                                    });
                                });
                            }
                        }

                        function allDocsNormalQuery(totalRows, opts, callback) {
                            var start = 'startkey' in opts ? opts.startkey : false;
                            var end = 'endkey' in opts ? opts.endkey : false;
                            var key = 'key' in opts ? opts.key : false;
                            var skip = opts.skip || 0;
                            var limit = typeof opts.limit === 'number' ? opts.limit : -1;

                            var descending = 'descending' in opts && opts.descending ? 'prev' : null;

                            var manualDescEnd = false;
                            if (descending && start && end) {
                                // unfortunately IDB has a quirk where IDBKeyRange.bound is invalid if the
                                // start is less than the end, even in descending mode.  Best bet
                                // is just to handle it manually in that case.
                                manualDescEnd = end;
                                end = false;
                            }

                            var keyRange;
                            try {
                                keyRange = start && end ? global.IDBKeyRange.bound(start, end) : start ? (descending ? global.IDBKeyRange.upperBound(start) : global.IDBKeyRange.lowerBound(start)) : end ? (descending ? global.IDBKeyRange.lowerBound(end) : global.IDBKeyRange.upperBound(end)) : key ? global.IDBKeyRange.only(key) : null;
                            } catch (e) {
                                if (e.name === "DataError" && e.code === 0) {
                                    // data error, start is less than end
                                    return callback(null, {
                                        total_rows: totalRows,
                                        offset: opts.skip,
                                        rows: []
                                    });
                                } else {
                                    return callback(errors.error(errors.IDB_ERROR, e.name, e.message));
                                }
                            }

                            var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');
                            transaction.oncomplete = function() {
                                callback(null, {
                                    total_rows: totalRows,
                                    offset: opts.skip,
                                    rows: results
                                });
                            };

                            var oStore = transaction.objectStore(DOC_STORE);
                            var oCursor = descending ? oStore.openCursor(keyRange, descending) : oStore.openCursor(keyRange);
                            var results = [];
                            oCursor.onsuccess = function(e) {
                                if (!e.target.result) {
                                    return;
                                }
                                var cursor = e.target.result;
                                var metadata = cursor.value;

                                function allDocsInner(metadata, data) {
                                    if (utils.isLocalId(metadata.id)) {
                                        return cursor['continue']();
                                    }
                                    var doc = {
                                        id: metadata.id,
                                        key: metadata.id,
                                        value: {
                                            rev: merge.winningRev(metadata)
                                        }
                                    };
                                    if (opts.include_docs) {
                                        doc.doc = data;
                                        doc.doc._rev = merge.winningRev(metadata);
                                        if (doc.doc._doc_id_rev) {
                                            delete(doc.doc._doc_id_rev);
                                        }
                                        if (opts.conflicts) {
                                            doc.doc._conflicts = merge.collectConflicts(metadata);
                                        }
                                        for (var att in doc.doc._attachments) {
                                            if (doc.doc._attachments.hasOwnProperty(att)) {
                                                doc.doc._attachments[att].stub = true;
                                            }
                                        }
                                    }
                                    if (opts.keys_request) {
                                        // deleted docs are okay with keys_requests
                                        if (utils.isDeleted(metadata)) {
                                            doc.value.deleted = true;
                                            doc.doc = null;
                                        }
                                        results.push(doc);
                                    } else if (!utils.isDeleted(metadata) && skip-- <= 0) {
                                        if (manualDescEnd && doc.key < manualDescEnd) {
                                            return;
                                        }
                                        results.push(doc);
                                        if (--limit === 0) {
                                            return;
                                        }
                                    }
                                    cursor['continue']();
                                }

                                if (!opts.include_docs) {
                                    allDocsInner(metadata);
                                } else {
                                    var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');
                                    var mainRev = merge.winningRev(metadata);
                                    var key = metadata.id + "::" + mainRev;
                                    index.get(key).onsuccess = function(event) {
                                        allDocsInner(cursor.value, event.target.result);
                                    };
                                }
                            };
                        }

                        api._allDocs = function idb_allDocs(opts, callback) {

                            // first count the total_rows using the undeleted/non-local count
                            var txn = idb.transaction([DOC_STORE], 'readonly');

                            var totalRows;

                            function countUndeletedNonlocalDocs(e) {
                                totalRows = e.target.result;
                            }

                            var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
                            index.count(global.IDBKeyRange.only("0")).onsuccess = countUndeletedNonlocalDocs;

                            txn.onerror = idbError(callback);

                            txn.oncomplete = function() {
                                if (opts.limit === 0) {
                                    return callback(null, {
                                        total_rows: totalRows,
                                        offset: opts.skip,
                                        rows: []
                                    });
                                } else if ('keys' in opts) {
                                    allDocsKeysQuery(totalRows, opts, callback);
                                } else {
                                    allDocsNormalQuery(totalRows, opts, callback);
                                }
                            };
                        };

                        api._info = function idb_info(callback) {
                            var count = 0;
                            var update_seq = 0;
                            var txn = idb.transaction([DOC_STORE, META_STORE], 'readonly');

                            function fetchUpdateSeq(e) {
                                update_seq = e.target.result && e.target.result.updateSeq || 0;
                            }

                            function countDocs(e) {
                                var cursor = e.target.result;
                                if (!cursor) {
                                    txn.objectStore(META_STORE).get(META_STORE).onsuccess = fetchUpdateSeq;
                                    return;
                                }
                                if (cursor.value.deleted !== true) {
                                    count++;
                                }
                                cursor['continue']();
                            }

                            txn.oncomplete = function() {
                                callback(null, {
                                    db_name: name,
                                    doc_count: count,
                                    update_seq: update_seq
                                });
                            };

                            txn.objectStore(DOC_STORE).openCursor().onsuccess = countDocs;
                        };

                        api._changes = function idb_changes(opts) {
                            opts = utils.extend(true, {}, opts);

                            if (opts.continuous) {
                                var id = name + ':' + utils.uuid();
                                IdbPouch.Changes.addListener(name, id, api, opts);
                                IdbPouch.Changes.notify(name);
                                return {
                                    cancel: function() {
                                        IdbPouch.Changes.removeListener(name, id);
                                    }
                                };
                            }

                            var descending = opts.descending ? 'prev' : null;
                            var last_seq = 0;

                            // Ignore the `since` parameter when `descending` is true
                            opts.since = opts.since && !descending ? opts.since : 0;

                            var results = [],
                                resultIndices = {}, dedupResults = [];
                            var txn;

                            function fetchChanges() {
                                txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);
                                txn.oncomplete = onTxnComplete;

                                var req;

                                if (descending) {
                                    req = txn.objectStore(BY_SEQ_STORE)
                                        .openCursor(global.IDBKeyRange.lowerBound(opts.since, true), descending);
                                } else {
                                    req = txn.objectStore(BY_SEQ_STORE)
                                        .openCursor(global.IDBKeyRange.lowerBound(opts.since, true));
                                }

                                req.onsuccess = onsuccess;
                                req.onerror = onerror;
                            }

                            fetchChanges();

                            function onsuccess(event) {
                                if (!event.target.result) {
                                    // Filter out null results casued by deduping
                                    for (var i = 0, l = results.length; i < l; i++) {
                                        var result = results[i];
                                        if (result) {
                                            dedupResults.push(result);
                                        }
                                    }
                                    return false;
                                }

                                var cursor = event.target.result;

                                // Try to pre-emptively dedup to save us a bunch of idb calls
                                var changeId = cursor.value._id;
                                var changeIdIndex = resultIndices[changeId];
                                if (changeIdIndex !== undefined) {
                                    results[changeIdIndex].seq = cursor.key;
                                    // update so it has the later sequence number
                                    results.push(results[changeIdIndex]);
                                    results[changeIdIndex] = null;
                                    resultIndices[changeId] = results.length - 1;
                                    return cursor['continue']();
                                }

                                var index = txn.objectStore(DOC_STORE);
                                index.get(cursor.value._id).onsuccess = function(event) {
                                    var metadata = event.target.result;
                                    if (utils.isLocalId(metadata.id)) {
                                        return cursor['continue']();
                                    }

                                    if (last_seq < metadata.seq) {
                                        last_seq = metadata.seq;
                                    }

                                    var mainRev = merge.winningRev(metadata);
                                    var key = metadata.id + "::" + mainRev;
                                    var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');
                                    index.get(key).onsuccess = function(docevent) {
                                        var doc = docevent.target.result;
                                        delete doc['_doc_id_rev'];

                                        doc._rev = mainRev;
                                        var change = opts.processChange(doc, metadata, opts);
                                        change.seq = cursor.key;

                                        // Dedupe the changes feed
                                        var changeId = change.id,
                                            changeIdIndex = resultIndices[changeId];
                                        if (changeIdIndex !== undefined) {
                                            results[changeIdIndex] = null;
                                        }
                                        results.push(change);
                                        resultIndices[changeId] = results.length - 1;
                                        cursor['continue']();
                                    };
                                };
                            }

                            function onTxnComplete() {
                                utils.processChanges(opts, dedupResults, last_seq);
                            }
                        };

                        api._close = function(callback) {
                            if (idb === null) {
                                return callback(errors.NOT_OPEN);
                            }

                            // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
                            // "Returns immediately and closes the connection in a separate thread..."
                            idb.close();
                            callback();
                        };

                        api._getRevisionTree = function(docId, callback) {
                            var txn = idb.transaction([DOC_STORE], 'readonly');
                            var req = txn.objectStore(DOC_STORE).get(docId);
                            req.onsuccess = function(event) {
                                var doc = event.target.result;
                                if (!doc) {
                                    callback(errors.MISSING_DOC);
                                } else {
                                    callback(null, doc.rev_tree);
                                }
                            };
                        };

                        // This function removes revisions of document docId
                        // which are listed in revs and sets this document
                        // revision to to rev_tree
                        api._doCompaction = function(docId, rev_tree, revs, callback) {
                            var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readwrite');

                            var index = txn.objectStore(DOC_STORE);
                            index.get(docId).onsuccess = function(event) {
                                var metadata = event.target.result;
                                metadata.rev_tree = rev_tree;

                                var count = revs.length;
                                revs.forEach(function(rev) {
                                    var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');
                                    var key = docId + "::" + rev;
                                    index.getKey(key).onsuccess = function(e) {
                                        var seq = e.target.result;
                                        if (!seq) {
                                            return;
                                        }
                                        txn.objectStore(BY_SEQ_STORE)['delete'](seq);

                                        count--;
                                        if (!count) {
                                            if (metadata) {
                                                var deleted = utils.isDeleted(metadata);
                                                var local = utils.isLocalId(metadata.id);
                                                metadata = utils.extend(true, {
                                                    deletedOrLocal: (deleted || local) ? "1" : "0"
                                                }, metadata);
                                            }
                                            txn.objectStore(DOC_STORE).put(metadata);
                                        }
                                    };
                                });
                            };
                            txn.oncomplete = function() {
                                utils.call(callback);
                            };
                        };

                    }

                    IdbPouch.valid = function() {
                        return global.indexedDB && isModernIdb();
                    };

                    IdbPouch.destroy = utils.toPromise(function(name, opts, callback) {
                        if (!('openReqList' in IdbPouch)) {
                            IdbPouch.openReqList = {};
                        }
                        IdbPouch.Changes.clearListeners(name);

                        //Close open request for "name" database to fix ie delay.
                        if (IdbPouch.openReqList[name] && IdbPouch.openReqList[name].result) {
                            IdbPouch.openReqList[name].result.close();
                        }
                        var req = global.indexedDB.deleteDatabase(name);

                        req.onsuccess = function() {
                            //Remove open request from the list.
                            if (IdbPouch.openReqList[name]) {
                                IdbPouch.openReqList[name] = null;
                            }
                            callback();
                        };

                        req.onerror = idbError(callback);
                    });

                    IdbPouch.Changes = new utils.Changes();

                    module.exports = IdbPouch;

                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {
                "../deps/errors": 8,
                "../merge": 14,
                "../utils": 18
            }
        ],
        4: [
            function(_dereq_, module, exports) {
                (function(global) {
                    'use strict';

                    var utils = _dereq_('../utils');
                    var merge = _dereq_('../merge');
                    var errors = _dereq_('../deps/errors');

                    function quote(str) {
                        return "'" + str + "'";
                    }

                    var cachedDatabases = {};

                    var openDB = utils.getArguments(function(args) {
                        if (typeof global !== 'undefined') {
                            if (global.navigator && global.navigator.sqlitePlugin &&
                                global.navigator.sqlitePlugin.openDatabase) {
                                return navigator.sqlitePlugin.openDatabase
                                    .apply(navigator.sqlitePlugin, args);
                            } else if (global.sqlitePlugin && global.sqlitePlugin.openDatabase) {
                                return global.sqlitePlugin.openDatabase
                                    .apply(global.sqlitePlugin, args);
                            } else {
                                var db = cachedDatabases[args[0]];
                                if (!db) {
                                    db = cachedDatabases[args[0]] = global.openDatabase.apply(global, args);
                                }
                                return db;
                            }
                        }
                    });

                    var POUCH_VERSION = 1;
                    var POUCH_SIZE = 5 * 1024 * 1024;
                    var ADAPTER_VERSION = 2; // used to manage migrations

                    // The object stores created for each database
                    // DOC_STORE stores the document meta data, its revision history and state
                    var DOC_STORE = quote('document-store');
                    // BY_SEQ_STORE stores a particular version of a document, keyed by its
                    // sequence id
                    var BY_SEQ_STORE = quote('by-sequence');
                    // Where we store attachments
                    var ATTACH_STORE = quote('attach-store');
                    var META_STORE = quote('metadata-store');

                    // these indexes cover the ground for most allDocs queries
                    var BY_SEQ_STORE_DELETED_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \'by-seq-deleted-idx\' ON ' +
                        BY_SEQ_STORE + ' (seq, deleted)';
                    var DOC_STORE_LOCAL_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \'doc-store-local-idx\' ON ' +
                        DOC_STORE + ' (local, id)';
                    var DOC_STORE_WINNINGSEQ_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \'doc-winningseq-idx\' ON ' +
                        DOC_STORE + ' (winningseq)';


                    function unknownError(callback) {
                        return function(event) {
                            // event may actually be a SQLError object, so report is as such
                            var errorNameMatch = event && event.constructor.toString()
                                .match(/function ([^\(]+)/);
                            var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;
                            var errorReason = event.target || event.message;
                            callback(errors.error(errors.WSQ_ERROR, errorReason, errorName));
                        };
                    }

                    function decodeUtf8(str) {
                        return decodeURIComponent(window.escape(str));
                    }

                    function parseHexString(str, encoding) {
                        var result = '';
                        var charWidth = encoding === 'UTF-8' ? 2 : 4;
                        for (var i = 0, len = str.length; i < len; i += charWidth) {
                            var substring = str.substring(i, i + charWidth);
                            if (charWidth === 4) { // UTF-16, twiddle the bits
                                substring = substring.substring(2, 4) + substring.substring(0, 2);
                            }
                            result += String.fromCharCode(parseInt(substring, 16));
                        }
                        result = encoding === 'UTF-8' ? decodeUtf8(result) : result;
                        return result;
                    }

                    function WebSqlPouch(opts, callback) {
                        var api = this;
                        var instanceId = null;
                        var name = opts.name;
                        var idRequests = [];
                        var encoding;

                        var db = openDB(name, POUCH_VERSION, name, POUCH_SIZE);
                        if (!db) {
                            return callback(errors.UNKNOWN_ERROR);
                        }

                        function dbCreated() {
                            // note the db name in case the browser upgrades to idb
                            if (utils.hasLocalStorage()) {
                                global.localStorage['_pouch__websqldb_' + name] = true;
                            }
                            callback(null, api);
                        }

                        // In this migration, we added the 'deleted' and 'local' columns to the by-seq and doc store tables.
                        // To preserve existing user data, we re-process all the existing JSON
                        // and add these values.
                        // Called migration2 because it corresponds to adapter version (db_version) #2
                        function runMigration2(tx) {

                            tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL); // index used for the join in the allDocs query

                            tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE + ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function() {
                                tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
                                tx.executeSql('ALTER TABLE ' + DOC_STORE + ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function() {
                                    tx.executeSql(DOC_STORE_LOCAL_INDEX_SQL);

                                    var sql = 'SELECT ' + DOC_STORE + '.winningseq AS seq, ' + DOC_STORE + '.json AS metadata FROM ' +
                                        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +
                                        DOC_STORE + '.winningseq';

                                    tx.executeSql(sql, [], function(tx, result) {

                                        var deleted = [];
                                        var local = [];

                                        for (var i = 0; i < result.rows.length; i++) {
                                            var item = result.rows.item(i);
                                            var seq = item.seq;
                                            var metadata = JSON.parse(item.metadata);
                                            if (utils.isDeleted(metadata)) {
                                                deleted.push(seq);
                                            }
                                            if (utils.isLocalId(metadata.id)) {
                                                local.push(metadata.id);
                                            }
                                        }

                                        tx.executeSql('UPDATE ' + DOC_STORE + 'SET local = 1 WHERE id IN (' + local.map(function() {
                                            return '?';
                                        }).join(',') + ')', local);
                                        tx.executeSql('UPDATE ' + BY_SEQ_STORE + ' SET deleted = 1 WHERE seq IN (' + deleted.map(function() {
                                            return '?';
                                        }).join(',') + ')', deleted);
                                    });
                                });
                            });
                        }

                        function onGetInstanceId(tx) {
                            while (idRequests.length > 0) {
                                var idCallback = idRequests.pop();
                                idCallback(null, instanceId);
                            }
                            checkDbEncoding(tx);
                        }

                        function checkDbEncoding(tx) {
                            // check db encoding - utf-8 (chrome, opera) or utf-16 (safari)?
                            tx.executeSql('SELECT dbid, hex(dbid) AS hexId FROM ' + META_STORE, [],
                                function(err, result) {
                                    var id = result.rows.item(0).dbid;
                                    var hexId = result.rows.item(0).hexId;
                                    encoding = (hexId.length === id.length * 2) ? 'UTF-8' : 'UTF-16';
                                }
                            );
                        }

                        function onGetVersion(tx, dbVersion) {
                            if (dbVersion === 0) {
                                // initial schema

                                var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +
                                    ' (update_seq, dbid, db_version INTEGER)';
                                var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +
                                    ' (digest, json, body BLOB)';
                                var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +
                                    ' (id unique, seq, json, winningseq, local TINYINT(1))';
                                var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +
                                    ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, doc_id_rev UNIQUE, json, deleted TINYINT(1))';

                                // creates
                                tx.executeSql(attach);
                                tx.executeSql(doc, [], function() {
                                    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);
                                    tx.executeSql(DOC_STORE_LOCAL_INDEX_SQL);
                                });
                                tx.executeSql(seq, [], function() {
                                    tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
                                });
                                tx.executeSql(meta, [], function() {
                                    // mark the update_seq, db version, and new dbid
                                    var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq, db_version, dbid) VALUES (?, ?, ?)';
                                    instanceId = utils.uuid();
                                    tx.executeSql(initSeq, [0, ADAPTER_VERSION, instanceId]);
                                    onGetInstanceId(tx);
                                });
                            } else { // version > 0

                                if (dbVersion === 1) {
                                    runMigration2(tx);
                                    // mark the db version within this transaction
                                    tx.executeSql('UPDATE ' + META_STORE + ' SET db_version = ' + ADAPTER_VERSION);
                                } // in the future, add more migrations here

                                // notify db.id() callers
                                tx.executeSql('SELECT dbid FROM ' + META_STORE, [], function(tx, result) {
                                    instanceId = result.rows.item(0).dbid;
                                    onGetInstanceId(tx);
                                });
                            }
                        }

                        function setup() {

                            db.transaction(function(tx) {
                                // first get the version
                                tx.executeSql('SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE, [], function(tx, result) {
                                    if (!result.rows.length) {
                                        // database hasn't even been created yet (version 0)
                                        onGetVersion(tx, 0);
                                    } else if (!/db_version/.test(result.rows.item(0).sql)) {
                                        // table was created, but without the new db_version column, so add it.
                                        tx.executeSql('ALTER TABLE ' + META_STORE + ' ADD COLUMN db_version INTEGER', [], function() {
                                            onGetVersion(tx, 1); // before version 2, this column didn't even exist
                                        });
                                    } else { // column exists, we can safely get it
                                        tx.executeSql('SELECT db_version FROM ' + META_STORE, [], function(tx, result) {
                                            var dbVersion = result.rows.item(0).db_version;
                                            onGetVersion(tx, dbVersion);
                                        });
                                    }
                                });
                            }, unknownError(callback), dbCreated);
                        }

                        if (utils.isCordova() && typeof global !== 'undefined') {
                            //to wait until custom api is made in pouch.adapters before doing setup
                            global.addEventListener(name + '_pouch', function cordova_init() {
                                global.removeEventListener(name + '_pouch', cordova_init, false);
                                setup();
                            }, false);
                        } else {
                            setup();
                        }


                        api.type = function() {
                            return 'websql';
                        };

                        api._id = utils.toPromise(function(callback) {
                            callback(null, instanceId);
                        });

                        api._info = function(callback) {
                            db.transaction(function(tx) {
                                var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;
                                tx.executeSql(sql, [], function(tx, result) {
                                    var doc_count = result.rows.item(0).count;
                                    var updateseq = 'SELECT update_seq FROM ' + META_STORE;
                                    tx.executeSql(updateseq, [], function(tx, result) {
                                        var update_seq = result.rows.item(0).update_seq;
                                        callback(null, {
                                            db_name: name,
                                            doc_count: doc_count,
                                            update_seq: update_seq
                                        });
                                    });
                                });
                            });
                        };

                        api._bulkDocs = function(req, opts, callback) {

                            var newEdits = opts.new_edits;
                            var userDocs = req.docs;
                            var docsWritten = 0;

                            // Parse the docs, give them a sequence number for the result
                            var docInfos = userDocs.map(function(doc, i) {
                                var newDoc = utils.parseDoc(doc, newEdits);
                                newDoc._bulk_seq = i;
                                return newDoc;
                            });

                            var docInfoErrors = docInfos.filter(function(docInfo) {
                                return docInfo.error;
                            });
                            if (docInfoErrors.length) {
                                return callback(docInfoErrors[0]);
                            }

                            var tx;
                            var results = [];
                            var fetchedDocs = {};

                            function sortByBulkSeq(a, b) {
                                return a._bulk_seq - b._bulk_seq;
                            }

                            function complete(event) {
                                var aresults = [];
                                results.sort(sortByBulkSeq);
                                results.forEach(function(result) {
                                    delete result._bulk_seq;
                                    if (result.error) {
                                        aresults.push(result);
                                        return;
                                    }
                                    var metadata = result.metadata;
                                    var rev = merge.winningRev(metadata);

                                    aresults.push({
                                        ok: true,
                                        id: metadata.id,
                                        rev: rev
                                    });

                                    if (utils.isLocalId(metadata.id)) {
                                        return;
                                    }

                                    docsWritten++;

                                    WebSqlPouch.Changes.notify(name);
                                    WebSqlPouch.Changes.notifyLocalWindows(name);
                                });

                                var updateseq = 'SELECT update_seq FROM ' + META_STORE;
                                tx.executeSql(updateseq, [], function(tx, result) {
                                    var update_seq = result.rows.item(0).update_seq + docsWritten;
                                    var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';
                                    tx.executeSql(sql, [update_seq], function() {
                                        callback(null, aresults);
                                    });
                                });
                            }

                            function preprocessAttachment(att, finish) {
                                if (att.stub) {
                                    return finish();
                                }
                                if (typeof att.data === 'string') {
                                    try {
                                        att.data = atob(att.data);
                                    } catch (e) {
                                        var err = errors.error(errors.BAD_ARG,
                                            "Attachments need to be base64 encoded");
                                        return callback(err);
                                    }
                                    var data = utils.fixBinary(att.data);
                                    att.data = utils.createBlob([data], {
                                        type: att.content_type
                                    });
                                }
                                var reader = new FileReader();
                                reader.onloadend = function(e) {
                                    var binary = utils.arrayBufferToBinaryString(this.result);
                                    att.data = binary;
                                    att.digest = 'md5-' + utils.Crypto.MD5(binary);
                                    finish();
                                };
                                reader.readAsArrayBuffer(att.data);
                            }

                            function preprocessAttachments(callback) {
                                if (!docInfos.length) {
                                    return callback();
                                }

                                var docv = 0;

                                docInfos.forEach(function(docInfo) {
                                    var attachments = docInfo.data && docInfo.data._attachments ?
                                        Object.keys(docInfo.data._attachments) : [];
                                    var recv = 0;

                                    if (!attachments.length) {
                                        return done();
                                    }

                                    function processedAttachment() {
                                        recv++;
                                        if (recv === attachments.length) {
                                            done();
                                        }
                                    }

                                    for (var key in docInfo.data._attachments) {
                                        if (docInfo.data._attachments.hasOwnProperty(key)) {
                                            preprocessAttachment(docInfo.data._attachments[key], processedAttachment);
                                        }
                                    }
                                });

                                function done() {
                                    docv++;
                                    if (docInfos.length === docv) {
                                        callback();
                                    }
                                }
                            }

                            function writeDoc(docInfo, callback, isUpdate) {

                                function finish() {
                                    var data = docInfo.data;
                                    var doc_id_rev = data._id + "::" + data._rev;
                                    var deleted = utils.isDeleted(docInfo.metadata, docInfo.metadata.rev) ? 1 : 0;
                                    var fetchSql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?;';

                                    tx.executeSql(fetchSql, [doc_id_rev], function(err, res) {
                                        var sql, sqlArgs;
                                        if (res.rows.length) {
                                            sql = 'UPDATE ' + BY_SEQ_STORE +
                                                ' SET json=?, deleted=? WHERE doc_id_rev=?;';
                                            sqlArgs = [JSON.stringify(data), deleted, doc_id_rev];
                                            tx.executeSql(sql, sqlArgs, function(tx) {
                                                dataWritten(tx, res.rows.item(0).seq);
                                            });
                                        } else {
                                            sql = 'INSERT INTO ' + BY_SEQ_STORE +
                                                ' (doc_id_rev, json, deleted) VALUES (?, ?, ?);';
                                            sqlArgs = [doc_id_rev, JSON.stringify(data), deleted];
                                            tx.executeSql(sql, sqlArgs, function(tx, result) {
                                                dataWritten(tx, result.insertId);
                                            });
                                        }
                                    });
                                }

                                function collectResults(attachmentErr) {
                                    if (!err) {
                                        if (attachmentErr) {
                                            err = attachmentErr;
                                            callback(err);
                                        } else if (recv === attachments.length) {
                                            finish();
                                        }
                                    }
                                }

                                var err = null;
                                var recv = 0;

                                docInfo.data._id = docInfo.metadata.id;
                                docInfo.data._rev = docInfo.metadata.rev;

                                if (utils.isDeleted(docInfo.metadata, docInfo.metadata.rev)) {
                                    docInfo.data._deleted = true;
                                }

                                var attachments = docInfo.data._attachments ?
                                    Object.keys(docInfo.data._attachments) : [];

                                function attachmentSaved(err) {
                                    recv++;
                                    collectResults(err);
                                }

                                for (var key in docInfo.data._attachments) {
                                    if (!docInfo.data._attachments[key].stub) {
                                        var data = docInfo.data._attachments[key].data;
                                        delete docInfo.data._attachments[key].data;
                                        var digest = docInfo.data._attachments[key].digest;
                                        saveAttachment(docInfo, digest, data, attachmentSaved);
                                    } else {
                                        recv++;
                                        collectResults();
                                    }
                                }

                                if (!attachments.length) {
                                    finish();
                                }

                                function dataWritten(tx, seq) {
                                    docInfo.metadata.seq = seq;
                                    delete docInfo.metadata.rev;

                                    var mainRev = merge.winningRev(docInfo.metadata);

                                    var sql = isUpdate ?
                                        'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' +
                                        BY_SEQ_STORE + ' WHERE doc_id_rev=?) WHERE id=?' :
                                        'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json, local) VALUES (?, ?, ?, ?, ?);';
                                    var metadataStr = JSON.stringify(docInfo.metadata);
                                    var key = docInfo.metadata.id + "::" + mainRev;
                                    var local = utils.isLocalId(docInfo.metadata.id) ? 1 : 0;
                                    var params = isUpdate ?
                                        [seq, metadataStr, key, docInfo.metadata.id] :
                                        [docInfo.metadata.id, seq, seq, metadataStr, local];
                                    tx.executeSql(sql, params, function(tx, result) {
                                        results.push(docInfo);
                                        callback();
                                    });
                                }
                            }

                            function updateDoc(oldDoc, docInfo) {
                                var merged = merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);
                                var inConflict = (utils.isDeleted(oldDoc) &&
                                    utils.isDeleted(docInfo.metadata)) ||
                                    (!utils.isDeleted(oldDoc) &&
                                    newEdits && merged.conflicts !== 'new_leaf');

                                if (inConflict) {
                                    results.push(makeErr(errors.REV_CONFLICT, docInfo._bulk_seq));
                                    return processDocs();
                                }

                                docInfo.metadata.rev_tree = merged.tree;
                                writeDoc(docInfo, processDocs, true);
                            }

                            function insertDoc(docInfo) {
                                // Cant insert new deleted documents
                                if ('was_delete' in opts && utils.isDeleted(docInfo.metadata)) {
                                    results.push(errors.MISSING_DOC);
                                    return processDocs();
                                }
                                writeDoc(docInfo, processDocs, false);
                            }

                            function processDocs() {
                                if (!docInfos.length) {
                                    return complete();
                                }
                                var currentDoc = docInfos.shift();
                                var id = currentDoc.metadata.id;
                                if (id in fetchedDocs) {
                                    updateDoc(fetchedDocs[id], currentDoc);
                                } else {
                                    // if we have newEdits=false then we can update the same
                                    // document twice in a single bulk docs call
                                    fetchedDocs[id] = currentDoc.metadata;
                                    insertDoc(currentDoc);
                                }
                            }

                            // Insert sequence number into the error so we can sort later
                            function makeErr(err, seq) {
                                err._bulk_seq = seq;
                                return err;
                            }

                            function saveAttachment(docInfo, digest, data, callback) {
                                var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');
                                var newAtt = {
                                    digest: digest
                                };
                                var sql = 'SELECT digest, json FROM ' + ATTACH_STORE + ' WHERE digest=?';
                                tx.executeSql(sql, [digest], function(tx, result) {
                                    if (!result.rows.length) {
                                        newAtt.refs = {};
                                        newAtt.refs[ref] = true;
                                        sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json, body) VALUES (?, ?, ?)';
                                        tx.executeSql(sql, [digest, JSON.stringify(newAtt), data], function() {
                                            callback();
                                        });
                                    } else {
                                        newAtt.refs = JSON.parse(result.rows.item(0).json).refs;
                                        sql = 'UPDATE ' + ATTACH_STORE + ' SET json=?, body=? WHERE digest=?';
                                        tx.executeSql(sql, [JSON.stringify(newAtt), data, digest], function() {
                                            callback();
                                        });
                                    }
                                });
                            }

                            function metadataFetched(tx, results) {
                                for (var j = 0; j < results.rows.length; j++) {
                                    var row = results.rows.item(j);
                                    var id = parseHexString(row.hexId, encoding);
                                    fetchedDocs[id] = JSON.parse(row.json);
                                }
                                processDocs();
                            }

                            preprocessAttachments(function() {
                                db.transaction(function(txn) {
                                    tx = txn;
                                    var sql = 'SELECT hex(id) AS hexId, json FROM ' + DOC_STORE + ' WHERE id IN ' +
                                        '(' + docInfos.map(function() {
                                            return '?';
                                        }).join(',') + ')';
                                    var queryArgs = docInfos.map(function(d) {
                                        return d.metadata.id;
                                    });
                                    tx.executeSql(sql, queryArgs, metadataFetched);
                                }, unknownError(callback));
                            });
                        };

                        api._get = function(id, opts, callback) {
                            opts = utils.extend(true, {}, opts);
                            var doc;
                            var metadata;
                            var err;
                            if (!opts.ctx) {
                                db.transaction(function(txn) {
                                    opts.ctx = txn;
                                    api._get(id, opts, callback);
                                });
                                return;
                            }
                            var tx = opts.ctx;

                            function finish() {
                                callback(err, {
                                    doc: doc,
                                    metadata: metadata,
                                    ctx: tx
                                });
                            }

                            var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';
                            tx.executeSql(sql, [id], function(a, results) {
                                if (!results.rows.length) {
                                    err = errors.MISSING_DOC;
                                    return finish();
                                }
                                metadata = JSON.parse(results.rows.item(0).json);
                                if (utils.isDeleted(metadata) && !opts.rev) {
                                    err = errors.error(errors.MISSING_DOC, "deleted");
                                    return finish();
                                }

                                var rev = merge.winningRev(metadata);
                                var key = opts.rev ? opts.rev : rev;
                                key = metadata.id + '::' + key;
                                var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?';
                                tx.executeSql(sql, [key], function(tx, results) {
                                    if (!results.rows.length) {
                                        err = errors.MISSING_DOC;
                                        return finish();
                                    }
                                    doc = JSON.parse(results.rows.item(0).json);

                                    finish();
                                });
                            });
                        };

                        api._allDocs = function(opts, callback) {
                            var results = [];
                            var resultsMap = {};
                            var totalRows;

                            var from = BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +
                                DOC_STORE + '.winningseq';

                            var start = 'startkey' in opts ? opts.startkey : false;
                            var end = 'endkey' in opts ? opts.endkey : false;
                            var key = 'key' in opts ? opts.key : false;
                            var descending = 'descending' in opts ? opts.descending : false;
                            var keys = 'keys' in opts ? opts.keys : false;
                            var limit = 'limit' in opts ? opts.limit : false;
                            var offset = 'skip' in opts ? opts.skip : false;

                            var sqlArgs = [];
                            var criteria = [DOC_STORE + '.local = 0'];

                            if (key !== false) {
                                criteria.push(DOC_STORE + '.id = ?');
                                sqlArgs.push(key);
                            } else if (keys !== false) {
                                criteria.push(DOC_STORE + '.id in (' + keys.map(function() {
                                    return '?';
                                }).join(',') + ')');
                                sqlArgs = sqlArgs.concat(keys);
                            } else if (start !== false || end !== false) {
                                if (start !== false) {
                                    criteria.push(DOC_STORE + '.id ' + (descending ? '<=' : '>=') + ' ?');
                                    sqlArgs.push(start);
                                }
                                if (end !== false) {
                                    criteria.push(DOC_STORE + '.id ' + (descending ? '>=' : '<=') + ' ?');
                                    sqlArgs.push(end);
                                }
                                if (key !== false) {
                                    criteria.push(DOC_STORE + '.id = ?');
                                    sqlArgs.push(key);
                                }
                            }

                            if (keys === false) {
                                // report deleted if keys are specified
                                criteria.push(BY_SEQ_STORE + '.deleted = 0');
                            }

                            db.transaction(function(tx) {

                                // first count up the total rows
                                var sql = 'SELECT COUNT(' + DOC_STORE + '.id) AS \'num\' FROM ' +
                                    from + ' WHERE ' + BY_SEQ_STORE + '.deleted = 0 AND ' +
                                // local docs are e.g. '_local_foo'
                                DOC_STORE + '.local = 0';

                                tx.executeSql(sql, [], function(tx, result) {
                                    totalRows = result.rows.item(0).num;

                                    if (limit === 0) {
                                        return;
                                    }

                                    // then actually fetch the documents

                                    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +
                                        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' + from;

                                    if (criteria.length) {
                                        sql += ' WHERE ' + criteria.join(' AND ');
                                    }
                                    sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');
                                    if (limit !== false) {
                                        sql += ' LIMIT ' + limit;
                                    }
                                    if (offset !== false && offset > 0) {
                                        if (limit === false) {
                                            // sqlite requires limit with offset, -1 acts as infinity here
                                            sql += ' LIMIT -1';
                                        }
                                        sql += ' OFFSET ' + offset;
                                    }

                                    tx.executeSql(sql, sqlArgs, function(tx, result) {
                                        for (var i = 0, l = result.rows.length; i < l; i++) {
                                            var doc = result.rows.item(i);
                                            var metadata = JSON.parse(doc.metadata);
                                            var data = JSON.parse(doc.data);
                                            doc = {
                                                id: metadata.id,
                                                key: metadata.id,
                                                value: {
                                                    rev: merge.winningRev(metadata)
                                                }
                                            };
                                            if (opts.include_docs) {
                                                doc.doc = data;
                                                doc.doc._rev = merge.winningRev(metadata);
                                                if (opts.conflicts) {
                                                    doc.doc._conflicts = merge.collectConflicts(metadata);
                                                }
                                                for (var att in doc.doc._attachments) {
                                                    if (doc.doc._attachments.hasOwnProperty(att)) {
                                                        doc.doc._attachments[att].stub = true;
                                                    }
                                                }
                                            }
                                            if ('keys' in opts) {
                                                if (opts.keys.indexOf(metadata.id) > -1) {
                                                    if (utils.isDeleted(metadata)) {
                                                        doc.value.deleted = true;
                                                        doc.doc = null;
                                                    }
                                                    resultsMap[doc.id] = doc;
                                                }
                                            } else {
                                                results.push(doc);
                                            }
                                        }
                                    });
                                });
                            }, unknownError(callback), function() {
                                if (limit !== 0 && 'keys' in opts) {
                                    opts.keys.forEach(function(key) {
                                        if (key in resultsMap) {
                                            results.push(resultsMap[key]);
                                        } else {
                                            results.push({
                                                "key": key,
                                                "error": "not_found"
                                            });
                                        }
                                    });
                                    if (opts.descending) {
                                        results.reverse();
                                    }
                                }
                                callback(null, {
                                    total_rows: totalRows,
                                    offset: opts.skip,
                                    rows: results
                                });
                            });
                        };

                        api._changes = function idb_changes(opts) {
                            opts = utils.extend(true, {}, opts);

                            if (opts.continuous) {
                                var id = name + ':' + utils.uuid();
                                WebSqlPouch.Changes.addListener(name, id, api, opts);
                                WebSqlPouch.Changes.notify(name);
                                return {
                                    cancel: function() {
                                        WebSqlPouch.Changes.removeListener(name, id);
                                    }
                                };
                            }

                            var descending = opts.descending;

                            // Ignore the `since` parameter when `descending` is true
                            opts.since = opts.since && !descending ? opts.since : 0;

                            var results = [];

                            function fetchChanges() {
                                var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +
                                    BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +
                                    BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +
                                    DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.since +
                                    ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');

                                db.transaction(function(tx) {
                                    tx.executeSql(sql, [], function(tx, result) {
                                        var last_seq = 0;
                                        for (var i = 0, l = result.rows.length; i < l; i++) {
                                            var res = result.rows.item(i);
                                            var metadata = JSON.parse(res.metadata);
                                            if (!utils.isLocalId(metadata.id)) {
                                                if (last_seq < res.seq) {
                                                    last_seq = res.seq;
                                                }
                                                var doc = JSON.parse(res.data);
                                                var change = opts.processChange(doc, metadata, opts);
                                                change.seq = res.seq;

                                                results.push(change);
                                            }
                                        }
                                        utils.processChanges(opts, results, last_seq);
                                    });
                                });
                            }

                            fetchChanges();
                        };

                        api._close = function(callback) {
                            //WebSQL databases do not need to be closed
                            callback();
                        };

                        api._getAttachment = function(attachment, opts, callback) {
                            var res;
                            var tx = opts.ctx;
                            var digest = attachment.digest;
                            var type = attachment.content_type;
                            var sql = 'SELECT hex(body) as body FROM ' + ATTACH_STORE + ' WHERE digest=?';
                            tx.executeSql(sql, [digest], function(tx, result) {
                                // sqlite normally stores data as utf8, so even the hex() function
                                // "encodes" the binary data in utf8/16 before returning it. yet hex()
                                // is the only way to get the full data, so we do this.
                                var data = parseHexString(result.rows.item(0).body, encoding);
                                if (opts.encode) {
                                    res = btoa(data);
                                } else {
                                    data = utils.fixBinary(data);
                                    res = utils.createBlob([data], {
                                        type: type
                                    });
                                }
                                callback(null, res);
                            });
                        };

                        api._getRevisionTree = function(docId, callback) {
                            db.transaction(function(tx) {
                                var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';
                                tx.executeSql(sql, [docId], function(tx, result) {
                                    if (!result.rows.length) {
                                        callback(errors.MISSING_DOC);
                                    } else {
                                        var data = JSON.parse(result.rows.item(0).metadata);
                                        callback(null, data.rev_tree);
                                    }
                                });
                            });
                        };

                        api._doCompaction = function(docId, rev_tree, revs, callback) {
                            db.transaction(function(tx) {
                                var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';
                                tx.executeSql(sql, [docId], function(tx, result) {
                                    if (!result.rows.length) {
                                        return utils.call(callback);
                                    }
                                    var metadata = JSON.parse(result.rows.item(0).metadata);
                                    metadata.rev_tree = rev_tree;

                                    var sql = 'DELETE FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev IN (' +
                                        revs.map(function() {
                                            return '?';
                                        }).join(',') + ')';

                                    var docIdRevs = revs.map(function(rev) {
                                        return docId + '::' + rev;
                                    });
                                    tx.executeSql(sql, [docIdRevs], function(tx) {
                                        var sql = 'UPDATE ' + DOC_STORE + ' SET json = ? WHERE id = ?';

                                        tx.executeSql(sql, [JSON.stringify(metadata), docId], function() {
                                            callback();
                                        });
                                    });
                                });
                            });
                        };
                    }

                    WebSqlPouch.valid = function() {
                        if (typeof global !== 'undefined') {
                            if (global.navigator && global.navigator.sqlitePlugin && global.navigator.sqlitePlugin.openDatabase) {
                                return true;
                            } else if (global.sqlitePlugin && global.sqlitePlugin.openDatabase) {
                                return true;
                            } else if (global.openDatabase) {
                                return true;
                            }
                        }
                        return false;
                    };

                    WebSqlPouch.destroy = utils.toPromise(function(name, opts, callback) {
                        var db = openDB(name, POUCH_VERSION, name, POUCH_SIZE);
                        db.transaction(function(tx) {
                            tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);
                            tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);
                            tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);
                            tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);
                        }, unknownError(callback), function() {
                            if (utils.hasLocalStorage()) {
                                delete global.localStorage['_pouch__websqldb_' + name];
                            }
                            callback();
                        });
                    });

                    WebSqlPouch.Changes = new utils.Changes();

                    module.exports = WebSqlPouch;

                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {
                "../deps/errors": 8,
                "../merge": 14,
                "../utils": 18
            }
        ],
        5: [
            function(_dereq_, module, exports) {
                (function(global) {
                    /*globals cordova */
                    "use strict";

                    var Promise = typeof global.Promise === 'function' ?
                        global.Promise : _dereq_('bluebird');

                    var Adapter = _dereq_('./adapter');
                    var utils = _dereq_('./utils');
                    var TaskQueue = _dereq_('./taskqueue');

                    function defaultCallback(err) {
                        if (err && global.debug) {
                            console.error(err);
                        }
                    }

                    utils.inherits(PouchDB, Adapter);

                    function PouchDB(name, opts, callback) {

                        if (!(this instanceof PouchDB)) {
                            return new PouchDB(name, opts, callback);
                        }
                        var self = this;
                        if (typeof opts === 'function' || typeof opts === 'undefined') {
                            callback = opts;
                            opts = {};
                        }

                        if (typeof name === 'object') {
                            opts = name;
                            name = undefined;
                        }
                        if (typeof callback === 'undefined') {
                            callback = defaultCallback;
                        }
                        opts = opts || {};
                        var oldCB = callback;
                        self.auto_compaction = opts.auto_compaction;
                        self.prefix = PouchDB.prefix;
                        Adapter.call(self);
                        self.taskqueue = new TaskQueue();
                        var promise = new Promise(function(fulfill, reject) {
                            callback = function(err, resp) {
                                if (err) {
                                    return reject(err);
                                }
                                delete resp.then;
                                fulfill(resp);
                            };

                            opts = utils.extend(true, {}, opts);
                            var originalName = opts.name || name;
                            var backend, error;
                            (function() {
                                try {

                                    if (typeof originalName !== 'string') {
                                        error = new Error('Missing/invalid DB name');
                                        error.code = 400;
                                        throw error;
                                    }

                                    backend = PouchDB.parseAdapter(originalName, opts);

                                    opts.originalName = originalName;
                                    opts.name = backend.name;
                                    opts.adapter = opts.adapter || backend.adapter;

                                    if (!PouchDB.adapters[opts.adapter]) {
                                        error = new Error('Adapter is missing');
                                        error.code = 404;
                                        throw error;
                                    }

                                    if (!PouchDB.adapters[opts.adapter].valid()) {
                                        error = new Error('Invalid Adapter');
                                        error.code = 404;
                                        throw error;
                                    }
                                } catch (err) {
                                    self.taskqueue.fail(err);
                                    self.changes = utils.toPromise(function(opts) {
                                        if (opts.complete) {
                                            opts.complete(err);
                                        }
                                    });
                                }
                            }());
                            if (error) {
                                return reject(error); // constructor error, see above
                            }
                            self.adapter = opts.adapter;

                            // needs access to PouchDB;
                            self.replicate = function(src, target, opts) {
                                return utils.cancellableFun(function(api, _opts, promise) {
                                    var replicate = PouchDB.replicate(src, target, opts);
                                    promise.cancel = replicate.cancel;
                                }, self, opts);
                            };

                            self.replicate.from = function(url, opts, callback) {
                                if (typeof opts === 'function') {
                                    callback = opts;
                                    opts = {};
                                }
                                return PouchDB.replicate(url, self, opts, callback);
                            };

                            self.replicate.to = function(url, opts, callback) {
                                if (typeof opts === 'function') {
                                    callback = opts;
                                    opts = {};
                                }
                                return PouchDB.replicate(self, url, opts, callback);
                            };

                            self.replicate.sync = function(dbName, opts, callback) {
                                if (typeof opts === 'function') {
                                    callback = opts;
                                    opts = {};
                                }
                                return utils.cancellableFun(function(api, _opts, promise) {
                                    var sync = PouchDB.sync(self, dbName, opts, callback);
                                    promise.cancel = sync.cancel;
                                }, self, opts);
                            };

                            self.destroy = utils.adapterFun('destroy', function(callback) {
                                var self = this;
                                self.info(function(err, info) {
                                    if (err) {
                                        return callback(err);
                                    }
                                    PouchDB.destroy(info.db_name, callback);
                                });
                            });

                            PouchDB.adapters[opts.adapter].call(self, opts, function(err, db) {
                                if (err) {
                                    if (callback) {
                                        self.taskqueue.fail(err);
                                        callback(err);
                                    }
                                    return;
                                }

                                function destructionListener(event) {
                                    if (event === 'destroyed') {
                                        self.emit('destroyed');
                                        PouchDB.removeListener(opts.name, destructionListener);
                                    }
                                }
                                PouchDB.on(opts.name, destructionListener);
                                self.emit('created', self);
                                PouchDB.emit('created', opts.originalName);
                                self.taskqueue.ready(self);
                                callback(null, self);

                            });
                            if (opts.skipSetup) {
                                self.taskqueue.ready(self);
                            }

                            if (utils.isCordova()) {
                                //to inform websql adapter that we can use api
                                cordova.fireWindowEvent(opts.name + "_pouch", {});
                            }
                        });
                        promise.then(function(resp) {
                            oldCB(null, resp);
                        }, oldCB);
                        self.then = promise.then.bind(promise);
                        //prevent deoptimizing
                        (function() {
                            try {
                                self['catch'] = promise['catch'].bind(promise);
                            } catch (e) {}
                        }());
                    }

                    module.exports = PouchDB;

                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {
                "./adapter": 1,
                "./taskqueue": 17,
                "./utils": 18,
                "bluebird": 27
            }
        ],
        6: [
            function(_dereq_, module, exports) {
                (function(process) {
                    "use strict";

                    var request = _dereq_('request');
                    var extend = _dereq_('./extend.js');
                    var createBlob = _dereq_('./blob.js');
                    var errors = _dereq_('./errors');
                    var uuid = _dereq_('../deps/uuid');
                    var utils = _dereq_("../utils");

                    function ajax(options, adapterCallback) {

                        var requestCompleted = false;
                        var callback = utils.getArguments(function(args) {
                            if (requestCompleted) {
                                return;
                            }
                            adapterCallback.apply(this, args);
                            requestCompleted = true;
                        });

                        if (typeof options === "function") {
                            callback = options;
                            options = {};
                        }

                        options = extend(true, {}, options);

                        var defaultOptions = {
                            method: "GET",
                            headers: {},
                            json: true,
                            processData: true,
                            timeout: 10000,
                            cache: false
                        };

                        options = extend(true, defaultOptions, options);

                        // cache-buster, specifically designed to work around IE's aggressive caching
                        // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/
                        if (options.method === 'GET' && !options.cache) {
                            var hasArgs = options.url.indexOf('?') !== -1;
                            options.url += (hasArgs ? '&' : '?') + '_nonce=' + uuid(16);
                        }

                        function onSuccess(obj, resp, cb) {
                            if (!options.binary && !options.json && options.processData &&
                                typeof obj !== 'string') {
                                obj = JSON.stringify(obj);
                            } else if (!options.binary && options.json && typeof obj === 'string') {
                                try {
                                    obj = JSON.parse(obj);
                                } catch (e) {
                                    // Probably a malformed JSON from server
                                    return cb(e);
                                }
                            }
                            if (Array.isArray(obj)) {
                                obj = obj.map(function(v) {
                                    var obj;
                                    if (v.ok) {
                                        return v;
                                    } else if (v.error && v.error === 'conflict') {
                                        obj = errors.REV_CONFLICT;
                                        obj.id = v.id;
                                        return obj;
                                    } else if (v.error && v.error === 'forbidden') {
                                        obj = errors.FORBIDDEN;
                                        obj.id = v.id;
                                        obj.reason = v.reason;
                                        return obj;
                                    } else if (v.missing) {
                                        obj = errors.MISSING_DOC;
                                        obj.missing = v.missing;
                                        return obj;
                                    } else {
                                        return v;
                                    }
                                });
                            }
                            cb(null, obj, resp);
                        }

                        function onError(err, cb) {
                            var errParsed, errObj, errType, key;
                            try {
                                errParsed = JSON.parse(err.responseText);
                                //would prefer not to have a try/catch clause
                                for (key in errors) {
                                    if (errors.hasOwnProperty(key) &&
                                        errors[key].name === errParsed.error) {
                                        errType = errors[key];
                                        break;
                                    }
                                }
                                if (!errType) {
                                    errType = errors.UNKNOWN_ERROR;
                                    if (err.status) {
                                        errType.status = err.status;
                                    }
                                    if (err.statusText) {
                                        err.name = err.statusText;
                                    }
                                }
                                errObj = errors.error(errType, errParsed.reason);
                            } catch (e) {
                                for (var key in errors) {
                                    if (errors.hasOwnProperty(key) && errors[key].status === err.status) {
                                        errType = errors[key];
                                        break;
                                    }
                                }
                                if (!errType) {
                                    errType = errors.UNKNOWN_ERROR;
                                    if (err.status) {
                                        errType.status = err.status;
                                    }
                                    if (err.statusText) {
                                        err.name = err.statusText;
                                    }
                                }
                                errObj = errors.error(errType);
                            }
                            cb(errObj);
                        }

                        if (process.browser) {
                            var timer;
                            var xhr;
                            if (options.xhr) {
                                xhr = new options.xhr();
                            } else {
                                xhr = new XMLHttpRequest();
                            }
                            xhr.open(options.method, options.url);
                            xhr.withCredentials = true;

                            if (options.json) {
                                options.headers.Accept = 'application/json';
                                options.headers['Content-Type'] = options.headers['Content-Type'] ||
                                    'application/json';
                                if (options.body &&
                                    options.processData &&
                                    typeof options.body !== "string") {
                                    options.body = JSON.stringify(options.body);
                                }
                            }

                            if (options.binary) {
                                xhr.responseType = 'arraybuffer';
                            }

                            var createCookie = function(name, value, days) {
                                var expires = "";
                                if (days) {
                                    var date = new Date();
                                    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                                    expires = "; expires=" + date.toGMTString();
                                }
                                document.cookie = name + "=" + value + expires + "; path=/";
                            };

                            for (var key in options.headers) {
                                if (key === 'Cookie') {
                                    var cookie = options.headers[key].split('=');
                                    createCookie(cookie[0], cookie[1], 10);
                                } else {
                                    xhr.setRequestHeader(key, options.headers[key]);
                                }
                            }

                            if (!("body" in options)) {
                                options.body = null;
                            }

                            var abortReq = function() {
                                if (requestCompleted) {
                                    return;
                                }
                                xhr.abort();
                                onError(xhr, callback);
                            };

                            xhr.onreadystatechange = function() {
                                if (xhr.readyState !== 4 || requestCompleted) {
                                    return;
                                }
                                clearTimeout(timer);
                                if (xhr.status >= 200 && xhr.status < 300) {
                                    var data;
                                    if (options.binary) {
                                        data = createBlob([xhr.response || ''], {
                                            type: xhr.getResponseHeader('Content-Type')
                                        });
                                    } else {
                                        data = xhr.responseText;
                                    }
                                    onSuccess(data, xhr, callback);
                                } else {
                                    onError(xhr, callback);
                                }
                            };

                            if (options.timeout > 0) {
                                timer = setTimeout(abortReq, options.timeout);
                                xhr.onprogress = function() {
                                    clearTimeout(timer);
                                    timer = setTimeout(abortReq, options.timeout);
                                };
                                if (xhr.upload) { // does not exist in ie9
                                    xhr.upload.onprogress = xhr.onprogress;
                                }
                            }
                            xhr.send(options.body);
                            return {
                                abort: abortReq
                            };

                        } else {

                            if (options.json) {
                                if (!options.binary) {
                                    options.headers.Accept = 'application/json';
                                }
                                options.headers['Content-Type'] = options.headers['Content-Type'] ||
                                    'application/json';
                            }

                            if (options.binary) {
                                options.encoding = null;
                                options.json = false;
                            }

                            if (!options.processData) {
                                options.json = false;
                            }

                            return request(options, function(err, response, body) {
                                if (err) {
                                    err.status = response ? response.statusCode : 400;
                                    return onError(err, callback);
                                }
                                var error;
                                var content_type = response.headers['content-type'];
                                var data = (body || '');

                                // CouchDB doesn't always return the right content-type for JSON data, so
                                // we check for ^{ and }$ (ignoring leading/trailing whitespace)
                                if (!options.binary && (options.json || !options.processData) &&
                                    typeof data !== 'object' &&
                                    (/json/.test(content_type) ||
                                        (/^[\s]*\{/.test(data) && /\}[\s]*$/.test(data)))) {
                                    data = JSON.parse(data);
                                }

                                if (response.statusCode >= 200 && response.statusCode < 300) {
                                    onSuccess(data, response, callback);
                                } else {
                                    if (options.binary) {
                                        data = JSON.parse(data.toString());
                                    }
                                    if (data.reason === 'missing') {
                                        error = errors.MISSING_DOC;
                                    } else if (data.reason === 'no_db_file') {
                                        error = errors.error(errors.DB_MISSING, data.reason);
                                    } else if (data.error === 'conflict') {
                                        error = errors.REV_CONFLICT;
                                    } else {
                                        error = errors.error(errors.UNKNOWN_ERROR, data.reason, data.error);
                                    }
                                    error.status = response.statusCode;
                                    callback(error);
                                }
                            });
                        }
                    }

                    module.exports = ajax;

                }).call(this, _dereq_("/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
            }, {
                "../deps/uuid": 12,
                "../utils": 18,
                "./blob.js": 7,
                "./errors": 8,
                "./extend.js": 10,
                "/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js": 22,
                "request": 20
            }
        ],
        7: [
            function(_dereq_, module, exports) {
                (function(global) {
                    "use strict";

                    //Abstracts constructing a Blob object, so it also works in older
                    //browsers that don't support the native Blob constructor. (i.e.
                    //old QtWebKit versions, at least).
                    function createBlob(parts, properties) {
                        parts = parts || [];
                        properties = properties || {};
                        try {
                            return new Blob(parts, properties);
                        } catch (e) {
                            if (e.name !== "TypeError") {
                                throw e;
                            }
                            var BlobBuilder = global.BlobBuilder ||
                                global.MSBlobBuilder ||
                                global.MozBlobBuilder ||
                                global.WebKitBlobBuilder;
                            var builder = new BlobBuilder();
                            for (var i = 0; i < parts.length; i += 1) {
                                builder.append(parts[i]);
                            }
                            return builder.getBlob(properties.type);
                        }
                    }

                    module.exports = createBlob;


                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {}
        ],
        8: [
            function(_dereq_, module, exports) {
                "use strict";

                function PouchError(opts) {
                    this.status = opts.status;
                    this.name = opts.error;
                    this.message = opts.reason;
                    this.error = true;
                }

                PouchError.prototype__proto__ = Error.prototype;

                PouchError.prototype.toString = function() {
                    return JSON.stringify({
                        status: this.status,
                        name: this.name,
                        message: this.message
                    });
                };

                exports.UNAUTHORIZED = new PouchError({
                    status: 401,
                    error: 'unauthorized',
                    reason: "Name or password is incorrect."
                });
                exports.MISSING_BULK_DOCS = new PouchError({
                    status: 400,
                    error: 'bad_request',
                    reason: "Missing JSON list of 'docs'"
                });
                exports.MISSING_DOC = new PouchError({
                    status: 404,
                    error: 'not_found',
                    reason: 'missing'
                });
                exports.REV_CONFLICT = new PouchError({
                    status: 409,
                    error: 'conflict',
                    reason: 'Document update conflict'
                });
                exports.INVALID_ID = new PouchError({
                    status: 400,
                    error: 'invalid_id',
                    reason: '_id field must contain a string'
                });
                exports.MISSING_ID = new PouchError({
                    status: 412,
                    error: 'missing_id',
                    reason: '_id is required for puts'
                });
                exports.RESERVED_ID = new PouchError({
                    status: 400,
                    error: 'bad_request',
                    reason: 'Only reserved document ids may start with underscore.'
                });
                exports.NOT_OPEN = new PouchError({
                    status: 412,
                    error: 'precondition_failed',
                    reason: 'Database not open so cannot close'
                });
                exports.UNKNOWN_ERROR = new PouchError({
                    status: 500,
                    error: 'unknown_error',
                    reason: 'Database encountered an unknown error'
                });
                exports.BAD_ARG = new PouchError({
                    status: 500,
                    error: 'badarg',
                    reason: 'Some query argument is invalid'
                });
                exports.INVALID_REQUEST = new PouchError({
                    status: 400,
                    error: 'invalid_request',
                    reason: 'Request was invalid'
                });
                exports.QUERY_PARSE_ERROR = new PouchError({
                    status: 400,
                    error: 'query_parse_error',
                    reason: 'Some query parameter is invalid'
                });
                exports.DOC_VALIDATION = new PouchError({
                    status: 500,
                    error: 'doc_validation',
                    reason: 'Bad special document member'
                });
                exports.BAD_REQUEST = new PouchError({
                    status: 400,
                    error: 'bad_request',
                    reason: 'Something wrong with the request'
                });
                exports.NOT_AN_OBJECT = new PouchError({
                    status: 400,
                    error: 'bad_request',
                    reason: 'Document must be a JSON object'
                });
                exports.DB_MISSING = new PouchError({
                    status: 404,
                    error: 'not_found',
                    reason: 'Database not found'
                });
                exports.IDB_ERROR = new PouchError({
                    status: 500,
                    error: 'indexed_db_went_bad',
                    reason: 'unknown'
                });
                exports.WSQ_ERROR = new PouchError({
                    status: 500,
                    error: 'web_sql_went_bad',
                    reason: 'unknown'
                });
                exports.LDB_ERROR = new PouchError({
                    status: 500,
                    error: 'levelDB_went_went_bad',
                    reason: 'unknown'
                });
                exports.FORBIDDEN = new PouchError({
                    status: 403,
                    error: 'forbidden',
                    reason: 'Forbidden by design doc validate_doc_update function'
                });
                exports.error = function(error, reason, name) {
                    function CustomPouchError(msg) {
                        this.message = reason;
                        if (name) {
                            this.name = name;
                        }
                    }
                    CustomPouchError.prototype = error;
                    return new CustomPouchError(reason);
                };

            }, {}
        ],
        9: [
            function(_dereq_, module, exports) {
                // some small shims for es5 just for the features we commonly use
                // some of this is copied from 
                // https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js
                'use strict';

                if (!Object.keys) {
                    Object.keys = function keys(object) {

                        if ((typeof object !== 'object' &&
                                typeof object !== 'function') ||
                            object === null) {
                            throw new TypeError('Object.keys called on a non-object');
                        }

                        var mykeys = [];
                        for (var name in object) {
                            if (Object.prototype.hasOwnProperty.call(object, name)) {
                                mykeys.push(name);
                            }
                        }
                        return mykeys;
                    };
                }

                if (!Array.isArray) {
                    Array.isArray = function isArray(obj) {
                        return Object.prototype.toString.call(obj) === '[object Array]';
                    };
                }

                if (!('forEach' in Array.prototype)) {
                    Array.prototype.forEach = function(action, that /*opt*/ ) {
                        for (var i = 0, n = this.length; i < n; i++) {
                            if (i in this) {
                                action.call(that, this[i], i, this);
                            }
                        }
                    };
                }

                if (!('map' in Array.prototype)) {
                    Array.prototype.map = function(mapper, that /*opt*/ ) {
                        var other = new Array(this.length);
                        for (var i = 0, n = this.length; i < n; i++) {
                            if (i in this) {
                                other[i] = mapper.call(that, this[i], i, this);
                            }
                        }
                        return other;
                    };
                }

            }, {}
        ],
        10: [
            function(_dereq_, module, exports) {
                "use strict";

                // Extends method
                // (taken from http://code.jquery.com/jquery-1.9.0.js)
                // Populate the class2type map
                var class2type = {};

                var types = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Object", "Error"];
                for (var i = 0; i < types.length; i++) {
                    var typename = types[i];
                    class2type["[object " + typename + "]"] = typename.toLowerCase();
                }

                var core_toString = class2type.toString;
                var core_hasOwn = class2type.hasOwnProperty;

                function type(obj) {
                    if (obj === null) {
                        return String(obj);
                    }
                    return typeof obj === "object" || typeof obj === "function" ?
                        class2type[core_toString.call(obj)] || "object" :
                        typeof obj;
                }

                function isWindow(obj) {
                    return obj !== null && obj === obj.window;
                }

                function isPlainObject(obj) {
                    // Must be an Object.
                    // Because of IE, we also have to check the presence of the constructor property.
                    // Make sure that DOM nodes and window objects don't pass through, as well
                    if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
                        return false;
                    }

                    try {
                        // Not own constructor property must be Object
                        if (obj.constructor && !core_hasOwn.call(obj, "constructor") && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                            return false;
                        }
                    } catch (e) {
                        // IE8,9 Will throw exceptions on certain host objects #9897
                        return false;
                    }

                    // Own properties are enumerated firstly, so to speed up,
                    // if last one is own, then all properties are own.
                    var key;
                    for (key in obj) {}

                    return key === undefined || core_hasOwn.call(obj, key);
                }


                function isFunction(obj) {
                    return type(obj) === "function";
                }

                var isArray = Array.isArray || function(obj) {
                        return type(obj) === "array";
                    };

                function extend() {
                    var options, name, src, copy, copyIsArray, clone,
                        target = arguments[0] || {},
                        i = 1,
                        length = arguments.length,
                        deep = false;

                    // Handle a deep copy situation
                    if (typeof target === "boolean") {
                        deep = target;
                        target = arguments[1] || {};
                        // skip the boolean and the target
                        i = 2;
                    }

                    // Handle case when target is a string or something (possible in deep copy)
                    if (typeof target !== "object" && !isFunction(target)) {
                        target = {};
                    }

                    // extend jQuery itself if only one argument is passed
                    if (length === i) {
                        /* jshint validthis: true */
                        target = this;
                        --i;
                    }

                    for (; i < length; i++) {
                        // Only deal with non-null/undefined values
                        if ((options = arguments[i]) != null) {
                            // Extend the base object
                            for (name in options) {
                                //if (options.hasOwnProperty(name)) {
                                if (!(name in Object.prototype)) {

                                    src = target[name];
                                    copy = options[name];

                                    // Prevent never-ending loop
                                    if (target === copy) {
                                        continue;
                                    }

                                    // Recurse if we're merging plain objects or arrays
                                    if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                                        if (copyIsArray) {
                                            copyIsArray = false;
                                            clone = src && isArray(src) ? src : [];

                                        } else {
                                            clone = src && isPlainObject(src) ? src : {};
                                        }

                                        // Never move original objects, clone them
                                        target[name] = extend(deep, clone, copy);

                                        // Don't bring in undefined values
                                    } else if (copy !== undefined) {
                                        if (!(isArray(options) && isFunction(copy))) {
                                            target[name] = copy;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Return the modified object
                    return target;
                }


                module.exports = extend;


            }, {}
        ],
        11: [
            function(_dereq_, module, exports) {
                (function(process) {
                    "use strict";

                    /**
                     *
                     *  MD5 (Message-Digest Algorithm)
                     *
                     *  For original source see http://www.webtoolkit.info/
                     *  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html
                     *
                     *  Licensed under CC-BY 2.0 License
                     *  (http://creativecommons.org/licenses/by/2.0/uk/)
                     *
                     **/
                    var crypto = _dereq_('crypto');

                    exports.MD5 = function(string) {
                        if (!process.browser) {
                            return crypto.createHash('md5').update(string).digest('hex');
                        }

                        function rotateLeft(lValue, iShiftBits) {
                            return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
                        }

                        function addUnsigned(lX, lY) {
                            var lX4, lY4, lX8, lY8, lResult;
                            lX8 = (lX & 0x80000000);
                            lY8 = (lY & 0x80000000);
                            lX4 = (lX & 0x40000000);
                            lY4 = (lY & 0x40000000);
                            lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                            if (lX4 & lY4) {
                                return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                            }
                            if (lX4 | lY4) {
                                if (lResult & 0x40000000) {
                                    return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                                } else {
                                    return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                                }
                            } else {
                                return (lResult ^ lX8 ^ lY8);
                            }
                        }

                        function f(x, y, z) {
                            return (x & y) | ((~x) & z);
                        }

                        function g(x, y, z) {
                            return (x & z) | (y & (~z));
                        }

                        function h(x, y, z) {
                            return (x ^ y ^ z);
                        }

                        function i(x, y, z) {
                            return (y ^ (x | (~z)));
                        }

                        function ff(a, b, c, d, x, s, ac) {
                            a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));
                            return addUnsigned(rotateLeft(a, s), b);
                        }

                        function gg(a, b, c, d, x, s, ac) {
                            a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));
                            return addUnsigned(rotateLeft(a, s), b);
                        }

                        function hh(a, b, c, d, x, s, ac) {
                            a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));
                            return addUnsigned(rotateLeft(a, s), b);
                        }

                        function ii(a, b, c, d, x, s, ac) {
                            a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));
                            return addUnsigned(rotateLeft(a, s), b);
                        }

                        function convertToWordArray(string) {
                            var lWordCount;
                            var lMessageLength = string.length;
                            var lNumberOfWords_temp1 = lMessageLength + 8;
                            var lNumberOfWords_temp2 =
                                (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                            var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                            var lWordArray = new Array(lNumberOfWords - 1);
                            var lBytePosition = 0;
                            var lByteCount = 0;
                            while (lByteCount < lMessageLength) {
                                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                                lBytePosition = (lByteCount % 4) * 8;
                                lWordArray[lWordCount] = (lWordArray[lWordCount] |
                                    (string.charCodeAt(lByteCount) << lBytePosition));
                                lByteCount++;
                            }
                            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                            lBytePosition = (lByteCount % 4) * 8;
                            lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                            lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                            lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                            return lWordArray;
                        }

                        function wordToHex(lValue) {
                            var wordToHexValue = "",
                                wordToHexValue_temp = "",
                                lByte, lCount;
                            for (lCount = 0; lCount <= 3; lCount++) {
                                lByte = (lValue >>> (lCount * 8)) & 255;
                                wordToHexValue_temp = "0" + lByte.toString(16);
                                wordToHexValue = wordToHexValue +
                                    wordToHexValue_temp.substr(
                                        wordToHexValue_temp.length - 2, 2
                                );
                            }
                            return wordToHexValue;
                        }

                        //**  function Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js

                        var x = [];
                        var k, AA, BB, CC, DD, a, b, c, d;
                        var S11 = 7,
                            S12 = 12,
                            S13 = 17,
                            S14 = 22;
                        var S21 = 5,
                            S22 = 9,
                            S23 = 14,
                            S24 = 20;
                        var S31 = 4,
                            S32 = 11,
                            S33 = 16,
                            S34 = 23;
                        var S41 = 6,
                            S42 = 10,
                            S43 = 15,
                            S44 = 21;

                        //  string = Utf8Encode(string); #function call removed

                        x = convertToWordArray(string);

                        a = 0x67452301;
                        b = 0xEFCDAB89;
                        c = 0x98BADCFE;
                        d = 0x10325476;

                        for (k = 0; k < x.length; k += 16) {
                            AA = a;
                            BB = b;
                            CC = c;
                            DD = d;
                            a = ff(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                            d = ff(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                            c = ff(c, d, a, b, x[k + 2], S13, 0x242070DB);
                            b = ff(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                            a = ff(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                            d = ff(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                            c = ff(c, d, a, b, x[k + 6], S13, 0xA8304613);
                            b = ff(b, c, d, a, x[k + 7], S14, 0xFD469501);
                            a = ff(a, b, c, d, x[k + 8], S11, 0x698098D8);
                            d = ff(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                            c = ff(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                            b = ff(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                            a = ff(a, b, c, d, x[k + 12], S11, 0x6B901122);
                            d = ff(d, a, b, c, x[k + 13], S12, 0xFD987193);
                            c = ff(c, d, a, b, x[k + 14], S13, 0xA679438E);
                            b = ff(b, c, d, a, x[k + 15], S14, 0x49B40821);
                            a = gg(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                            d = gg(d, a, b, c, x[k + 6], S22, 0xC040B340);
                            c = gg(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                            b = gg(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                            a = gg(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                            d = gg(d, a, b, c, x[k + 10], S22, 0x2441453);
                            c = gg(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                            b = gg(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                            a = gg(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                            d = gg(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                            c = gg(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                            b = gg(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                            a = gg(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                            d = gg(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                            c = gg(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                            b = gg(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                            a = hh(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                            d = hh(d, a, b, c, x[k + 8], S32, 0x8771F681);
                            c = hh(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                            b = hh(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                            a = hh(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                            d = hh(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                            c = hh(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                            b = hh(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                            a = hh(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                            d = hh(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                            c = hh(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                            b = hh(b, c, d, a, x[k + 6], S34, 0x4881D05);
                            a = hh(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                            d = hh(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                            c = hh(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                            b = hh(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                            a = ii(a, b, c, d, x[k + 0], S41, 0xF4292244);
                            d = ii(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                            c = ii(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                            b = ii(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                            a = ii(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                            d = ii(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                            c = ii(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                            b = ii(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                            a = ii(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                            d = ii(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                            c = ii(c, d, a, b, x[k + 6], S43, 0xA3014314);
                            b = ii(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                            a = ii(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                            d = ii(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                            c = ii(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                            b = ii(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                            a = addUnsigned(a, AA);
                            b = addUnsigned(b, BB);
                            c = addUnsigned(c, CC);
                            d = addUnsigned(d, DD);
                        }
                        var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
                        return temp.toLowerCase();
                    };

                }).call(this, _dereq_("/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
            }, {
                "/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js": 22,
                "crypto": 20
            }
        ],
        12: [
            function(_dereq_, module, exports) {
                "use strict";

                // BEGIN Math.uuid.js

                /*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

                /*
                 * Generate a random uuid.
                 *
                 * USAGE: Math.uuid(length, radix)
                 *   length - the desired number of characters
                 *   radix  - the number of allowable values for each character.
                 *
                 * EXAMPLES:
                 *   // No arguments  - returns RFC4122, version 4 ID
                 *   >>> Math.uuid()
                 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
                 *
                 *   // One argument - returns ID of the specified length
                 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
                 *   "VcydxgltxrVZSTV"
                 *
                 *   // Two arguments - returns ID of the specified length, and radix.
                 *   // (Radix must be <= 62)
                 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
                 *   "01001010"
                 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
                 *   "47473046"
                 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
                 *   "098F4D35"
                 */


                function uuid(len, radix) {
                    var chars = uuid.CHARS;
                    var uuidInner = [];
                    var i;

                    radix = radix || chars.length;

                    if (len) {
                        // Compact form
                        for (i = 0; i < len; i++) {
                            uuidInner[i] = chars[0 | Math.random() * radix];
                        }
                    } else {
                        // rfc4122, version 4 form
                        var r;

                        // rfc4122 requires these characters
                        uuidInner[8] = uuidInner[13] = uuidInner[18] = uuidInner[23] = '-';
                        uuidInner[14] = '4';

                        // Fill in random data.  At i==19 set the high bits of clock sequence as
                        // per rfc4122, sec. 4.1.5
                        for (i = 0; i < 36; i++) {
                            if (!uuidInner[i]) {
                                r = 0 | Math.random() * 16;
                                uuidInner[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
                            }
                        }
                    }

                    return uuidInner.join('');
                }

                uuid.CHARS = (
                    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
                    'abcdefghijklmnopqrstuvwxyz'
                ).split('');

                module.exports = uuid;


            }, {}
        ],
        13: [
            function(_dereq_, module, exports) {
                (function(process) {
                    "use strict";

                    _dereq_('./deps/es5_shims');

                    var PouchDB = _dereq_('./setup');

                    module.exports = PouchDB;

                    PouchDB.ajax = _dereq_('./deps/ajax');
                    PouchDB.extend = _dereq_('./deps/extend');
                    PouchDB.utils = _dereq_('./utils');
                    PouchDB.Errors = _dereq_('./deps/errors');
                    var replicate = _dereq_('./replicate');
                    PouchDB.replicate = replicate.replicate;
                    PouchDB.sync = replicate.sync;
                    PouchDB.version = _dereq_('./version');
                    var httpAdapter = _dereq_('./adapters/http');
                    PouchDB.adapter('http', httpAdapter);
                    PouchDB.adapter('https', httpAdapter);

                    PouchDB.adapter('idb', _dereq_('./adapters/idb'));
                    PouchDB.adapter('websql', _dereq_('./adapters/websql'));
                    PouchDB.plugin(_dereq_('pouchdb-mapreduce'));

                    if (!process.browser) {
                        var ldbAdapter = _dereq_('./adapters/leveldb');
                        PouchDB.adapter('ldb', ldbAdapter);
                        PouchDB.adapter('leveldb', ldbAdapter);
                    }

                }).call(this, _dereq_("/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
            }, {
                "./adapters/http": 2,
                "./adapters/idb": 3,
                "./adapters/leveldb": 20,
                "./adapters/websql": 4,
                "./deps/ajax": 6,
                "./deps/errors": 8,
                "./deps/es5_shims": 9,
                "./deps/extend": 10,
                "./replicate": 15,
                "./setup": 16,
                "./utils": 18,
                "./version": 19,
                "/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js": 22,
                "pouchdb-mapreduce": 42
            }
        ],
        14: [
            function(_dereq_, module, exports) {
                'use strict';

                var extend = _dereq_('./deps/extend');


                // for a better overview of what this is doing, read:
                // https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl
                //
                // But for a quick intro, CouchDB uses a revision tree to store a documents
                // history, A -> B -> C, when a document has conflicts, that is a branch in the
                // tree, A -> (B1 | B2 -> C), We store these as a nested array in the format
                //
                // KeyTree = [Path ... ]
                // Path = {pos: position_from_root, ids: Tree}
                // Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]

                // Turn a path as a flat array into a tree with a single branch
                function pathToTree(path) {
                    var doc = path.shift();
                    var root = [doc.id, doc.opts, []];
                    var leaf = root;
                    var nleaf;

                    while (path.length) {
                        doc = path.shift();
                        nleaf = [doc.id, doc.opts, []];
                        leaf[2].push(nleaf);
                        leaf = nleaf;
                    }
                    return root;
                }

                // Merge two trees together
                // The roots of tree1 and tree2 must be the same revision
                function mergeTree(in_tree1, in_tree2) {
                    var queue = [{
                        tree1: in_tree1,
                        tree2: in_tree2
                    }];
                    var conflicts = false;
                    while (queue.length > 0) {
                        var item = queue.pop();
                        var tree1 = item.tree1;
                        var tree2 = item.tree2;

                        if (tree1[1].status || tree2[1].status) {
                            tree1[1].status = (tree1[1].status === 'available' ||
                                tree2[1].status === 'available') ? 'available' : 'missing';
                        }

                        for (var i = 0; i < tree2[2].length; i++) {
                            if (!tree1[2][0]) {
                                conflicts = 'new_leaf';
                                tree1[2][0] = tree2[2][i];
                                continue;
                            }

                            var merged = false;
                            for (var j = 0; j < tree1[2].length; j++) {
                                if (tree1[2][j][0] === tree2[2][i][0]) {
                                    queue.push({
                                        tree1: tree1[2][j],
                                        tree2: tree2[2][i]
                                    });
                                    merged = true;
                                }
                            }
                            if (!merged) {
                                conflicts = 'new_branch';
                                tree1[2].push(tree2[2][i]);
                                tree1[2].sort();
                            }
                        }
                    }
                    return {
                        conflicts: conflicts,
                        tree: in_tree1
                    };
                }

                function doMerge(tree, path, dontExpand) {
                    var restree = [];
                    var conflicts = false;
                    var merged = false;
                    var res;

                    if (!tree.length) {
                        return {
                            tree: [path],
                            conflicts: 'new_leaf'
                        };
                    }

                    tree.forEach(function(branch) {
                        if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
                            // Paths start at the same position and have the same root, so they need
                            // merged
                            res = mergeTree(branch.ids, path.ids);
                            restree.push({
                                pos: branch.pos,
                                ids: res.tree
                            });
                            conflicts = conflicts || res.conflicts;
                            merged = true;
                        } else if (dontExpand !== true) {
                            // The paths start at a different position, take the earliest path and
                            // traverse up until it as at the same point from root as the path we want to
                            // merge.  If the keys match we return the longer path with the other merged
                            // After stemming we dont want to expand the trees

                            var t1 = branch.pos < path.pos ? branch : path;
                            var t2 = branch.pos < path.pos ? path : branch;
                            var diff = t2.pos - t1.pos;

                            var candidateParents = [];

                            var trees = [];
                            trees.push({
                                ids: t1.ids,
                                diff: diff,
                                parent: null,
                                parentIdx: null
                            });
                            while (trees.length > 0) {
                                var item = trees.pop();
                                if (item.diff === 0) {
                                    if (item.ids[0] === t2.ids[0]) {
                                        candidateParents.push(item);
                                    }
                                    continue;
                                }
                                if (!item.ids) {
                                    continue;
                                }
                                /*jshint loopfunc:true */
                                item.ids[2].forEach(function(el, idx) {
                                    trees.push({
                                        ids: el,
                                        diff: item.diff - 1,
                                        parent: item.ids,
                                        parentIdx: idx
                                    });
                                });
                            }

                            var el = candidateParents[0];

                            if (!el) {
                                restree.push(branch);
                            } else {
                                res = mergeTree(el.ids, t2.ids);
                                el.parent[2][el.parentIdx] = res.tree;
                                restree.push({
                                    pos: t1.pos,
                                    ids: t1.ids
                                });
                                conflicts = conflicts || res.conflicts;
                                merged = true;
                            }
                        } else {
                            restree.push(branch);
                        }
                    });

                    // We didnt find
                    if (!merged) {
                        restree.push(path);
                    }

                    restree.sort(function(a, b) {
                        return a.pos - b.pos;
                    });

                    return {
                        tree: restree,
                        conflicts: conflicts || 'internal_node'
                    };
                }

                // To ensure we dont grow the revision tree infinitely, we stem old revisions
                function stem(tree, depth) {
                    // First we break out the tree into a complete list of root to leaf paths,
                    // we cut off the start of the path and generate a new set of flat trees
                    var stemmedPaths = PouchMerge.rootToLeaf(tree).map(function(path) {
                        var stemmed = path.ids.slice(-depth);
                        return {
                            pos: path.pos + (path.ids.length - stemmed.length),
                            ids: pathToTree(stemmed)
                        };
                    });
                    // Then we remerge all those flat trees together, ensuring that we dont
                    // connect trees that would go beyond the depth limit
                    return stemmedPaths.reduce(function(prev, current, i, arr) {
                        return doMerge(prev, current, true).tree;
                    }, [stemmedPaths.shift()]);
                }

                var PouchMerge = {};

                PouchMerge.merge = function(tree, path, depth) {
                    // Ugh, nicer way to not modify arguments in place?
                    tree = extend(true, [], tree);
                    path = extend(true, {}, path);
                    var newTree = doMerge(tree, path);
                    return {
                        tree: stem(newTree.tree, depth),
                        conflicts: newTree.conflicts
                    };
                };

                // We fetch all leafs of the revision tree, and sort them based on tree length
                // and whether they were deleted, undeleted documents with the longest revision
                // tree (most edits) win
                // The final sort algorithm is slightly documented in a sidebar here:
                // http://guide.couchdb.org/draft/conflicts.html
                PouchMerge.winningRev = function(metadata) {
                    var leafs = [];
                    PouchMerge.traverseRevTree(metadata.rev_tree,
                        function(isLeaf, pos, id, something, opts) {
                            if (isLeaf) {
                                leafs.push({
                                    pos: pos,
                                    id: id,
                                    deleted: !! opts.deleted
                                });
                            }
                        });
                    leafs.sort(function(a, b) {
                        if (a.deleted !== b.deleted) {
                            return a.deleted > b.deleted ? 1 : -1;
                        }
                        if (a.pos !== b.pos) {
                            return b.pos - a.pos;
                        }
                        return a.id < b.id ? 1 : -1;
                    });

                    return leafs[0].pos + '-' + leafs[0].id;
                };

                // Pretty much all below can be combined into a higher order function to
                // traverse revisions
                // The return value from the callback will be passed as context to all
                // children of that node
                PouchMerge.traverseRevTree = function(revs, callback) {
                    var toVisit = [];

                    revs.forEach(function(tree) {
                        toVisit.push({
                            pos: tree.pos,
                            ids: tree.ids
                        });
                    });
                    while (toVisit.length > 0) {
                        var node = toVisit.pop();
                        var pos = node.pos;
                        var tree = node.ids;
                        var newCtx = callback(tree[2].length === 0, pos, tree[0], node.ctx, tree[1]);
                        /*jshint loopfunc: true */
                        tree[2].forEach(function(branch) {
                            toVisit.push({
                                pos: pos + 1,
                                ids: branch,
                                ctx: newCtx
                            });
                        });
                    }
                };

                PouchMerge.collectLeaves = function(revs) {
                    var leaves = [];
                    PouchMerge.traverseRevTree(revs, function(isLeaf, pos, id, acc, opts) {
                        if (isLeaf) {
                            leaves.unshift({
                                rev: pos + "-" + id,
                                pos: pos,
                                opts: opts
                            });
                        }
                    });
                    leaves.sort(function(a, b) {
                        return b.pos - a.pos;
                    });
                    leaves.map(function(leaf) {
                        delete leaf.pos;
                    });
                    return leaves;
                };

                // returns revs of all conflicts that is leaves such that
                // 1. are not deleted and
                // 2. are different than winning revision
                PouchMerge.collectConflicts = function(metadata) {
                    var win = PouchMerge.winningRev(metadata);
                    var leaves = PouchMerge.collectLeaves(metadata.rev_tree);
                    var conflicts = [];
                    leaves.forEach(function(leaf) {
                        if (leaf.rev !== win && !leaf.opts.deleted) {
                            conflicts.push(leaf.rev);
                        }
                    });
                    return conflicts;
                };

                PouchMerge.rootToLeaf = function(tree) {
                    var paths = [];
                    PouchMerge.traverseRevTree(tree, function(isLeaf, pos, id, history, opts) {
                        history = history ? history.slice(0) : [];
                        history.push({
                            id: id,
                            opts: opts
                        });
                        if (isLeaf) {
                            var rootPos = pos + 1 - history.length;
                            paths.unshift({
                                pos: rootPos,
                                ids: history
                            });
                        }
                        return history;
                    });
                    return paths;
                };


                module.exports = PouchMerge;

            }, {
                "./deps/extend": 10
            }
        ],
        15: [
            function(_dereq_, module, exports) {
                'use strict';

                var PouchUtils = _dereq_('./utils');
                var Pouch = _dereq_('./index');

                // We create a basic promise so the caller can cancel the replication possibly
                // before we have actually started listening to changes etc
                function Promise() {
                    var that = this;
                    this.cancelled = false;
                    this.cancel = function() {
                        that.cancelled = true;
                    };
                }


                // A batch of changes to be processed as a unit
                function Batch() {
                    this.seq = 0;
                    this.changes = [];
                    this.docs = [];
                }


                // TODO: check CouchDB's replication id generation
                // Generate a unique id particular to this replication
                function genReplicationId(src, target, opts, callback) {
                    var filterFun = opts.filter ? opts.filter.toString() : '';
                    src.id(function(err, src_id) {
                        target.id(function(err, target_id) {
                            var queryData = src_id + target_id + filterFun +
                                JSON.stringify(opts.query_params) + opts.doc_ids;
                            callback('_local/' + PouchUtils.Crypto.MD5(queryData));
                        });
                    });
                }


                // A checkpoint lets us restart replications from when they were last cancelled
                function fetchCheckpoint(src, target, id, callback) {
                    target.get(id, function(err, targetDoc) {
                        if (err && err.status === 404) {
                            callback(null, 0);
                        } else if (err) {
                            callback(err);
                        } else {
                            src.get(id, function(err, sourceDoc) {
                                if (err && err.status === 404 ||
                                    (!err && (targetDoc.last_seq !== sourceDoc.last_seq))) {
                                    callback(null, 0);
                                } else if (err) {
                                    callback(err);
                                } else {
                                    callback(null, sourceDoc.last_seq);
                                }
                            });
                        }
                    });
                }


                function writeCheckpoint(src, target, id, checkpoint, callback) {
                    function updateCheckpoint(db, callback) {
                        db.get(id, function(err, doc) {
                            if (err && err.status === 404) {
                                doc = {
                                    _id: id
                                };
                            } else if (err) {
                                return callback(err);
                            }
                            doc.last_seq = checkpoint;
                            db.put(doc, callback);
                        });
                    }
                    updateCheckpoint(target, function(err, doc) {
                        if (err) {
                            return callback(err);
                        }
                        updateCheckpoint(src, function(err, doc) {
                            if (err) {
                                return callback(err);
                            }
                            callback();
                        });
                    });
                }


                function replicate(repId, src, target, opts, promise) {
                    var batches = []; // list of batches to be processed
                    var currentBatch; // the batch currently being processed
                    var pendingBatch = new Batch(); // next batch, not yet ready to be processed
                    var fetchAgain = []; // queue of documents to be fetched again with api.get
                    var writingCheckpoint = false;
                    var changesCompleted = false;
                    var completeCalled = false;
                    var last_seq = 0;
                    var continuous = opts.continuous || opts.live || false;
                    var batch_size = opts.batch_size || 1;
                    var doc_ids = opts.doc_ids;
                    var result = {
                        ok: true,
                        start_time: new Date(),
                        docs_read: 0,
                        docs_written: 0,
                        doc_write_failures: 0,
                        errors: []
                    };


                    function writeDocs() {
                        if (currentBatch.docs.length === 0) {
                            // This should never happen:
                            // batch processing continues past onRevsDiff only if there are diffs
                            // and replication is aborted if a get fails.
                            // TODO: throw or log the error
                            return finishBatch();
                        }

                        var docs = currentBatch.docs;
                        target.bulkDocs({
                            docs: docs
                        }, {
                            new_edits: false
                        }, function(err, res) {
                            if (err) {
                                result.doc_write_failures += docs.length;
                                return abortReplication('target.bulkDocs completed with error', err);
                            }

                            var errors = [];
                            res.forEach(function(res) {
                                if (!res.ok) {
                                    result.doc_write_failures++;
                                    errors.push({
                                        status: 500,
                                        error: res.error || 'Unknown document write error',
                                        reason: res.reason || 'Unknown reason',
                                    });
                                }
                            });

                            if (errors.length > 0) {
                                return abortReplication('target.bulkDocs failed to write docs', errors);
                            }

                            result.docs_written += docs.length;
                            finishBatch();
                        });
                    }


                    function onGet(err, docs) {
                        if (promise.cancelled) {
                            return replicationComplete();
                        }

                        if (err) {
                            return abortReplication('src.get completed with error', err);
                        }

                        Object.keys(docs).forEach(function(revpos) {
                            var doc = docs[revpos].ok;

                            if (doc) {
                                result.docs_read++;
                                currentBatch.pendingRevs++;
                                currentBatch.docs.push(doc);
                            }
                        });

                        fetchRev();
                    }

                    function fetchGenerationOneRevs(ids, revs) {
                        src.allDocs({
                            keys: ids,
                            include_docs: true
                        }, function(err, res) {
                            if (promise.cancelled) {
                                return replicationComplete();
                            }
                            if (err) {
                                return abortReplication('src.get completed with error', err);
                            }

                            res.rows.forEach(function(row, i) {
                                // fetch document again via api.get when doc
                                // * is deleted document (could have data)
                                // * is no longer generation 1
                                // * has attachments
                                var needsSingleFetch = !row.doc ||
                                    row.value.rev.slice(0, 2) !== '1-' ||
                                    row.doc._attachments && Object.keys(row.doc._attachments).length;

                                if (needsSingleFetch) {
                                    return fetchAgain.push({
                                        id: row.error === 'not_found' ? row.key : row.id,
                                        rev: revs[i]
                                    });
                                }

                                result.docs_read++;
                                currentBatch.pendingRevs++;
                                currentBatch.docs.push(row.doc);
                            });

                            fetchRev();
                        });
                    }

                    function fetchRev() {
                        if (fetchAgain.length) {
                            var doc = fetchAgain.shift();
                            return fetchSingleRev(src, onGet, doc.id, [doc.rev]);
                        }

                        var diffs = currentBatch.diffs;

                        if (Object.keys(diffs).length === 0) {
                            writeDocs();
                            return;
                        }

                        var generationOne = Object.keys(diffs).reduce(function(memo, id) {
                            if (diffs[id].missing.length === 1 && diffs[id].missing[0].slice(0, 2) === '1-') {
                                memo.ids.push(id);
                                memo.revs.push(diffs[id].missing[0]);
                                delete diffs[id];
                            }

                            return memo;
                        }, {
                            ids: [],
                            revs: []
                        });

                        if (generationOne.ids.length) {
                            return fetchGenerationOneRevs(generationOne.ids, generationOne.revs);
                        }

                        var id = Object.keys(diffs)[0];
                        var revs = diffs[id].missing;
                        delete diffs[id];

                        fetchSingleRev(src, onGet, id, revs);
                    }


                    function abortReplication(reason, err) {
                        if (completeCalled) {
                            return;
                        }
                        result.ok = false;
                        result.status = 'aborted';
                        result.errors.push(err);
                        result.end_time = new Date();
                        result.last_seq = last_seq;
                        batches = [];
                        pendingBatch = new Batch();
                        var error = {
                            status: 500,
                            error: 'Replication aborted',
                            reason: reason,
                            details: err
                        };
                        completeCalled = true;
                        PouchUtils.call(opts.complete, error, result);
                        promise.cancel();
                    }


                    function finishBatch() {
                        writingCheckpoint = true;
                        writeCheckpoint(src, target, repId, currentBatch.seq, function(err, res) {
                            writingCheckpoint = false;
                            if (promise.cancelled) {
                                return replicationComplete();
                            }
                            if (err) {
                                return abortReplication('writeCheckpoint completed with error', err);
                            }
                            result.last_seq = last_seq = currentBatch.seq;
                            PouchUtils.call(opts.onChange, null, result);
                            currentBatch = undefined;
                            startNextBatch();
                        });
                    }

                    function onRevsDiff(err, diffs) {
                        if (promise.cancelled) {
                            return replicationComplete();
                        }

                        if (err) {
                            return abortReplication('target.revsDiff completed with error', err);
                        }

                        if (Object.keys(diffs).length === 0) {
                            finishBatch();
                            return;
                        }

                        currentBatch.diffs = diffs;
                        currentBatch.pendingRevs = 0;
                        fetchRev();
                    }


                    function fetchRevsDiff() {
                        var diff = {};
                        currentBatch.changes.forEach(function(change) {
                            diff[change.id] = change.changes.map(function(x) {
                                return x.rev;
                            });
                        });

                        target.revsDiff(diff, onRevsDiff);
                    }


                    function startNextBatch() {
                        if (promise.cancelled) {
                            return replicationComplete();
                        }

                        if (currentBatch) {
                            return;
                        }

                        if (batches.length === 0) {
                            processPendingBatch();
                            return;
                        }

                        currentBatch = batches.shift();
                        fetchRevsDiff();
                    }


                    function processPendingBatch() {
                        if (pendingBatch.changes.length === 0) {
                            if (changesCompleted && batches.length === 0 && !currentBatch) {
                                replicationComplete();
                            }
                            return;
                        }

                        if (changesCompleted || pendingBatch.changes.length >= batch_size) {
                            batches.push(pendingBatch);
                            pendingBatch = new Batch();
                            startNextBatch();
                        }
                    }


                    function replicationComplete() {
                        if (completeCalled) {
                            return;
                        }
                        if (promise.cancelled) {
                            result.status = 'cancelled';
                            if (writingCheckpoint) {
                                return;
                            }
                        }
                        result.status = result.status || 'complete';
                        result.end_time = new Date();
                        result.last_seq = last_seq;
                        completeCalled = true;
                        if (result.errors.length > 0) {
                            return PouchUtils.call(opts.complete, result.errors[0], result);
                        } else {
                            return PouchUtils.call(opts.complete, null, result);
                        }
                    }


                    function onChange(change) {
                        if (promise.cancelled) {
                            return replicationComplete();
                        }

                        if (completeCalled) {
                            // This should never happen
                            // The complete callback has already been called
                            // How to raise an exception in PouchDB?
                            return;
                        }

                        pendingBatch.seq = change.seq;
                        pendingBatch.changes.push(change);

                        processPendingBatch();
                    }


                    function complete(err, changes) {
                        changesCompleted = true;
                        if (promise.cancelled) {
                            return replicationComplete();
                        }

                        if (err) {
                            result.status = 'src.changes completed with error';
                            result.errors.push(err);
                        }

                        processPendingBatch();
                    }


                    function getChanges() {
                        fetchCheckpoint(src, target, repId, function(err, checkpoint) {
                            if (err) {
                                return abortReplication('fetchCheckpoint completed with error', err);
                            }

                            last_seq = checkpoint;

                            // Was the replication cancelled by the caller before it had a chance
                            // to start. Shouldnt we be calling complete?
                            if (promise.cancelled) {
                                return replicationComplete();
                            }

                            // Call changes on the source database, with callbacks to onChange for
                            // each change and complete when done.
                            var repOpts = {
                                continuous: continuous,
                                since: last_seq,
                                style: 'all_docs',
                                onChange: onChange,
                                complete: complete,
                                doc_ids: doc_ids
                            };

                            if (opts.filter) {
                                repOpts.filter = opts.filter;
                            }

                            if (opts.query_params) {
                                repOpts.query_params = opts.query_params;
                            }

                            var changes = src.changes(repOpts);

                            var cancelPromise = promise.cancel;
                            promise.cancel = function() {
                                cancelPromise();
                                replicationComplete();
                                if (changes && changes.cancel instanceof Function) {
                                    changes.cancel();
                                }
                            };

                        });
                    }

                    // If opts.since is given, set the checkpoint to opts.since
                    if (typeof opts.since === 'undefined') {
                        getChanges();
                    } else {
                        writeCheckpoint(src, target, repId, opts.since, function(err, res) {
                            if (err) {
                                return abortReplication('writeCheckpoint completed with error', err);
                            }
                            last_seq = opts.since;
                            getChanges();
                        });
                    }
                }

                function fetchSingleRev(src, callback, id, revs) {
                    src.get(id, {
                        revs: true,
                        open_revs: revs,
                        attachments: true
                    }, callback);
                }

                function toPouch(db, callback) {
                    if (typeof db === 'string') {
                        return new Pouch(db, callback);
                    }
                    callback(null, db);
                }

                function replicateWrapper(src, target, opts, callback) {
                    if (opts instanceof Function) {
                        callback = opts;
                        opts = {};
                    }
                    if (opts === undefined) {
                        opts = {};
                    }
                    if (!opts.complete) {
                        opts.complete = callback;
                    }
                    opts = PouchUtils.extend(true, {}, opts);
                    opts.continuous = opts.continuous || opts.live;
                    var replicateRet = new Promise();
                    toPouch(src, function(err, src) {
                        if (err) {
                            return callback(err);
                        }
                        toPouch(target, function(err, target) {
                            if (err) {
                                return callback(err);
                            }
                            if (opts.server) {
                                if (typeof src.replicateOnServer !== 'function') {
                                    return callback({
                                        error: 'Server replication not supported for ' + src.type() +
                                            'adapter'
                                    });
                                }
                                if (src.type() !== target.type()) {
                                    return callback({
                                        error: 'Server replication for different adapter types (' +
                                            src.type() + ' and ' + target.type() + ') is not supported'
                                    });
                                }
                                src.replicateOnServer(target, opts, replicateRet);
                            } else {
                                genReplicationId(src, target, opts, function(repId) {
                                    replicate(repId, src, target, opts, replicateRet);
                                });
                            }
                        });
                    });
                    return replicateRet;
                }

                function sync(db1, db2, opts, callback) {
                    var push_promise;
                    var pull_promise;

                    if (opts instanceof Function) {
                        callback = opts;
                        opts = {};
                    }
                    if (opts === undefined) {
                        opts = {};
                    }
                    if (callback instanceof Function && !opts.complete) {
                        opts.complete = callback;
                    }

                    function complete(callback, direction) {
                        return function(err, res) {
                            if (err) {
                                // cancel both replications if either experiences problems
                                cancel();
                            }
                            res.direction = direction;
                            callback(err, res);
                        };
                    }

                    function onChange(src, callback) {
                        callback = callback || function() {};
                        return function(change) {
                            return {
                                source: src,
                                change: callback(change)
                            };
                        };
                    }

                    function makeOpts(src, opts, direction) {
                        opts = PouchUtils.extend(true, {}, opts);
                        opts.complete = complete(opts.complete, direction);
                        opts.onChange = onChange(src, opts.onChange);
                        opts.continuous = opts.continuous || opts.live;
                        return opts;
                    }

                    function push() {
                        push_promise =
                            replicateWrapper(db1, db2, makeOpts(db1, opts, 'push'), callback);
                        return push_promise;
                    }

                    function pull() {
                        pull_promise =
                            replicateWrapper(db2, db1, makeOpts(db2, opts, 'pull'), callback);
                        return pull_promise;
                    }

                    function cancel() {
                        if (push_promise) {
                            push_promise.cancel();
                        }
                        if (pull_promise) {
                            pull_promise.cancel();
                        }
                    }

                    return {
                        push: push(),
                        pull: pull(),
                        cancel: cancel
                    };
                }

                exports.replicate = replicateWrapper;
                exports.sync = sync;

            }, {
                "./index": 13,
                "./utils": 18
            }
        ],
        16: [
            function(_dereq_, module, exports) {
                (function(global) {
                    "use strict";

                    var PouchDB = _dereq_("./constructor");
                    var utils = _dereq_('./utils');
                    var EventEmitter = _dereq_('events').EventEmitter;
                    PouchDB.adapters = {};

                    PouchDB.prefix = '_pouch_';

                    var eventEmitter = new EventEmitter();

                    var eventEmitterMethods = [
                        'on',
                        'addListener',
                        'emit',
                        'listeners',
                        'once',
                        'removeAllListeners',
                        'removeListener',
                        'setMaxListeners'
                    ];

                    var preferredAdapters = ['levelalt', 'idb', 'leveldb', 'websql'];

                    eventEmitterMethods.forEach(function(method) {
                        PouchDB[method] = eventEmitter[method].bind(eventEmitter);
                    });
                    PouchDB.setMaxListeners(0);
                    PouchDB.parseAdapter = function(name, opts) {
                        var match = name.match(/([a-z\-]*):\/\/(.*)/);
                        var adapter, adapterName;
                        if (match) {
                            // the http adapter expects the fully qualified name
                            name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];
                            adapter = match[1];
                            if (!PouchDB.adapters[adapter].valid()) {
                                throw 'Invalid adapter';
                            }
                            return {
                                name: name,
                                adapter: match[1]
                            };
                        }

                        // check for browsers that have been upgraded from websql-only to websql+idb
                        var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&
                            utils.hasLocalStorage() &&
                            global.localStorage['_pouch__websqldb_' + PouchDB.prefix + name];

                        if (typeof opts !== 'undefined' && opts.db) {
                            adapterName = 'leveldb';
                        } else {
                            for (var i = 0; i < preferredAdapters.length; ++i) {
                                adapterName = preferredAdapters[i];
                                if (adapterName in PouchDB.adapters) {
                                    if (skipIdb && adapterName === 'idb') {
                                        continue; // keep using websql to avoid user data loss
                                    }
                                    break;
                                }
                            }
                        }

                        if (adapterName) {
                            adapter = PouchDB.adapters[adapterName];
                            var use_prefix = 'use_prefix' in adapter ? adapter.use_prefix : true;

                            return {
                                name: use_prefix ? PouchDB.prefix + name : name,
                                adapter: adapterName
                            };
                        }

                        throw 'No valid adapter found';
                    };

                    PouchDB.destroy = utils.toPromise(function(name, opts, callback) {
                        if (typeof opts === 'function' || typeof opts === 'undefined') {
                            callback = opts;
                            opts = {};
                        }

                        if (typeof name === 'object') {
                            opts = name;
                            name = undefined;
                        }

                        var backend = PouchDB.parseAdapter(opts.name || name, opts);
                        var dbName = backend.name;

                        // call destroy method of the particular adaptor
                        PouchDB.adapters[backend.adapter].destroy(dbName, opts, function(err, resp) {
                            if (err) {
                                callback(err);
                            } else {
                                PouchDB.emit('destroyed', dbName);
                                //so we don't have to sift through all dbnames
                                PouchDB.emit(dbName, 'destroyed');
                                callback(null, resp);
                            }
                        });
                    });
                    PouchDB.allDbs = utils.toPromise(function(callback) {
                        var err = new Error('allDbs method removed');
                        err.stats = '400';
                        callback(err);
                    });
                    PouchDB.adapter = function(id, obj) {
                        if (obj.valid()) {
                            PouchDB.adapters[id] = obj;
                        }
                    };

                    PouchDB.plugin = function(obj) {
                        Object.keys(obj).forEach(function(id) {
                            PouchDB.prototype[id] = obj[id];
                        });
                    };

                    module.exports = PouchDB;

                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {
                "./constructor": 5,
                "./utils": 18,
                "events": 21
            }
        ],
        17: [
            function(_dereq_, module, exports) {
                'use strict';

                module.exports = TaskQueue;

                function TaskQueue() {
                    this.isReady = false;
                    this.failed = false;
                    this.queue = [];
                }

                TaskQueue.prototype.execute = function() {
                    var d, func;
                    if (this.failed) {
                        while ((d = this.queue.shift())) {
                            func = d.parameters[d.parameters.length - 1];
                            if (typeof func === 'function') {
                                func(this.failed);
                            } else if (d.name === 'changes' && typeof func.complete === 'function') {
                                func.complete(this.failed);
                            }
                        }
                    } else if (this.isReady) {
                        while ((d = this.queue.shift())) {
                            if (typeof d === 'function') {
                                d();
                            } else {
                                d.task = this.db[d.name].apply(this.db, d.parameters);
                            }
                        }
                    }
                };

                TaskQueue.prototype.fail = function(err) {
                    this.failed = err;
                    this.execute();
                };

                TaskQueue.prototype.ready = function(db) {
                    if (this.failed) {
                        return false;
                    } else if (arguments.length === 0) {
                        return this.isReady;
                    }
                    this.isReady = db ? true : false;
                    this.db = db;
                    this.execute();
                };

                TaskQueue.prototype.addTask = function(name, parameters) {
                    if (typeof name === 'function') {
                        this.queue.push(name);
                    } else {
                        var task = {
                            name: name,
                            parameters: parameters
                        };
                        this.queue.push(task);
                        if (this.failed) {
                            this.execute();
                        }
                        return task;
                    }
                };

            }, {}
        ],
        18: [
            function(_dereq_, module, exports) {
                (function(process, global) {
                    /*jshint strict: false */
                    /*global chrome */

                    var merge = _dereq_('./merge');
                    exports.extend = _dereq_('./deps/extend');
                    exports.ajax = _dereq_('./deps/ajax');
                    exports.createBlob = _dereq_('./deps/blob');
                    var uuid = _dereq_('./deps/uuid');
                    exports.Crypto = _dereq_('./deps/md5.js');
                    var buffer = _dereq_('./deps/buffer');
                    var errors = _dereq_('./deps/errors');
                    var EventEmitter = _dereq_('events').EventEmitter;
                    var Promise = typeof global.Promise === 'function' ? global.Promise : _dereq_('bluebird');

                    // List of top level reserved words for doc
                    var reservedWords = [
                        '_id',
                        '_rev',
                        '_attachments',
                        '_deleted',
                        '_revisions',
                        '_revs_info',
                        '_conflicts',
                        '_deleted_conflicts',
                        '_local_seq',
                        '_rev_tree'
                    ];
                    exports.inherits = _dereq_('inherits');
                    exports.uuids = function(count, options) {

                        if (typeof(options) !== 'object') {
                            options = {};
                        }

                        var length = options.length;
                        var radix = options.radix;
                        var uuids = [];

                        while (uuids.push(uuid(length, radix)) < count) {}

                        return uuids;
                    };

                    // Give back one UUID
                    exports.uuid = function(options) {
                        return exports.uuids(1, options)[0];
                    };
                    // Determine id an ID is valid
                    //   - invalid IDs begin with an underescore that does not begin '_design' or '_local'
                    //   - any other string value is a valid id
                    // Returns the specific error object for each case
                    exports.invalidIdError = function(id) {
                        if (!id) {
                            return errors.MISSING_ID;
                        } else if (typeof id !== 'string') {
                            return errors.INVALID_ID;
                        } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
                            return errors.RESERVED_ID;
                        }
                    };

                    function isChromeApp() {
                        return (typeof chrome !== "undefined" &&
                            typeof chrome.storage !== "undefined" &&
                            typeof chrome.storage.local !== "undefined");
                    }

                    exports.getArguments = function(fun) {
                        return function() {
                            var len = arguments.length;
                            var args = new Array(len);
                            var i = -1;
                            while (++i < len) {
                                args[i] = arguments[i];
                            }
                            return fun.call(this, args);
                        };
                    };
                    // Pretty dumb name for a function, just wraps callback calls so we dont
                    // to if (callback) callback() everywhere
                    exports.call = exports.getArguments(function(args) {
                        if (!args.length) {
                            return;
                        }
                        var fun = args.shift();
                        if (typeof fun === 'function') {
                            fun.apply(this, args);
                        }
                    });

                    exports.isLocalId = function(id) {
                        return (/^_local/).test(id);
                    };

                    // check if a specific revision of a doc has been deleted
                    //  - metadata: the metadata object from the doc store
                    //  - rev: (optional) the revision to check. defaults to winning revision
                    exports.isDeleted = function(metadata, rev) {
                        if (!rev) {
                            rev = merge.winningRev(metadata);
                        }
                        if (rev.indexOf('-') >= 0) {
                            rev = rev.split('-')[1];
                        }
                        var deleted = false;
                        merge.traverseRevTree(metadata.rev_tree, function(isLeaf, pos, id, acc, opts) {
                            if (id === rev) {
                                deleted = !! opts.deleted;
                            }
                        });

                        return deleted;
                    };

                    exports.filterChange = function(opts) {
                        return function(change) {
                            var req = {};
                            var hasFilter = opts.filter && typeof opts.filter === 'function';

                            req.query = opts.query_params;
                            if (opts.filter && hasFilter && !opts.filter.call(this, change.doc, req)) {
                                return false;
                            }
                            if (opts.doc_ids && opts.doc_ids.indexOf(change.id) === -1) {
                                return false;
                            }
                            if (!opts.include_docs) {
                                delete change.doc;
                            } else {
                                for (var att in change.doc._attachments) {
                                    if (change.doc._attachments.hasOwnProperty(att)) {
                                        change.doc._attachments[att].stub = true;
                                    }
                                }
                            }
                            return true;
                        };
                    };

                    exports.processChanges = function(opts, changes, last_seq) {
                        // TODO: we should try to filter and limit as soon as possible
                        changes = changes.filter(exports.filterChange(opts));
                        if (opts.limit) {
                            if (opts.limit < changes.length) {
                                changes.length = opts.limit;
                            }
                        }
                        changes.forEach(function(change) {
                            exports.call(opts.onChange, change);
                        });
                        if (!opts.continuous) {
                            exports.call(opts.complete, null, {
                                results: changes,
                                last_seq: last_seq
                            });
                        }
                    };

                    // Preprocess documents, parse their revisions, assign an id and a
                    // revision for new writes that are missing them, etc
                    exports.parseDoc = function(doc, newEdits) {
                        var error = null;
                        var nRevNum;
                        var newRevId;
                        var revInfo;
                        var opts = {
                            status: 'available'
                        };
                        if (doc._deleted) {
                            opts.deleted = true;
                        }

                        if (newEdits) {
                            if (!doc._id) {
                                doc._id = exports.uuid();
                            }
                            newRevId = exports.uuid({
                                length: 32,
                                radix: 16
                            }).toLowerCase();
                            if (doc._rev) {
                                revInfo = /^(\d+)-(.+)$/.exec(doc._rev);
                                if (!revInfo) {
                                    throw "invalid value for property '_rev'";
                                }
                                doc._rev_tree = [{
                                    pos: parseInt(revInfo[1], 10),
                                    ids: [revInfo[2], {
                                            status: 'missing'
                                        },
                                        [
                                            [newRevId, opts, []]
                                        ]
                                    ]
                                }];
                                nRevNum = parseInt(revInfo[1], 10) + 1;
                            } else {
                                doc._rev_tree = [{
                                    pos: 1,
                                    ids: [newRevId, opts, []]
                                }];
                                nRevNum = 1;
                            }
                        } else {
                            if (doc._revisions) {
                                doc._rev_tree = [{
                                    pos: doc._revisions.start - doc._revisions.ids.length + 1,
                                    ids: doc._revisions.ids.reduce(function(acc, x) {
                                        if (acc === null) {
                                            return [x, opts, []];
                                        } else {
                                            return [x, {
                                                status: 'missing'
                                            }, [acc]];
                                        }
                                    }, null)
                                }];
                                nRevNum = doc._revisions.start;
                                newRevId = doc._revisions.ids[0];
                            }
                            if (!doc._rev_tree) {
                                revInfo = /^(\d+)-(.+)$/.exec(doc._rev);
                                if (!revInfo) {
                                    return errors.BAD_ARG;
                                }
                                nRevNum = parseInt(revInfo[1], 10);
                                newRevId = revInfo[2];
                                doc._rev_tree = [{
                                    pos: parseInt(revInfo[1], 10),
                                    ids: [revInfo[2], opts, []]
                                }];
                            }
                        }

                        error = exports.invalidIdError(doc._id);

                        for (var key in doc) {
                            if (doc.hasOwnProperty(key) && key[0] === '_' && reservedWords.indexOf(key) === -1) {
                                error = exports.extend({}, errors.DOC_VALIDATION);
                                error.reason += ': ' + key;
                            }
                        }

                        doc._id = decodeURIComponent(doc._id);
                        doc._rev = [nRevNum, newRevId].join('-');

                        if (error) {
                            return error;
                        }

                        return Object.keys(doc).reduce(function(acc, key) {
                            if (/^_/.test(key) && key !== '_attachments') {
                                acc.metadata[key.slice(1)] = doc[key];
                            } else {
                                acc.data[key] = doc[key];
                            }
                            return acc;
                        }, {
                            metadata: {},
                            data: {}
                        });
                    };

                    exports.isCordova = function() {
                        return (typeof cordova !== "undefined" ||
                            typeof PhoneGap !== "undefined" ||
                            typeof phonegap !== "undefined");
                    };

                    exports.hasLocalStorage = function() {
                        if (isChromeApp()) {
                            return false;
                        }
                        try {
                            return global.localStorage;
                        } catch (e) {
                            return false;
                        }
                    };
                    exports.Changes = function() {

                        var api = {};
                        var eventEmitter = new EventEmitter();
                        var isChrome = isChromeApp();
                        var listeners = {};
                        var hasLocal = false;
                        if (!isChrome) {
                            hasLocal = exports.hasLocalStorage();
                        }
                        if (isChrome) {
                            chrome.storage.onChanged.addListener(function(e) {
                                // make sure it's event addressed to us
                                if (e.db_name != null) {
                                    eventEmitter.emit(e.dbName.newValue); //object only has oldValue, newValue members
                                }
                            });
                        } else if (hasLocal) {
                            if (global.addEventListener) {
                                global.addEventListener("storage", function(e) {
                                    eventEmitter.emit(e.key);
                                });
                            } else {
                                global.attachEvent("storage", function(e) {
                                    eventEmitter.emit(e.key);
                                });
                            }
                        }

                        api.addListener = function(dbName, id, db, opts) {
                            if (listeners[id]) {
                                return;
                            }

                            function eventFunction() {
                                db.changes({
                                    include_docs: opts.include_docs,
                                    conflicts: opts.conflicts,
                                    continuous: false,
                                    descending: false,
                                    filter: opts.filter,
                                    view: opts.view,
                                    since: opts.since,
                                    query_params: opts.query_params,
                                    onChange: function(c) {
                                        if (c.seq > opts.since && !opts.cancelled) {
                                            opts.since = c.seq;
                                            exports.call(opts.onChange, c);
                                        }
                                    }
                                });
                            }
                            listeners[id] = eventFunction;
                            eventEmitter.on(dbName, eventFunction);
                        };

                        api.removeListener = function(dbName, id) {
                            if (!(id in listeners)) {
                                return;
                            }
                            eventEmitter.removeListener(dbName, listeners[id]);
                        };

                        api.clearListeners = function(dbName) {
                            eventEmitter.removeAllListeners(dbName);
                        };

                        api.notifyLocalWindows = function(dbName) {
                            //do a useless change on a storage thing
                            //in order to get other windows's listeners to activate
                            if (isChrome) {
                                chrome.storage.local.set({
                                    dbName: dbName
                                });
                            } else if (hasLocal) {
                                localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
                            }
                        };

                        api.notify = function(dbName) {
                            eventEmitter.emit(dbName);
                        };

                        return api;
                    };

                    if (!process.browser || !('atob' in global)) {
                        exports.atob = function(str) {
                            var base64 = new buffer(str, 'base64');
                            // Node.js will just skip the characters it can't encode instead of
                            // throwing and exception
                            if (base64.toString('base64') !== str) {
                                throw ("Cannot base64 encode full string");
                            }
                            return base64.toString('binary');
                        };
                    } else {
                        exports.atob = function(str) {
                            return atob(str);
                        };
                    }

                    if (!process.browser || !('btoa' in global)) {
                        exports.btoa = function(str) {
                            return new buffer(str, 'binary').toString('base64');
                        };
                    } else {
                        exports.btoa = function(str) {
                            return btoa(str);
                        };
                    }

                    // From http://stackoverflow.com/questions/14967647/encode-decode-image-with-base64-breaks-image (2013-04-21)
                    exports.fixBinary = function(bin) {
                        if (!process.browser) {
                            // don't need to do this in Node
                            return bin;
                        }

                        var length = bin.length;
                        var buf = new ArrayBuffer(length);
                        var arr = new Uint8Array(buf);
                        for (var i = 0; i < length; i++) {
                            arr[i] = bin.charCodeAt(i);
                        }
                        return buf;
                    };

                    exports.once = function(fun) {
                        var called = false;
                        return exports.getArguments(function(args) {
                            if (called) {
                                console.trace();
                                throw new Error('once called  more than once');
                            } else {
                                called = true;
                                fun.apply(this, args);
                            }
                        });
                    };

                    exports.toPromise = function(func) {
                        //create the function we will be returning
                        return exports.getArguments(function(args) {
                            var self = this;
                            var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
                            // if the last argument is a function, assume its a callback
                            var usedCB;
                            if (tempCB) {
                                // if it was a callback, create a new callback which calls it,
                                // but do so async so we don't trap any errors
                                usedCB = function(err, resp) {
                                    process.nextTick(function() {
                                        tempCB(err, resp);
                                    });
                                };
                            }
                            var promise = new Promise(function(fulfill, reject) {
                                try {
                                    var callback = exports.once(function(err, mesg) {
                                        if (err) {
                                            reject(err);
                                        } else {
                                            fulfill(mesg);
                                        }
                                    });
                                    // create a callback for this invocation
                                    // apply the function in the orig context
                                    args.push(callback);
                                    func.apply(self, args);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                            // if there is a callback, call it back
                            if (usedCB) {
                                promise.then(function(result) {
                                    usedCB(null, result);
                                }, usedCB);
                            }
                            promise.cancel = function() {
                                return this;
                            };
                            return promise;
                        });
                    };

                    exports.adapterFun = function(name, callback) {
                        return exports.toPromise(exports.getArguments(function(args) {
                            if (!this.taskqueue.isReady) {
                                this.taskqueue.addTask(name, args);
                                return;
                            }
                            callback.apply(this, args);
                        }));
                    };
                    //Can't find original post, but this is close
                    //http://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers
                    exports.arrayBufferToBinaryString = function(buffer) {
                        var binary = "";
                        var bytes = new Uint8Array(buffer);
                        var length = bytes.byteLength;
                        for (var i = 0; i < length; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        return binary;
                    };

                    exports.cancellableFun = function(fun, self, opts) {

                        opts = opts ? exports.extend(true, {}, opts) : {};
                        opts.complete = opts.complete || function() {};
                        var complete = exports.once(opts.complete);

                        var promise = new Promise(function(fulfill, reject) {
                            opts.complete = function(err, res) {
                                if (err) {
                                    reject(err);
                                } else {
                                    fulfill(res);
                                }
                            };
                        });

                        promise.then(function(result) {
                            complete(null, result);
                        }, complete);

                        // this needs to be overwridden by caller, dont fire complete until
                        // the task is ready
                        promise.cancel = function() {
                            promise.isCancelled = true;
                            if (self.taskqueue.isReady) {
                                opts.complete(null, {
                                    status: 'cancelled'
                                });
                            }
                        };

                        if (!self.taskqueue.isReady) {
                            self.taskqueue.addTask(function() {
                                if (promise.isCancelled) {
                                    opts.complete(null, {
                                        status: 'cancelled'
                                    });
                                } else {
                                    fun(self, opts, promise);
                                }
                            });
                            return promise;
                        } else {
                            fun(self, opts, promise);
                            return promise;
                        }
                    };

                }).call(this, _dereq_("/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {
                "./deps/ajax": 6,
                "./deps/blob": 7,
                "./deps/buffer": 20,
                "./deps/errors": 8,
                "./deps/extend": 10,
                "./deps/md5.js": 11,
                "./deps/uuid": 12,
                "./merge": 14,
                "/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js": 22,
                "bluebird": 27,
                "events": 21,
                "inherits": 23
            }
        ],
        19: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_('../package.json').version;
            }, {
                "../package.json": 52
            }
        ],
        20: [
            function(_dereq_, module, exports) {

            }, {}
        ],
        21: [
            function(_dereq_, module, exports) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.

                function EventEmitter() {
                    this._events = this._events || {};
                    this._maxListeners = this._maxListeners || undefined;
                }
                module.exports = EventEmitter;

                // Backwards-compat with node 0.10.x
                EventEmitter.EventEmitter = EventEmitter;

                EventEmitter.prototype._events = undefined;
                EventEmitter.prototype._maxListeners = undefined;

                // By default EventEmitters will print a warning if more than 10 listeners are
                // added to it. This is a useful default which helps finding memory leaks.
                EventEmitter.defaultMaxListeners = 10;

                // Obviously not all Emitters should be limited to 10. This function allows
                // that to be increased. Set to zero for unlimited.
                EventEmitter.prototype.setMaxListeners = function(n) {
                    if (!isNumber(n) || n < 0 || isNaN(n))
                        throw TypeError('n must be a positive number');
                    this._maxListeners = n;
                    return this;
                };

                EventEmitter.prototype.emit = function(type) {
                    var er, handler, len, args, i, listeners;

                    if (!this._events)
                        this._events = {};

                    // If there is no 'error' event listener then throw.
                    if (type === 'error') {
                        if (!this._events.error ||
                            (isObject(this._events.error) && !this._events.error.length)) {
                            er = arguments[1];
                            if (er instanceof Error) {
                                throw er; // Unhandled 'error' event
                            } else {
                                throw TypeError('Uncaught, unspecified "error" event.');
                            }
                            return false;
                        }
                    }

                    handler = this._events[type];

                    if (isUndefined(handler))
                        return false;

                    if (isFunction(handler)) {
                        switch (arguments.length) {
                            // fast cases
                            case 1:
                                handler.call(this);
                                break;
                            case 2:
                                handler.call(this, arguments[1]);
                                break;
                            case 3:
                                handler.call(this, arguments[1], arguments[2]);
                                break;
                                // slower
                            default:
                                len = arguments.length;
                                args = new Array(len - 1);
                                for (i = 1; i < len; i++)
                                    args[i - 1] = arguments[i];
                                handler.apply(this, args);
                        }
                    } else if (isObject(handler)) {
                        len = arguments.length;
                        args = new Array(len - 1);
                        for (i = 1; i < len; i++)
                            args[i - 1] = arguments[i];

                        listeners = handler.slice();
                        len = listeners.length;
                        for (i = 0; i < len; i++)
                            listeners[i].apply(this, args);
                    }

                    return true;
                };

                EventEmitter.prototype.addListener = function(type, listener) {
                    var m;

                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');

                    if (!this._events)
                        this._events = {};

                    // To avoid recursion in the case that type === "newListener"! Before
                    // adding it to the listeners, first emit "newListener".
                    if (this._events.newListener)
                        this.emit('newListener', type,
                            isFunction(listener.listener) ?
                            listener.listener : listener);

                    if (!this._events[type])
                    // Optimize the case of one listener. Don't need the extra array object.
                        this._events[type] = listener;
                    else if (isObject(this._events[type]))
                    // If we've already got an array, just append.
                        this._events[type].push(listener);
                    else
                    // Adding the second element, need to change to array.
                        this._events[type] = [this._events[type], listener];

                    // Check for listener leak
                    if (isObject(this._events[type]) && !this._events[type].warned) {
                        var m;
                        if (!isUndefined(this._maxListeners)) {
                            m = this._maxListeners;
                        } else {
                            m = EventEmitter.defaultMaxListeners;
                        }

                        if (m && m > 0 && this._events[type].length > m) {
                            this._events[type].warned = true;
                            console.error('(node) warning: possible EventEmitter memory ' +
                                'leak detected. %d listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit.',
                                this._events[type].length);
                            console.trace();
                        }
                    }

                    return this;
                };

                EventEmitter.prototype.on = EventEmitter.prototype.addListener;

                EventEmitter.prototype.once = function(type, listener) {
                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');

                    var fired = false;

                    function g() {
                        this.removeListener(type, g);

                        if (!fired) {
                            fired = true;
                            listener.apply(this, arguments);
                        }
                    }

                    g.listener = listener;
                    this.on(type, g);

                    return this;
                };

                // emits a 'removeListener' event iff the listener was removed
                EventEmitter.prototype.removeListener = function(type, listener) {
                    var list, position, length, i;

                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');

                    if (!this._events || !this._events[type])
                        return this;

                    list = this._events[type];
                    length = list.length;
                    position = -1;

                    if (list === listener ||
                        (isFunction(list.listener) && list.listener === listener)) {
                        delete this._events[type];
                        if (this._events.removeListener)
                            this.emit('removeListener', type, listener);

                    } else if (isObject(list)) {
                        for (i = length; i-- > 0;) {
                            if (list[i] === listener ||
                                (list[i].listener && list[i].listener === listener)) {
                                position = i;
                                break;
                            }
                        }

                        if (position < 0)
                            return this;

                        if (list.length === 1) {
                            list.length = 0;
                            delete this._events[type];
                        } else {
                            list.splice(position, 1);
                        }

                        if (this._events.removeListener)
                            this.emit('removeListener', type, listener);
                    }

                    return this;
                };

                EventEmitter.prototype.removeAllListeners = function(type) {
                    var key, listeners;

                    if (!this._events)
                        return this;

                    // not listening for removeListener, no need to emit
                    if (!this._events.removeListener) {
                        if (arguments.length === 0)
                            this._events = {};
                        else if (this._events[type])
                            delete this._events[type];
                        return this;
                    }

                    // emit removeListener for all listeners on all events
                    if (arguments.length === 0) {
                        for (key in this._events) {
                            if (key === 'removeListener') continue;
                            this.removeAllListeners(key);
                        }
                        this.removeAllListeners('removeListener');
                        this._events = {};
                        return this;
                    }

                    listeners = this._events[type];

                    if (isFunction(listeners)) {
                        this.removeListener(type, listeners);
                    } else {
                        // LIFO order
                        while (listeners.length)
                            this.removeListener(type, listeners[listeners.length - 1]);
                    }
                    delete this._events[type];

                    return this;
                };

                EventEmitter.prototype.listeners = function(type) {
                    var ret;
                    if (!this._events || !this._events[type])
                        ret = [];
                    else if (isFunction(this._events[type]))
                        ret = [this._events[type]];
                    else
                        ret = this._events[type].slice();
                    return ret;
                };

                EventEmitter.listenerCount = function(emitter, type) {
                    var ret;
                    if (!emitter._events || !emitter._events[type])
                        ret = 0;
                    else if (isFunction(emitter._events[type]))
                        ret = 1;
                    else
                        ret = emitter._events[type].length;
                    return ret;
                };

                function isFunction(arg) {
                    return typeof arg === 'function';
                }

                function isNumber(arg) {
                    return typeof arg === 'number';
                }

                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }

                function isUndefined(arg) {
                    return arg === void 0;
                }

            }, {}
        ],
        22: [
            function(_dereq_, module, exports) {
                // shim for using process in browser

                var process = module.exports = {};

                process.nextTick = (function() {
                    var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
                    var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;

                    if (canSetImmediate) {
                        return function(f) {
                            return window.setImmediate(f)
                        };
                    }

                    if (canPost) {
                        var queue = [];
                        window.addEventListener('message', function(ev) {
                            var source = ev.source;
                            if ((source === window || source === null) && ev.data === 'process-tick') {
                                ev.stopPropagation();
                                if (queue.length > 0) {
                                    var fn = queue.shift();
                                    fn();
                                }
                            }
                        }, true);

                        return function nextTick(fn) {
                            queue.push(fn);
                            window.postMessage('process-tick', '*');
                        };
                    }

                    return function nextTick(fn) {
                        setTimeout(fn, 0);
                    };
                })();

                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];

                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                }

                // TODO(shtylman)
                process.cwd = function() {
                    return '/'
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };

            }, {}
        ],
        23: [
            function(_dereq_, module, exports) {
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module.exports = function inherits(ctor, superCtor) {
                        ctor.super_ = superCtor
                        ctor.prototype = Object.create(superCtor.prototype, {
                            constructor: {
                                value: ctor,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                    };
                } else {
                    // old school shim for old browsers
                    module.exports = function inherits(ctor, superCtor) {
                        ctor.super_ = superCtor
                        var TempCtor = function() {}
                        TempCtor.prototype = superCtor.prototype
                        ctor.prototype = new TempCtor()
                        ctor.prototype.constructor = ctor
                    }
                }

            }, {}
        ],
        24: [
            function(_dereq_, module, exports) {
                'use strict';

                module.exports = INTERNAL;

                function INTERNAL() {}
            }, {}
        ],
        25: [
            function(_dereq_, module, exports) {
                'use strict';
                var INTERNAL = _dereq_('./INTERNAL');
                var Promise = _dereq_('./promise');
                var reject = _dereq_('./reject');
                var resolve = _dereq_('./resolve');

                module.exports = function all(iterable) {
                    if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                        return reject(new TypeError('must be an array'));
                    }
                    var len = iterable.length;
                    if (!len) {
                        return resolve([]);
                    }
                    var values = [];
                    var resolved = 0;
                    var i = -1;
                    var promise = new Promise(INTERNAL);

                    function allResolver(value, i) {
                        resolve(value).then(function(outValue) {
                            values[i] = outValue;
                            if (++resolved === len) {
                                promise.resolve(values);
                            }
                        }, function(error) {
                            promise.reject(error);
                        });
                    }

                    while (++i < len) {
                        allResolver(iterable[i], i);
                    }
                    return promise;
                };
            }, {
                "./INTERNAL": 24,
                "./promise": 29,
                "./reject": 30,
                "./resolve": 31
            }
        ],
        26: [
            function(_dereq_, module, exports) {
                'use strict';

                module.exports = getThen;

                function getThen(obj) {
                    // Make sure we only access the accessor once as required by the spec
                    var then = obj && obj.then;
                    if (obj && typeof obj === 'object' && typeof then === 'function') {
                        return function appyThen() {
                            then.apply(obj, arguments);
                        };
                    }
                }
            }, {}
        ],
        27: [
            function(_dereq_, module, exports) {
                module.exports = exports = _dereq_('./promise');

                exports.resolve = _dereq_('./resolve');
                exports.reject = _dereq_('./reject');
                exports.all = _dereq_('./all');
            }, {
                "./all": 25,
                "./promise": 29,
                "./reject": 30,
                "./resolve": 31
            }
        ],
        28: [
            function(_dereq_, module, exports) {
                'use strict';

                module.exports = once;

                /* Wrap an arbitrary number of functions and allow only one of them to be
   executed and only once */
                function once() {
                    var called = 0;
                    return function wrapper(wrappedFunction) {
                        return function() {
                            if (called++) {
                                return;
                            }
                            wrappedFunction.apply(this, arguments);
                        };
                    };
                }
            }, {}
        ],
        29: [
            function(_dereq_, module, exports) {
                'use strict';

                var unwrap = _dereq_('./unwrap');
                var INTERNAL = _dereq_('./INTERNAL');
                var once = _dereq_('./once');
                var tryCatch = _dereq_('./tryCatch');
                var getThen = _dereq_('./getThen');

                // Lazy man's symbols for states
                var PENDING = ['PENDING'],
                    FULFILLED = ['FULFILLED'],
                    REJECTED = ['REJECTED'];
                module.exports = Promise;

                function Promise(resolver) {
                    if (!(this instanceof Promise)) {
                        return new Promise(resolver);
                    }
                    if (typeof resolver !== 'function') {
                        throw new TypeError('reslover must be a function');
                    }
                    this.state = PENDING;
                    this.queue = [];
                    if (resolver !== INTERNAL) {
                        safelyResolveThenable(this, resolver);
                    }
                }
                Promise.prototype.resolve = function(value) {
                    var result = tryCatch(getThen, value);
                    if (result.status === 'error') {
                        return this.reject(result.value);
                    }
                    var thenable = result.value;

                    if (thenable) {
                        safelyResolveThenable(this, thenable);
                    } else {
                        this.state = FULFILLED;
                        this.outcome = value;
                        var i = -1;
                        var len = this.queue.length;
                        while (++i < len) {
                            this.queue[i].callFulfilled(value);
                        }
                    }
                    return this;
                };
                Promise.prototype.reject = function(error) {
                    this.state = REJECTED;
                    this.outcome = error;
                    var i = -1;
                    var len = this.queue.length;
                    while (++i < len) {
                        this.queue[i].callRejected(error);
                    }
                    return this;
                };

                Promise.prototype['catch'] = function(onRejected) {
                    return this.then(null, onRejected);
                };
                Promise.prototype.then = function(onFulfilled, onRejected) {
                    var onFulfilledFunc = typeof onFulfilled === 'function';
                    var onRejectedFunc = typeof onRejected === 'function';
                    if (!onFulfilledFunc && this.state === FULFILLED || !onRejected && this.state === REJECTED) {
                        return this;
                    }
                    var promise = new Promise(INTERNAL);

                    var thenHandler = {
                        promise: promise,
                    };
                    if (this.state !== REJECTED) {
                        if (onFulfilledFunc) {
                            thenHandler.callFulfilled = function(value) {
                                unwrap(promise, onFulfilled, value);
                            };
                        } else {
                            thenHandler.callFulfilled = function(value) {
                                promise.resolve(value);
                            };
                        }
                    }
                    if (this.state !== FULFILLED) {
                        if (onRejectedFunc) {
                            thenHandler.callRejected = function(value) {
                                unwrap(promise, onRejected, value);
                            };
                        } else {
                            thenHandler.callRejected = function(value) {
                                promise.reject(value);
                            };
                        }
                    }
                    if (this.state === FULFILLED) {
                        thenHandler.callFulfilled(this.outcome);
                    } else if (this.state === REJECTED) {
                        thenHandler.callRejected(this.outcome);
                    } else {
                        this.queue.push(thenHandler);
                    }

                    return promise;
                };

                function safelyResolveThenable(self, thenable) {
                    // Either fulfill, reject or reject with error
                    var onceWrapper = once();
                    var onError = onceWrapper(function(value) {
                        return self.reject(value);
                    });
                    var result = tryCatch(function() {
                        thenable(
                            onceWrapper(function(value) {
                                return self.resolve(value);
                            }),
                            onError
                        );
                    });
                    if (result.status === 'error') {
                        onError(result.value);
                    }
                }
            }, {
                "./INTERNAL": 24,
                "./getThen": 26,
                "./once": 28,
                "./tryCatch": 32,
                "./unwrap": 33
            }
        ],
        30: [
            function(_dereq_, module, exports) {
                'use strict';

                var Promise = _dereq_('./promise');
                var INTERNAL = _dereq_('./INTERNAL');

                module.exports = reject;

                function reject(reason) {
                    var promise = new Promise(INTERNAL);
                    return promise.reject(reason);
                }
            }, {
                "./INTERNAL": 24,
                "./promise": 29
            }
        ],
        31: [
            function(_dereq_, module, exports) {
                'use strict';

                var Promise = _dereq_('./promise');
                var INTERNAL = _dereq_('./INTERNAL');

                module.exports = resolve;

                var FALSE = new Promise(INTERNAL).resolve(false);
                var NULL = new Promise(INTERNAL).resolve(null);
                var UNDEFINED = new Promise(INTERNAL).resolve(void 0);
                var ZERO = new Promise(INTERNAL).resolve(0);
                var EMPTYSTRING = new Promise(INTERNAL).resolve('');

                function resolve(value) {
                    if (value) {
                        return new Promise(INTERNAL).resolve(value);
                    }
                    var valueType = typeof value;
                    switch (valueType) {
                        case 'boolean':
                            return FALSE;
                        case 'undefined':
                            return UNDEFINED;
                        case 'object':
                            return NULL;
                        case 'number':
                            return ZERO;
                        case 'string':
                            return EMPTYSTRING;
                    }
                }
            }, {
                "./INTERNAL": 24,
                "./promise": 29
            }
        ],
        32: [
            function(_dereq_, module, exports) {
                'use strict';

                module.exports = tryCatch;

                function tryCatch(func, value) {
                    var out = {};
                    try {
                        out.value = func(value);
                        out.status = 'success';
                    } catch (e) {
                        out.status = 'error';
                        out.value = e;
                    }
                    return out;
                }
            }, {}
        ],
        33: [
            function(_dereq_, module, exports) {
                'use strict';

                var immediate = _dereq_('immediate');

                module.exports = unwrap;

                function unwrap(promise, func, value) {
                    immediate(function() {
                        var returnValue;
                        try {
                            returnValue = func(value);
                        } catch (e) {
                            return promise.reject(e);
                        }
                        if (returnValue === promise) {
                            promise.reject(new TypeError('Cannot resolve promise with itself'));
                        } else {
                            promise.resolve(returnValue);
                        }
                    });
                }
            }, {
                "immediate": 35
            }
        ],
        34: [
            function(_dereq_, module, exports) {
                "use strict";
                exports.test = function() {
                    return false;
                };
            }, {}
        ],
        35: [
            function(_dereq_, module, exports) {
                "use strict";
                var types = [
                    _dereq_("./nextTick"),
                    _dereq_("./mutation"),
                    _dereq_("./postMessage"),
                    _dereq_("./messageChannel"),
                    _dereq_("./stateChange"),
                    _dereq_("./timeout")
                ];
                var handlerQueue = [];

                function drainQueue() {
                    var i = 0,
                        task,
                        innerQueue = handlerQueue;
                    handlerQueue = [];
                    /*jslint boss: true */
                    while (task = innerQueue[i++]) {
                        task();
                    }
                }
                var nextTick;
                var i = -1;
                var len = types.length;
                while (++i < len) {
                    if (types[i].test()) {
                        nextTick = types[i].install(drainQueue);
                        break;
                    }
                }
                module.exports = function(task) {
                    var len, i, args;
                    var nTask = task;
                    if (arguments.length > 1 && typeof task === "function") {
                        args = new Array(arguments.length - 1);
                        i = 0;
                        while (++i < arguments.length) {
                            args[i - 1] = arguments[i];
                        }
                        nTask = function() {
                            task.apply(undefined, args);
                        };
                    }
                    if ((len = handlerQueue.push(nTask)) === 1) {
                        nextTick(drainQueue);
                    }
                    return len;
                };
                module.exports.clear = function(n) {
                    if (n <= handlerQueue.length) {
                        handlerQueue[n - 1] = function() {};
                    }
                    return this;
                };

            }, {
                "./messageChannel": 36,
                "./mutation": 37,
                "./nextTick": 34,
                "./postMessage": 38,
                "./stateChange": 39,
                "./timeout": 40
            }
        ],
        36: [
            function(_dereq_, module, exports) {
                (function(global) {
                    "use strict";

                    exports.test = function() {
                        return typeof global.MessageChannel !== "undefined";
                    };

                    exports.install = function(func) {
                        var channel = new global.MessageChannel();
                        channel.port1.onmessage = func;
                        return function() {
                            channel.port2.postMessage(0);
                        };
                    };
                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {}
        ],
        37: [
            function(_dereq_, module, exports) {
                (function(global) {
                    "use strict";
                    //based off rsvp
                    //https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/async.js

                    var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;

                    exports.test = function() {
                        return MutationObserver;
                    };

                    exports.install = function(handle) {
                        var observer = new MutationObserver(handle);
                        var element = global.document.createElement("div");
                        observer.observe(element, {
                            attributes: true
                        });

                        // Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661
                        global.addEventListener("unload", function() {
                            observer.disconnect();
                            observer = null;
                        }, false);
                        return function() {
                            element.setAttribute("drainQueue", "drainQueue");
                        };
                    };
                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {}
        ],
        38: [
            function(_dereq_, module, exports) {
                (function(global) {
                    "use strict";
                    exports.test = function() {
                        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
                        // where `global.postMessage` means something completely different and can"t be used for this purpose.

                        if (!global.postMessage || global.importScripts) {
                            return false;
                        }

                        var postMessageIsAsynchronous = true;
                        var oldOnMessage = global.onmessage;
                        global.onmessage = function() {
                            postMessageIsAsynchronous = false;
                        };
                        global.postMessage("", "*");
                        global.onmessage = oldOnMessage;

                        return postMessageIsAsynchronous;
                    };

                    exports.install = function(func) {
                        var codeWord = "com.calvinmetcalf.setImmediate" + Math.random();

                        function globalMessage(event) {
                            if (event.source === global && event.data === codeWord) {
                                func();
                            }
                        }
                        if (global.addEventListener) {
                            global.addEventListener("message", globalMessage, false);
                        } else {
                            global.attachEvent("onmessage", globalMessage);
                        }
                        return function() {
                            global.postMessage(codeWord, "*");
                        };
                    };
                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {}
        ],
        39: [
            function(_dereq_, module, exports) {
                (function(global) {
                    "use strict";

                    exports.test = function() {
                        return "document" in global && "onreadystatechange" in global.document.createElement("script");
                    };

                    exports.install = function(handle) {
                        return function() {

                            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                            var scriptEl = global.document.createElement("script");
                            scriptEl.onreadystatechange = function() {
                                handle();

                                scriptEl.onreadystatechange = null;
                                scriptEl.parentNode.removeChild(scriptEl);
                                scriptEl = null;
                            };
                            global.document.documentElement.appendChild(scriptEl);

                            return handle;
                        };
                    };
                }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {}
        ],
        40: [
            function(_dereq_, module, exports) {
                "use strict";
                exports.test = function() {
                    return true;
                };

                exports.install = function(t) {
                    return function() {
                        setTimeout(t, 0);
                    };
                };
            }, {}
        ],
        41: [
            function(_dereq_, module, exports) {
                'use strict';

                module.exports = function(func, emit, sum, log, isArray, toJSON) {
                    /*jshint evil: true */
                    return eval("'use strict'; (" + func + ");");
                };

            }, {}
        ],
        42: [
            function(_dereq_, module, exports) {
                (function(process, global) {
                    'use strict';

                    var pouchCollate = _dereq_('pouchdb-collate');
                    var Promise = typeof global.Promise === 'function' ? global.Promise : _dereq_('lie');
                    var collate = pouchCollate.collate;
                    var evalFunc = _dereq_('./evalfunc');
                    var log = (typeof console !== 'undefined') ?
                        Function.prototype.bind.call(console.log, console) : function() {};
                    var processKey = function(key) {
                        // Stringify keys since we want them as map keys (see #35)
                        return JSON.stringify(pouchCollate.normalizeKey(key));
                    };
                    // This is the first implementation of a basic plugin, we register the
                    // plugin object with pouch and it is mixin'd to each database created
                    // (regardless of adapter), adapters can override plugins by providing
                    // their own implementation. functions on the plugin object that start
                    // with _ are reserved function that are called by pouchdb for special
                    // notifications.

                    // If we wanted to store incremental views we can do it here by listening
                    // to the changes feed (keeping track of our last update_seq between page loads)
                    // and storing the result of the map function (possibly using the upcoming
                    // extracted adapter functions)


                    function createKeysLookup(keys) {
                        // creates a lookup map for the given keys, so that doing
                        // query() with keys doesn't become an O(n * m) operation
                        // lookup values are typically integer indexes, but may
                        // map to a list of integers, since keys can be duplicated
                        var lookup = {};

                        for (var i = 0, len = keys.length; i < len; i++) {
                            var key = processKey(keys[i]);
                            var val = lookup[key];
                            if (typeof val === 'undefined') {
                                lookup[key] = i;
                            } else if (typeof val === 'number') {
                                lookup[key] = [val, i];
                            } else { // array
                                val.push(i);
                            }
                        }

                        return lookup;
                    }

                    function sortByIdAndValue(a, b) {
                        // sort by id, then value
                        var idCompare = collate(a.id, b.id);
                        return idCompare !== 0 ? idCompare : collate(a.value, b.value);
                    }

                    function addAtIndex(idx, result, prelimResults) {
                        var val = prelimResults[idx];
                        if (typeof val === 'undefined') {
                            prelimResults[idx] = result;
                        } else if (!Array.isArray(val)) {
                            // same key for multiple docs, need to preserve document order, so create array
                            prelimResults[idx] = [val, result];
                        } else { // existing array
                            val.push(result);
                        }
                    }

                    function sum(values) {
                        return values.reduce(function(a, b) {
                            return a + b;
                        }, 0);
                    }

                    var builtInReduce = {
                        "_sum": function(keys, values) {
                            return sum(values);
                        },

                        "_count": function(keys, values, rereduce) {
                            return values.length;
                        },

                        "_stats": function(keys, values) {
                            return {
                                'sum': sum(values),
                                'min': Math.min.apply(null, values),
                                'max': Math.max.apply(null, values),
                                'count': values.length,
                                'sumsqr': (function() {
                                    var _sumsqr = 0;
                                    var error;
                                    for (var idx in values) {
                                        if (typeof values[idx] === 'number') {
                                            _sumsqr += values[idx] * values[idx];
                                        } else {
                                            error = new Error('builtin _stats function requires map values to be numbers');
                                            error.name = 'invalid_value';
                                            error.status = 500;
                                            return error;
                                        }
                                    }
                                    return _sumsqr;
                                })()
                            };
                        }
                    };

                    function addHttpParam(paramName, opts, params, asJson) {
                        // add an http param from opts to params, optionally json-encoded
                        var val = opts[paramName];
                        if (typeof val !== 'undefined') {
                            if (asJson) {
                                val = encodeURIComponent(JSON.stringify(val));
                            }
                            params.push(paramName + '=' + val);
                        }
                    }

                    function mapUsingKeys(inputResults, keys, keysLookup) {
                        // create a new results array from the given array,
                        // ensuring that the following conditions are respected:
                        // 1. docs are ordered by key, then doc id
                        // 2. docs can appear >1 time in the list, if their key is specified >1 time
                        // 3. keys can be unknown, in which case there's just a hole in the returned array

                        var prelimResults = new Array(keys.length);

                        inputResults.forEach(function(result) {
                            var idx = keysLookup[processKey(result.key)];
                            if (typeof idx === 'number') {
                                addAtIndex(idx, result, prelimResults);
                            } else { // array of indices
                                idx.forEach(function(subIdx) {
                                    addAtIndex(subIdx, result, prelimResults);
                                });
                            }
                        });

                        // flatten the array, remove nulls, sort by doc ids
                        var outputResults = [];
                        prelimResults.forEach(function(result) {
                            if (Array.isArray(result)) {
                                outputResults = outputResults.concat(result.sort(sortByIdAndValue));
                            } else { // single result
                                outputResults.push(result);
                            }
                        });

                        return outputResults;
                    }

                    function viewQuery(db, fun, options) {
                        var origMap;
                        if (!options.skip) {
                            options.skip = 0;
                        }

                        if (!fun.reduce) {
                            options.reduce = false;
                        }

                        var results = [];
                        var current;
                        var num_started = 0;
                        var completed = false;
                        var keysLookup;

                        function emit(key, val) {
                            var viewRow = {
                                id: current.doc._id,
                                key: key,
                                value: val
                            };

                            if (typeof options.startkey !== 'undefined' && collate(key, options.startkey) < 0) {
                                return;
                            }
                            if (typeof options.endkey !== 'undefined' && collate(key, options.endkey) > 0) {
                                return;
                            }
                            if (typeof options.key !== 'undefined' && collate(key, options.key) !== 0) {
                                return;
                            }
                            if (typeof options.keys !== 'undefined') {
                                keysLookup = keysLookup || createKeysLookup(options.keys);
                                if (typeof keysLookup[processKey(key)] === 'undefined') {
                                    return;
                                }
                            }

                            num_started++;
                            if (options.include_docs) {
                                //in this special case, join on _id (issue #106)
                                if (val && typeof val === 'object' && val._id) {
                                    db.get(val._id,
                                        function(_, joined_doc) {
                                            if (joined_doc) {
                                                viewRow.doc = joined_doc;
                                            }
                                            results.push(viewRow);
                                            checkComplete();
                                        });
                                    return;
                                } else {
                                    viewRow.doc = current.doc;
                                }
                            }
                            results.push(viewRow);
                        }
                        if (typeof fun.map === "function" && fun.map.length === 2) {
                            //save a reference to it
                            origMap = fun.map;
                            fun.map = function(doc) {
                                //call it with the emit as the second argument
                                return origMap(doc, emit);
                            };
                        } else {
                            // ugly way to make sure references to 'emit' in map/reduce bind to the
                            // above emit
                            fun.map = evalFunc(fun.map.toString(), emit, sum, log, Array.isArray, JSON.parse);
                        }
                        if (fun.reduce) {
                            if (builtInReduce[fun.reduce]) {
                                fun.reduce = builtInReduce[fun.reduce];
                            } else {
                                fun.reduce = evalFunc(fun.reduce.toString(), emit, sum, log, Array.isArray, JSON.parse);
                            }
                        }

                        //only proceed once all documents are mapped and joined
                        function checkComplete() {
                            var error;
                            if (completed && results.length === num_started) {

                                if (typeof options.keys !== 'undefined' && results.length) {
                                    // user supplied a keys param, sort by keys
                                    results = mapUsingKeys(results, options.keys, keysLookup);
                                } else { // normal sorting
                                    results.sort(function(a, b) {
                                        // sort by key, then id
                                        var keyCollate = collate(a.key, b.key);
                                        return keyCollate !== 0 ? keyCollate : collate(a.id, b.id);
                                    });
                                }
                                if (options.descending) {
                                    results.reverse();
                                }
                                if (options.reduce === false) {
                                    return options.complete(null, {
                                        total_rows: results.length,
                                        offset: options.skip,
                                        rows: ('limit' in options) ? results.slice(options.skip, options.limit + options.skip) : (options.skip > 0) ? results.slice(options.skip) : results
                                    });
                                }

                                var groups = [];
                                results.forEach(function(e) {
                                    var last = groups[groups.length - 1];
                                    if (last && collate(last.key[0][0], e.key) === 0) {
                                        last.key.push([e.key, e.id]);
                                        last.value.push(e.value);
                                        return;
                                    }
                                    groups.push({
                                        key: [
                                            [e.key, e.id]
                                        ],
                                        value: [e.value]
                                    });
                                });
                                groups.forEach(function(e) {
                                    e.value = fun.reduce.call(null, e.key, e.value);
                                    if (e.value.sumsqr && e.value.sumsqr instanceof Error) {
                                        error = e.value;
                                        return;
                                    }
                                    e.key = e.key[0][0];
                                });
                                if (error) {
                                    options.complete(error);
                                    return;
                                }
                                options.complete(null, {
                                    total_rows: groups.length,
                                    offset: options.skip,
                                    rows: ('limit' in options) ? groups.slice(options.skip, options.limit + options.skip) : (options.skip > 0) ? groups.slice(options.skip) : groups
                                });
                            }
                        }

                        db.changes({
                            conflicts: true,
                            include_docs: true,
                            onChange: function(doc) {
                                if (!('deleted' in doc) && doc.id[0] !== "_") {
                                    current = {
                                        doc: doc.doc
                                    };
                                    fun.map.call(null, doc.doc);
                                }
                            },
                            complete: function() {
                                completed = true;
                                checkComplete();
                            }
                        });
                    }

                    function httpQuery(db, fun, opts) {
                        var callback = opts.complete;

                        // List of parameters to add to the PUT request
                        var params = [];
                        var body;
                        var method = 'GET';

                        // If opts.reduce exists and is defined, then add it to the list
                        // of parameters.
                        // If reduce=false then the results are that of only the map function
                        // not the final result of map and reduce.
                        addHttpParam('reduce', opts, params);
                        addHttpParam('include_docs', opts, params);
                        addHttpParam('limit', opts, params);
                        addHttpParam('descending', opts, params);
                        addHttpParam('group', opts, params);
                        addHttpParam('group_level', opts, params);
                        addHttpParam('skip', opts, params);
                        addHttpParam('startkey', opts, params, true);
                        addHttpParam('endkey', opts, params, true);
                        addHttpParam('key', opts, params, true);

                        // If keys are supplied, issue a POST request to circumvent GET query string limits
                        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
                        if (typeof opts.keys !== 'undefined') {
                            method = 'POST';
                            if (typeof fun === 'string') {
                                body = JSON.stringify({
                                    keys: opts.keys
                                });
                            } else { // fun is {map : mapfun}, so append to this
                                fun.keys = opts.keys;
                            }
                        }

                        // Format the list of parameters into a valid URI query string
                        params = params.join('&');
                        params = params === '' ? '' : '?' + params;

                        // We are referencing a query defined in the design doc
                        if (typeof fun === 'string') {
                            var parts = fun.split('/');
                            db.request({
                                method: method,
                                url: '_design/' + parts[0] + '/_view/' + parts[1] + params,
                                body: body
                            }, callback);
                            return;
                        }

                        // We are using a temporary view, terrible for performance but good for testing
                        var queryObject = JSON.parse(JSON.stringify(fun, function(key, val) {
                            if (typeof val === 'function') {
                                return val + ''; // implicitly `toString` it
                            }
                            return val;
                        }));

                        db.request({
                            method: 'POST',
                            url: '_temp_view' + params,
                            body: queryObject
                        }, callback);
                    }

                    exports.query = function(fun, opts, callback) {
                        var db = this;
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = opts || {};
                        if (callback) {
                            opts.complete = callback;
                        }
                        var tempCB = opts.complete;
                        var realCB;
                        if (opts.complete) {
                            realCB = function(err, resp) {
                                process.nextTick(function() {
                                    tempCB(err, resp);
                                });
                            };
                        }
                        var promise = new Promise(function(resolve, reject) {
                            opts.complete = function(err, data) {
                                if (err) {
                                    reject(err);
                                } else {
                                    resolve(data);
                                }
                            };

                            if (db.type() === 'http') {
                                if (typeof fun === 'function') {
                                    return httpQuery(db, {
                                        map: fun
                                    }, opts);
                                }
                                return httpQuery(db, fun, opts);
                            }

                            if (typeof fun === 'object') {
                                return viewQuery(db, fun, opts);
                            }

                            if (typeof fun === 'function') {
                                return viewQuery(db, {
                                    map: fun
                                }, opts);
                            }

                            var parts = fun.split('/');
                            db.get('_design/' + parts[0], function(err, doc) {
                                if (err) {
                                    opts.complete(err);
                                    return;
                                }

                                if (!doc.views[parts[1]]) {
                                    opts.complete({
                                        name: 'not_found',
                                        message: 'missing_named_view'
                                    });
                                    return;
                                }
                                viewQuery(db, {
                                    map: doc.views[parts[1]].map,
                                    reduce: doc.views[parts[1]].reduce
                                }, opts);
                            });
                        });
                        if (realCB) {
                            promise.then(function(resp) {
                                realCB(null, resp);
                            }, realCB);
                        }
                        return promise;
                    };

                }).call(this, _dereq_("/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {
                "./evalfunc": 41,
                "/Users/cmetcalf/pouchdb/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js": 22,
                "lie": 43,
                "pouchdb-collate": 51
            }
        ],
        43: [
            function(_dereq_, module, exports) {
                'use strict';

                var immediate = _dereq_('immediate');
                var isDefineProp = false;
                // prevents deoptimization
                (function() {
                    try {
                        Object.defineProperty({}, 'test', {
                            value: true
                        });
                        isDefineProp = true;
                    } catch (e) {}
                }());

                function defineNonEnum(obj, name, value) {
                    if (isDefineProp) {
                        Object.defineProperty(obj, name, {
                            value: value,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[name] = value;
                    }
                }

                function Promise(resolver) {

                    if (!(this instanceof Promise)) {
                        return new Promise(resolver);
                    }

                    defineNonEnum(this, 'successQueue', []);
                    defineNonEnum(this, 'failureQueue', []);
                    defineNonEnum(this, 'resolved', false);


                    if (typeof resolver === 'function') {
                        this.resolvePassed(resolver);
                    }
                }
                defineNonEnum(Promise.prototype, 'resolvePassed', function(resolver) {
                    try {
                        resolver(this.fulfillUnwrap.bind(this), this.reject.bind(this));
                    } catch (e) {
                        this.reject(e);
                    }
                });
                defineNonEnum(Promise.prototype, 'reject', function(reason) {
                    this.resolve(false, reason);
                });
                defineNonEnum(Promise.prototype, 'fulfill', function(value) {
                    this.resolve(true, value);
                });
                defineNonEnum(Promise.prototype, 'fulfillUnwrap', function(value) {
                    unwrap(this.fulfill.bind(this), this.reject.bind(this), value);
                });
                Promise.prototype.then = function(onFulfilled, onRejected) {
                    if (this.resolved) {
                        return this.resolved(onFulfilled, onRejected);
                    } else {
                        return this.pending(onFulfilled, onRejected);
                    }
                };
                (function() {
                    try {
                        Promise.prototype['catch'] = function(onRejected) {
                            return this.then(null, onRejected);
                        };
                    } catch (e) {}
                }());
                defineNonEnum(Promise.prototype, 'pending', function(onFulfilled, onRejected) {
                    var self = this;
                    return new Promise(function(success, failure) {
                        if (typeof onFulfilled === 'function') {
                            self.successQueue.push({
                                resolve: success,
                                reject: failure,
                                callback: onFulfilled
                            });
                        } else {
                            self.successQueue.push({
                                next: success,
                                callback: false
                            });
                        }

                        if (typeof onRejected === 'function') {
                            self.failureQueue.push({
                                resolve: success,
                                reject: failure,
                                callback: onRejected
                            });
                        } else {
                            self.failureQueue.push({
                                next: failure,
                                callback: false
                            });
                        }
                    });
                });
                defineNonEnum(Promise.prototype, 'resolve', function(success, value) {

                    if (this.resolved) {
                        return;
                    }

                    this.resolved = createResolved(this, value, success ? 0 : 1);

                    var queue = success ? this.successQueue : this.failureQueue;
                    var len = queue.length;
                    var i = -1;
                    while (++i < len) {

                        if (queue[i].callback) {
                            immediate(execute, queue[i].callback, value, queue[i].resolve, queue[i].reject);
                        } else {
                            queue[i].next(value);
                        }
                    }
                });

                function unwrap(fulfill, reject, value) {
                    if (value && typeof value.then === 'function') {
                        value.then(fulfill, reject);
                    } else {
                        fulfill(value);
                    }
                }

                function createResolved(scope, value, whichArg) {
                    function resolved() {
                        var callback = arguments[whichArg];
                        if (typeof callback !== 'function') {
                            return scope;
                        } else {
                            return new Promise(function(resolve, reject) {
                                immediate(execute, callback, value, resolve, reject);
                            });
                        }
                    }
                    return resolved;
                }

                function execute(callback, value, resolve, reject) {
                    try {
                        unwrap(resolve, reject, callback(value));
                    } catch (error) {
                        reject(error);
                    }
                }



                module.exports = Promise;

            }, {
                "immediate": 45
            }
        ],
        44: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(34)
            }, {}
        ],
        45: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(35)
            }, {
                "./messageChannel": 46,
                "./mutation": 47,
                "./nextTick": 44,
                "./postMessage": 48,
                "./stateChange": 49,
                "./timeout": 50
            }
        ],
        46: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(36)
            }, {}
        ],
        47: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(37)
            }, {}
        ],
        48: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(38)
            }, {}
        ],
        49: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(39)
            }, {}
        ],
        50: [
            function(_dereq_, module, exports) {
                module.exports = _dereq_(40)
            }, {}
        ],
        51: [
            function(_dereq_, module, exports) {
                'use strict';

                exports.collate = function(a, b) {
                    a = exports.normalizeKey(a);
                    b = exports.normalizeKey(b);
                    var ai = collationIndex(a);
                    var bi = collationIndex(b);
                    if ((ai - bi) !== 0) {
                        return ai - bi;
                    }
                    if (a === null) {
                        return 0;
                    }
                    if (typeof a === 'number') {
                        return a - b;
                    }
                    if (typeof a === 'boolean') {
                        return a === b ? 0 : (a < b ? -1 : 1);
                    }
                    if (typeof a === 'string') {
                        return stringCollate(a, b);
                    }
                    if (Array.isArray(a)) {
                        return arrayCollate(a, b);
                    }
                    if (typeof a === 'object') {
                        return objectCollate(a, b);
                    }
                }

                // couch considers null/NaN/Infinity/-Infinity === undefined,
                // for the purposes of mapreduce indexes. also, dates get stringified.
                exports.normalizeKey = function(key) {
                    if (typeof key === 'undefined') {
                        return null;
                    } else if (typeof key === 'number') {
                        if (key === Infinity || key === -Infinity || isNaN(key)) {
                            return null;
                        }
                    } else if (key instanceof Date) {
                        return key.toJSON();
                    }
                    return key;
                }

                function arrayCollate(a, b) {
                    var len = Math.min(a.length, b.length);
                    for (var i = 0; i < len; i++) {
                        var sort = exports.collate(a[i], b[i]);
                        if (sort !== 0) {
                            return sort;
                        }
                    }
                    return (a.length === b.length) ? 0 :
                        (a.length > b.length) ? 1 : -1;
                }

                function stringCollate(a, b) {
                    // See: https://github.com/daleharvey/pouchdb/issues/40
                    // This is incompatible with the CouchDB implementation, but its the
                    // best we can do for now
                    return (a === b) ? 0 : ((a > b) ? 1 : -1);
                }

                function objectCollate(a, b) {
                    var ak = Object.keys(a),
                        bk = Object.keys(b);
                    var len = Math.min(ak.length, bk.length);
                    for (var i = 0; i < len; i++) {
                        // First sort the keys
                        var sort = exports.collate(ak[i], bk[i]);
                        if (sort !== 0) {
                            return sort;
                        }
                        // if the keys are equal sort the values
                        sort = exports.collate(a[ak[i]], b[bk[i]]);
                        if (sort !== 0) {
                            return sort;
                        }

                    }
                    return (ak.length === bk.length) ? 0 :
                        (ak.length > bk.length) ? 1 : -1;
                }
                // The collation is defined by erlangs ordered terms
                // the atoms null, true, false come first, then numbers, strings,
                // arrays, then objects
                // null/undefined/NaN/Infinity/-Infinity are all considered null
                function collationIndex(x) {
                    var id = ['boolean', 'number', 'string', 'object'];
                    if (id.indexOf(typeof x) !== -1) {
                        if (x === null) {
                            return 1;
                        }
                        return id.indexOf(typeof x) + 2;
                    }
                    if (Array.isArray(x)) {
                        return 4.5;
                    }
                }

            }, {}
        ],
        52: [
            function(_dereq_, module, exports) {
                module.exports = {
                    "name": "pouchdb",
                    "version": "2.1.2",
                    "description": "PouchDB is a pocket-sized database.",
                    "release": "nightly",
                    "main": "./lib/index.js",
                    "homepage": "https://github.com/daleharvey/pouchdb",
                    "repository": "https://github.com/daleharvey/pouchdb",
                    "keywords": [
                        "db",
                        "couchdb",
                        "pouchdb"
                    ],
                    "tags": [
                        "db",
                        "couchdb",
                        "pouchdb"
                    ],
                    "dependencies": {
                        "bluebird": "~1.0.0",
                        "inherits": "~2.0.1",
                        "level-js": "~2.0.0",
                        "level-sublevel": "~5.2.0",
                        "leveldown": "~0.10.2",
                        "levelup": "~0.18.2",
                        "lie": "^2.6.0",
                        "pouchdb-mapreduce": "1.0.0",
                        "request": "~2.28.0"
                    },
                    "devDependencies": {
                        "commander": "~2.1.0",
                        "watchify": "~0.4.1",
                        "uglify-js": "~2.4.6",
                        "jshint": "~2.3.0",
                        "http-proxy": "~0.10.3",
                        "corsproxy": "~0.2.13",
                        "http-server": "~0.5.5",
                        "browserify": "~3.24.13",
                        "wd": "~0.2.8",
                        "tin": "~0.4.0",
                        "mocha": "~1.17.1",
                        "chai": "~1.9.0",
                        "istanbul": "~0.2.4",
                        "ncp": "~0.5.0",
                        "sauce-connect-launcher": "0.2.2",
                        "less": "~1.7.0",
                        "bower": "~1.2.8"
                    },
                    "scripts": {
                        "jshint": "jshint -c .jshintrc bin/ lib/ tests/*.js",
                        "build-js": "browserify . -s PouchDB > dist/pouchdb-nightly.js",
                        "min": "uglifyjs dist/pouchdb-nightly.js -mc > dist/pouchdb-nightly.min.js",
                        "build": "mkdir -p dist && npm run build-js && npm run min",
                        "test-node": "./bin/run-mocha.sh",
                        "test-browser": "mkdir -p dist && npm run build-js && ./bin/test-browser.js",
                        "dev": "./bin/dev-server.js",
                        "test": "npm run jshint && ./bin/run-test.sh",
                        "publish": "./bin/publish.sh",
                        "publish-site": "./bin/publish-site.sh",
                        "build-site": "./bin/build-site.sh",
                        "shell": "./bin/repl.js",
                        "report-coverage": "./bin/run-coverage.js"
                    },
                    "browser": {
                        "./deps/buffer": false,
                        "request": false,
                        "level-sublevel": false,
                        "levelup": false,
                        "crypto": false,
                        "./adapters/leveldb": false,
                        "./adapters/levelalt": false,
                        "bluebird": "lie"
                    }
                }
            }, {}
        ]
    }, {}, [13])
    (13)
});
define('libs/pouchInterfaceBaseObject',['pouchDB', ], function(PouchDB) {
    'use strict';


    var PouchInterface = function(options) {
        this.initialize(options);
    };

    if (!window.PouchDB) {
        window.PouchDB = PouchDB;
    }

    //  PouchDB.destroy('websql://wemodevicewidgets');

    _.extend(PouchInterface.prototype, Backbone.Events, {
        initialize: function(options) {
            options = options || {};
            _.extend(this, options);

        },
        remoteDb: 'http://localhost:5984/',
        dbName: '',
        /*
        to: function() {
            this.db.replicate.to(this.remoteDb, {
                onChange: function(resp) {

                },
                complete: function() {

                }
            });
        },
        from: function() {
            var dfd = $.Deferred();

            this.db.replicate.from(this.remoteDb, {
                onChange: function(resp) {

                    if (!resp.ok) {
                        dfd.reject();
                    }
                },
                complete: function(resp) {

                    dfd.resolve();
                }
            });

            return dfd.promise();
        },*/
        createDatabase: function() {
            var dfd = $.Deferred();


            if (!window[this.dbName]) {
                window[this.dbName] = new PouchDB(this.dbName, {}, function(err, result) {

                    if (err) {
                        dfd.reject(err);
                    } else {
                        // self.from().then(function(){
                        dfd.resolve(result);
                        // }).fail(function(){
                        //         dfd.reject();
                        // });
                    }
                });
                this.db = window[this.dbName];
            } else {
                this.db = window[this.dbName];
                dfd.resolve();
            }

            return dfd.promise();
        },
        getAll: function() {
            var self = this;
            var dfd = $.Deferred();
            this.createDatabase().done(function() {
                self.db.allDocs({
                    include_docs: true,
                    attachments: true
                }).then(function(result) {
                    dfd.resolve(result.rows);
                }).catch(function(err) {
                    dfd.reject(err);
                });
            }).fail(function() {
                dfd.reject();
            });
            return dfd.promise();
        },
        get: function(key) {

            var dfd = $.Deferred();
            var self = this;
            key = key || self.key;

            this.createDatabase().done(function() {

                self.db.get(key, {}, function(err, result) {

                    if (err && err.status !== 404) {
                        dfd.reject(err);

                    } else if (err && err.status === 404) {
                        dfd.resolve(err);

                    } else {

                        if (typeof result.value === 'string' && self.translateValue) {
                            result.i18n = self.translateValue(result.value);
                        }

                        dfd.resolve(result);
                    }
                });
            }).fail(function(resp) {
                dfd.reject(resp);
            });


            return dfd.promise();
        },
        set: function(key, incoming) {
            var self = this;

            return this.createDatabase().done(function() {
                var args = Array.prototype.slice.call(arguments);

                if (args.length === 1 && typeof(args[0]) === 'object' && this.key) {
                    key = this.key;
                } else if (args.length === 1 && typeof(args[0]) === 'object' && !this.key) {
                    // {temperature:{value:'F'}}
                    _.each(args[0], function(value, key) {
                        self.set(key, value);
                    });
                } else {
                    key = key || this.key;
                }

                return self.put(key, incoming);

            });
        },
        put: function(key, incoming) {
            var dfd = $.Deferred();
            var self = this;

            var args = Array.prototype.slice.call(arguments);

            if (args.length === 1 && this.key) {
                key = this.key;
                incoming = args[0];
            } else {
                key = key || this.key;
            }

            var data = {
                _id: key,
                timestamp: Date.now()
            };

            _.extend(data, incoming);

            this.createDatabase().done(function() {
                self.get(key).then(function(resp) {
                    if (resp.status !== 404) {
                        delete data._rev;
                        _.extend(resp, data);
                    } else {
                        resp = data;
                    }

                    self.db.put(resp, function(err, response) {
                        if (err) {
                            dfd.reject(err);
                            DEBUG && console.log('SYNC:put error:' + JSON.stringify(err) + JSON.stringify(response));
                        } else {
                            DEBUG && console.log('THIS IS WHAT WE PUT INTO THE DB' + JSON.stringify(data), response);
                            //  self.to();
                            dfd.resolve(response);
                            if (self.emit) {
                                self.emit(key, incoming);
                            }
                        }

                    });

                });
            });


            return dfd.promise();
        },
        remove: function(key, rev) {

            var args = Array.prototype.slice(arguments);

            if (args.length === 1 && this.key) {
                key = this.key;
            } else {
                key = key || this.key;
            }

            var dfd = $.Deferred();
            var self = this;
            this.createDatabase().done(function() {
                self.db.get(key, {}, function(err, result) {
                    DEBUG && console.warn('DB DELETE:' + JSON.stringify(result));
                    if (result) {
                        self.db.remove(result, function(err, resp) {
                            if (err && err.status !== 404) {
                                dfd.reject(err);
                            } else {
                                dfd.resolve(resp);
                            }

                        });
                    } else if (err) {
                        dfd.reject(err);
                    }

                });
            });

            return dfd.promise();
        },
        delete: function() {
            return PouchDB.destroy(this.dbName);
        }
    });




    return PouchInterface;

});
define('extensions/dataInterface', ['feature!dataInterface', 'libs/pouchInterfaceBaseObject'], function(dataInterface, PouchInterface) {

    'use strict';



    return {
        initialize: function(app) {
            app.sandbox.PouchInterface = PouchInterface;
            app.core.dataInterface = dataInterface;
        }
    };
});
define('extensions/globalsettings', ['Cache', 'libs/pouchInterfaceBaseObject'], function(Backbone, PouchInterface) {

    'use strict';

    var aura;
    var globalsettings = new PouchInterface({
        dbName: 'websql://wemoGlobalSettings'
    });

    _.extend(globalsettings, {
        get: function(key) {
            var self = this;

            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {

                    if (resp) {

                        var result = {};

                        if (self.translateValue) {
                            result.i18n = self.translateValue(resp);
                            result.value = resp;
                            result.key = key;
                        }


                        dfd.resolve(result);

                    } else {
                        dfd.reject();
                    }
                }

                if (aura.device.os === 'ios') {
                    cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'getGlobalSettingWithKey', [key]);
                } else {
                    callMeMaybe(window.localStorage.getItem(key));
                }

            }).promise();


            // should be this, but this isn't working right now. Android app settings are in localStorage. 
            // One day we might use this.
            // return PouchInterface.prototype.get.call(this);

        },
        set: function() {

        },
        translateValue: function(value) {
            return aura.core.i18n.t('globalsettings.' + value);
        },
        emit: function(key, resp) {
            aura.sandbox.emit('global.settings', {
                key: key,
                value: resp.value
            });
        },
        checkForChanges: function() {
            var sessionGlobalSettings = window.sessionStorage.getItem('globalsettings');
            if (sessionGlobalSettings) {
                var settings = JSON.parse(sessionGlobalSettings);
                this.set(settings);
                window.sessionStorage.removeItem('globalsettings');
            }
        }
    });


    return {
        initialize: function(app) {
            aura = app;
            app.sandbox.globalsettings = globalsettings;
        }
    };
});
define('features/uiInterface/notIos',[], function() {

    'use strict';


    var spinnerTimeout = setTimeout({}, 0);

    var UiInterface = function() {


    };

    UiInterface.prototype = {


        setShowHideDrawer: function(target) {

            var self = this;
            if (!this.accordion) {
//                if (!window.isSmartCache) {
//                    this.accordion = new this.sandbox.dom.Accordion({
//                        view: this,
//                        el: this.el,
//                        target: target
//                    });
//                    $("#startWidget").addClass("notSmartCache");
//                } else {
                    this.accordion = new this.sandbox.dom.Accordion2({
                        view: this,
                        el: this.el,
                        target: target
                    });

                    this.peekaboo = new this.sandbox.dom.Peekaboo({
                        view: this,
                        el: this.el,
                        target: target
                    });

                    $("#mainContainer").addClass("isSmartCache");
//                }
                this.sandbox.on('drawer.change', function() {
                    self.accordion.calculate();
                });

                this.sandbox.on('global.deviceAdded', function(widget, widgets) {
                    self.accordion.close();
                });

                //close opened drawer when lose network
                this.sandbox.on('global.onNetworkChanged', function(status){
                    if (!status.isNetworkenabled) {
                        self.accordion.close(null, true);
                    }
                });
            }
        },

        getWidgetPath: function(callback) {
            //this is a no-op in browser. code below is only for testing the device API
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {

                    dfd.resolve(resp);
                    if (callback) {
                        callback(resp);
                    }
                }

                setTimeout(function() {
                    callMeMaybe('widgets/wemo_crockpot/tile');
                }, 500);

            }).promise();

        },

        showTile: function() {
            cordova.exec(null, null, 'UIPlugin', 'showTile', []);
        },

        showHideDrawer: function() {
            cordova.exec(null, null, 'UIPlugin', 'showHideDrawer', []);
        },

        createDrawer: function() {
            // no-op for single page
        },
        createSettings: function() {
            // no-op for single page
        },

        /** preloads a webview so that it responds immediately **/
        prepareView: function() {

        },

        showSettings: function(element, options) {
            var self = this;
            var postCallback;

            options = options || {};
            var view = options.view || 'settings';
            options.view = view;

            /** this is to test webview to native or webview to webview **/
            //this.startView means we have loaded the drawer separately.
            /*if (this.sandbox.view) {  //THIS IS ONLY NEEDED FOR iOS NATIVE/HYBRID SUPPORT
                console.log('STARTVIEW', this.startView);
                postCallback = function() {
                    window.parent.cordova.exec(null, null, 'WeMoSMARTUIPlugin', 'showSettings', options);
                }
            } else {*/
            postCallback = function() {
                self.sandbox.emit('changeView', view);
            }
            //}


            DEBUG && console.log('MODIFY BUTTON:notIos.js:adding the button event');



            element.hammer({
                preventDefault: true
            }).off('tap').on("tap", function(event) {

                if (options.callback) {
                    if (options.callbackIsPromise) {
                        if (typeof options.callback === 'string') {
                            self[options.callback](event).then(function() {
                                postCallback();
                            })
                        } else {
                            options.callback(event).then(function() {
                                postCallback();
                            })
                        }

                    } else {
                        if (typeof options.callback === 'string') {
                            self[options.callback](event);
                            postCallback();
                        } else {
                            options.callback(event);
                            postCallback();
                        }

                    }

                } else {
                    postCallback();
                }

            });

        },

        dismissSettings: function(options) {

            /* if (this.sandbox.view) { Don't need this unless iOS stuff.
                window.parent.cordova.exec(null, null, 'WeMoSMARTUIPlugin', 'dismissSettings', options);
            } else {*/
            options = options || {};
            this.close(options);
            //}

        },

        subscribeEditStateChange: function(callback) {
            cordova.exec(callback, null, 'UIPlugin', 'subscribeEditStateChange', []);
        },

        unsubscribeEditStateChange: function() {
            cordova.exec(null, null, 'UIPlugin', 'unsubscribeEditStateChange', []);
        },

        getLocalDeviceInfo: function(callback) {
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {

                    dfd.resolve(resp);
                    if (callback) {
                        callback(resp);
                    }
                }
                if (!$('html').hasClass('web')) {
                    cordova.exec(callMeMaybe, null, 'WeMoSMARTUIPlugin', 'getLocalDeviceInfo', []);
                } else {
                    callMeMaybe({
                        isTablet: "true"
                    });
                }
            }).promise();
        },
        showSpinner: function(options) {
            var self = this;
            var options = options || {};
            if (!options.hideOverlay) {
                $('body').append('<div class="spinnerOverlay"></div>');
            }
            if (!$('html').hasClass('web')) {
                cordova.exec(null, null, 'NativeUtilPlugin', 9001, []);
            }

            spinnerTimeout = setTimeout(function() {
                self.hideSpinner(true);
            }, 15000);

        },
        hideSpinner: function(isTimeout) {
            return $.Deferred(function(dfd) {

                function callMeMaybe(resp) {
                    var $spinnerOverlay = $('.spinnerOverlay');
                    if ($spinnerOverlay.length > 0) {
                        $spinnerOverlay.remove();
                    }
                    if (isTimeout) {
                        dfd.reject('timeout');
                    } else {
                        dfd.resolve(resp);
                    }
                }

                DEBUG && console.log('UIINTERFACE: spinner overlay should be gone');

                if (!$('html').hasClass('web')) {
                    cordova.exec(callMeMaybe, null, 'NativeUtilPlugin', 9002, []);
                } else {
                    callMeMaybe();
                }

                clearTimeout(spinnerTimeout);

            }).promise();
        },
        notifyFrameworkEvent: function(event) {
            window.app.events.emit('frameworkEvent', event);
        },

        subscribeFrameworkEvents: function(view) {
            DEBUG && console.log('No Op')
        },
        unsubscribeFrameworkEvents: function() {
            window.app.events.off('notifyFrameworkEvent');
        }

    };



    return UiInterface;

});

define('extensions/uiInterface',['feature!uiInterface'],function(UiInterface) {

    'use strict';

    /** this is kind of a hack, but the initialize function doesnt run until the app is started, and we need a function from this before the app is officially started
     * the good news is, prototype keeps these memory references SUPER small **/
    if(!window.app) window.app = {};
    window.app.uiInterface = new UiInterface();

    return{
        initialize: function (app) {
            app.sandbox.uiInterface = new UiInterface();
            app.device.uiInterface = new UiInterface();
        }
    };
});
//  Underscore.string
//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
//  Underscore.string is freely distributable under the terms of the MIT license.
//  Documentation: https://github.com/epeli/underscore.string
//  Some code is borrowed from MooTools and Alexandru Marasteanu.
//  Version '2.3.0'

! function(root, String) {
    'use strict';

    // Defining helper functions.

    var nativeTrim = String.prototype.trim;
    var nativeTrimRight = String.prototype.trimRight;
    var nativeTrimLeft = String.prototype.trimLeft;

    var parseNumber = function(source) {
        return source * 1 || 0;
    };

    var strRepeat = function(str, qty) {
        if (qty < 1) return '';
        var result = '';
        while (qty > 0) {
            if (qty & 1) result += str;
            qty >>= 1, str += str;
        }
        return result;
    };

    var slice = [].slice;

    var defaultToWhiteSpace = function(characters) {
        if (characters == null)
            return '\\s';
        else if (characters.source)
            return characters.source;
        else
            return '[' + _s.escapeRegExp(characters) + ']';
    };

    var escapeChars = {
        lt: '<',
        gt: '>',
        quot: '"',
        apos: "'",
        amp: '&'
    };

    var reversedEscapeChars = {};
    for (var key in escapeChars) {
        reversedEscapeChars[escapeChars[key]] = key;
    }

    // sprintf() for JavaScript 0.7-beta1
    // http://www.diveintojavascript.com/projects/javascript-sprintf
    //
    // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
    // All rights reserved.

    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }

        var str_repeat = strRepeat;

        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };

        str_format.format = function(parse_tree, argv) {
            var cursor = 1,
                tree_length = parse_tree.length,
                node_type = '',
                arg, output = [],
                i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                } else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    } else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    } else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }

                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b':
                            arg = arg.toString(2);
                            break;
                        case 'c':
                            arg = String.fromCharCode(arg);
                            break;
                        case 'd':
                            arg = parseInt(arg, 10);
                            break;
                        case 'e':
                            arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                            break;
                        case 'f':
                            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                            break;
                        case 'o':
                            arg = arg.toString(8);
                            break;
                        case 's':
                            arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg);
                            break;
                        case 'u':
                            arg = Math.abs(arg);
                            break;
                        case 'x':
                            arg = arg.toString(16);
                            break;
                        case 'X':
                            arg = arg.toString(16).toUpperCase();
                            break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };

        str_format.cache = {};

        str_format.parse = function(fmt) {
            var _fmt = fmt,
                match = [],
                parse_tree = [],
                arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [],
                            replacement_field = match[2],
                            field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                } else {
                                    throw new Error('[_.sprintf] huh?');
                                }
                            }
                        } else {
                            throw new Error('[_.sprintf] huh?');
                        }
                        match[2] = field_list;
                    } else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                } else {
                    throw new Error('[_.sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };

        return str_format;
    })();



    // Defining underscore.string

    var _s = {

        VERSION: '2.3.0',

        isBlank: function(str) {
            if (str == null) str = '';
            return (/^\s*$/).test(str);
        },

        stripTags: function(str) {
            if (str == null) return '';
            return String(str).replace(/<\/?[^>]+>/g, '');
        },

        capitalize: function(str) {
            str = str == null ? '' : String(str);
            return str.charAt(0).toUpperCase() + str.slice(1);
        },

        chop: function(str, step) {
            if (str == null) return [];
            str = String(str);
            step = ~~step;
            return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
        },

        clean: function(str) {
            return _s.strip(str).replace(/\s+/g, ' ');
        },

        count: function(str, substr) {
            if (str == null || substr == null) return 0;
            return String(str).split(substr).length - 1;
        },

        chars: function(str) {
            if (str == null) return [];
            return String(str).split('');
        },

        swapCase: function(str) {
            if (str == null) return '';
            return String(str).replace(/\S/g, function(c) {
                return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
            });
        },

        escapeHTML: function(str) {
            if (str == null) return '';
            return String(str).replace(/[&<>"']/g, function(m) {
                return '&' + reversedEscapeChars[m] + ';';
            });
        },

        unescapeHTML: function(str) {
            if (str == null) return '';
            return String(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
                var match;

                if (entityCode in escapeChars) {
                    return escapeChars[entityCode];
                } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
                    return String.fromCharCode(parseInt(match[1], 16));
                } else if (match = entityCode.match(/^#(\d+)$/)) {
                    return String.fromCharCode(~~match[1]);
                } else {
                    return entity;
                }
            });
        },

        escapeRegExp: function(str) {
            if (str == null) return '';
            return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
        },

        splice: function(str, i, howmany, substr) {
            var arr = _s.chars(str);
            arr.splice(~~i, ~~howmany, substr);
            return arr.join('');
        },

        insert: function(str, i, substr) {
            return _s.splice(str, i, 0, substr);
        },

        include: function(str, needle) {
            if (needle === '') return true;
            if (str == null) return false;
            return String(str).indexOf(needle) !== -1;
        },

        join: function() {
            var args = slice.call(arguments),
                separator = args.shift();

            if (separator == null) separator = '';

            return args.join(separator);
        },

        lines: function(str) {
            if (str == null) return [];
            return String(str).split("\n");
        },

        reverse: function(str) {
            return _s.chars(str).reverse().join('');
        },

        startsWith: function(str, starts) {
            if (starts === '') return true;
            if (str == null || starts == null) return false;
            str = String(str);
            starts = String(starts);
            return str.length >= starts.length && str.slice(0, starts.length) === starts;
        },

        endsWith: function(str, ends) {
            if (ends === '') return true;
            if (str == null || ends == null) return false;
            str = String(str);
            ends = String(ends);
            return str.length >= ends.length && str.slice(str.length - ends.length) === ends;
        },

        succ: function(str) {
            if (str == null) return '';
            str = String(str);
            return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length - 1) + 1);
        },

        titleize: function(str) {
            if (str == null) return '';
            return String(str).replace(/(?:^|\s)\S/g, function(c) {
                return c.toUpperCase();
            });
        },

        camelize: function(str) {
            return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
                return c.toUpperCase();
            });
        },

        underscored: function(str) {
            return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
        },

        dasherize: function(str) {
            return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
        },

        classify: function(str) {
            return _s.titleize(String(str).replace(/_/g, ' ')).replace(/\s/g, '');
        },

        humanize: function(str) {
            return _s.capitalize(_s.underscored(str).replace(/_id$/, '').replace(/_/g, ' '));
        },

        trim: function(str, characters) {
            if (str == null) return '';
            if (!characters && nativeTrim) return nativeTrim.call(str);
            characters = defaultToWhiteSpace(characters);
            return String(str).replace(new RegExp('\^' + characters + '+|' + characters + '+$', 'g'), '');
        },

        ltrim: function(str, characters) {
            if (str == null) return '';
            if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
            characters = defaultToWhiteSpace(characters);
            return String(str).replace(new RegExp('^' + characters + '+'), '');
        },

        rtrim: function(str, characters) {
            if (str == null) return '';
            if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
            characters = defaultToWhiteSpace(characters);
            return String(str).replace(new RegExp(characters + '+$'), '');
        },

        truncate: function(str, length, truncateStr) {
            if (str == null) return '';
            str = String(str);
            truncateStr = truncateStr || '...';
            length = ~~length;
            return str.length > length ? str.slice(0, length) + truncateStr : str;
        },

        /**
         * _s.prune: a more elegant version of truncate
         * prune extra chars, never leaving a half-chopped word.
         * @author github.com/rwz
         */
        prune: function(str, length, pruneStr) {
            if (str == null) return '';

            str = String(str);
            length = ~~length;
            pruneStr = pruneStr != null ? String(pruneStr) : '...';

            if (str.length <= length) return str;

            var tmpl = function(c) {
                return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';
            },
                template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

            if (template.slice(template.length - 2).match(/\w\w/))
                template = template.replace(/\s*\S+$/, '');
            else
                template = _s.rtrim(template.slice(0, template.length - 1));

            return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
        },

        words: function(str, delimiter) {
            if (_s.isBlank(str)) return [];
            return _s.trim(str, delimiter).split(delimiter || /\s+/);
        },

        pad: function(str, length, padStr, type) {
            str = str == null ? '' : String(str);
            length = ~~length;

            var padlen = 0;

            if (!padStr)
                padStr = ' ';
            else if (padStr.length > 1)
                padStr = padStr.charAt(0);

            switch (type) {
                case 'right':
                    padlen = length - str.length;
                    return str + strRepeat(padStr, padlen);
                case 'both':
                    padlen = length - str.length;
                    return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
                default: // 'left'
                    padlen = length - str.length;
                    return strRepeat(padStr, padlen) + str;
            }
        },

        lpad: function(str, length, padStr) {
            return _s.pad(str, length, padStr);
        },

        rpad: function(str, length, padStr) {
            return _s.pad(str, length, padStr, 'right');
        },

        lrpad: function(str, length, padStr) {
            return _s.pad(str, length, padStr, 'both');
        },

        sprintf: sprintf,

        vsprintf: function(fmt, argv) {
            argv.unshift(fmt);
            return sprintf.apply(null, argv);
        },

        toNumber: function(str, decimals) {
            if (str == null || str == '') return 0;
            str = String(str);
            var num = parseNumber(parseNumber(str).toFixed(~~decimals));
            return num === 0 && !str.match(/^0+$/) ? Number.NaN : num;
        },

        numberFormat: function(number, dec, dsep, tsep) {
            if (isNaN(number) || number == null) return '';

            number = number.toFixed(~~dec);
            tsep = tsep || ',';

            var parts = number.split('.'),
                fnums = parts[0],
                decimals = parts[1] ? (dsep || '.') + parts[1] : '';

            return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
        },

        strRight: function(str, sep) {
            if (str == null) return '';
            str = String(str);
            sep = sep != null ? String(sep) : sep;
            var pos = !sep ? -1 : str.indexOf(sep);
            return~ pos ? str.slice(pos + sep.length, str.length) : str;
        },

        strRightBack: function(str, sep) {
            if (str == null) return '';
            str = String(str);
            sep = sep != null ? String(sep) : sep;
            var pos = !sep ? -1 : str.lastIndexOf(sep);
            return~ pos ? str.slice(pos + sep.length, str.length) : str;
        },

        strLeft: function(str, sep) {
            if (str == null) return '';
            str = String(str);
            sep = sep != null ? String(sep) : sep;
            var pos = !sep ? -1 : str.indexOf(sep);
            return~ pos ? str.slice(0, pos) : str;
        },

        strLeftBack: function(str, sep) {
            if (str == null) return '';
            str += '';
            sep = sep != null ? '' + sep : sep;
            var pos = str.lastIndexOf(sep);
            return~ pos ? str.slice(0, pos) : str;
        },

        toSentence: function(array, separator, lastSeparator, serial) {
            separator = separator || ', '
            lastSeparator = lastSeparator || ' and '
            var a = array.slice(),
                lastMember = a.pop();

            if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;

            return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
        },

        toSentenceSerial: function() {
            var args = slice.call(arguments);
            args[3] = true;
            return _s.toSentence.apply(_s, args);
        },

        slugify: function(str) {
            if (str == null) return '';

            var from = "Ä…Ã Ã¡Ã¤Ã¢Ã£Ã¥Ã¦Ä‡Ä™Ã¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®Å‚Å„Ã²Ã³Ã¶Ã´ÃµÃ¸Ã¹ÃºÃ¼Ã»Ã±Ã§Å¼Åº",
                to = "aaaaaaaaceeeeeiiiilnoooooouuuunczz",
                regex = new RegExp(defaultToWhiteSpace(from), 'g');

            str = String(str).toLowerCase().replace(regex, function(c) {
                var index = from.indexOf(c);
                return to.charAt(index) || '-';
            });

            return _s.dasherize(str.replace(/[^\w\s-]/g, ''));
        },

        surround: function(str, wrapper) {
            return [wrapper, str, wrapper].join('');
        },

        quote: function(str) {
            return _s.surround(str, '"');
        },

        exports: function() {
            var result = {};

            for (var prop in this) {
                if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;
                result[prop] = this[prop];
            }

            return result;
        },

        repeat: function(str, qty, separator) {
            if (str == null) return '';

            qty = ~~qty;

            // using faster implementation if separator is not needed;
            if (separator == null) return strRepeat(String(str), qty);

            // this one is about 300x slower in Google Chrome
            for (var repeat = []; qty > 0; repeat[--qty] = str) {}
            return repeat.join(separator);
        },

        levenshtein: function(str1, str2) {
            if (str1 == null && str2 == null) return 0;
            if (str1 == null) return String(str2).length;
            if (str2 == null) return String(str1).length;

            str1 = String(str1);
            str2 = String(str2);

            var current = [],
                prev, value;

            for (var i = 0; i <= str2.length; i++)
                for (var j = 0; j <= str1.length; j++) {
                    if (i && j)
                        if (str1.charAt(j - 1) === str2.charAt(i - 1))
                            value = prev;
                        else
                            value = Math.min(current[j], current[j - 1], prev) + 1;
                        else
                            value = i + j;

                    prev = current[j];
                    current[j] = value;
                }

            return current.pop();
        }
    };

    // Aliases

    _s.strip = _s.trim;
    _s.lstrip = _s.ltrim;
    _s.rstrip = _s.rtrim;
    _s.center = _s.lrpad;
    _s.rjust = _s.lpad;
    _s.ljust = _s.rpad;
    _s.contains = _s.include;
    _s.q = _s.quote;


    /** michael forbes - belkin - using require, but i want to just attach it to the root **/
    // CommonJS module is defined
    /*   if (typeof exports !== 'undefined' || define.amd) {
        if (typeof module !== 'undefined' && module.exports) {

            // Export module
            module.exports = _s;
        }
        exports._s = _s;

    } else if (typeof define === 'function' && define.amd) {

        // Register as a named module with AMD.
        define('underscore.string', [], function() {
            return _s;
        });

    } else {*/
    // Integrate with Underscore.js if defined
    // or create our own underscore object.

    root._ = root._ || {};
    root._.string = root._.str = _s;

    // }

}(this, String);
define("plugins/underscore.string", function(){});

define('libs/rulesEngine/parse',['require','exports','module','plugins/xml2json','plugins/underscore.string'],function (require, exports, module) {
    var Xml = require('plugins/xml2json');
    require('plugins/underscore.string'); //adds _.str to underscore

    _.mixin(_.str.exports());

    var x = new Xml();

    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
    filterInt = function (value) {
        if (/^(\-|\+)?([0-9]+|Infinity)$/.test(value))
            return Number(value);
        return NaN;
    }

    var Parse = function () {

    };


    function parseNotifications(param, notifications) {

        notifications.forEach(function (value, index) {
            var notification = {};
            var notify = value.split(',');
            if (_.str.include(notify[0], 'BOTH')) {
                notification.platform = 'BOTH';
            } else if (_.str.include(notify[0], 'ANDROID')) {
                notification.platform = 'ANDROID';
            } else {
                notification.platform = 'IOS';
            }

            notification.message = _.trim(notify[1].replace(/'/gi, '').replace(/\)/gi, ''));
            notification.replacements = [];
            for (var i = 2; i < notify.length; i++) {
                if (notify[i].match(/attribute/)) {
                    notify[i] = notify[i].replace(/attribute\./, '');
                }
                notification.replacements.push(_.trim(notify[i].replace(/\)/gi, '')));
            }
            if (!param.notifications) param.notifications = [];
            param.notifications.push(notification);
        });
    }

    function parseAttributes(param, attributes) {

        attributes.forEach(function (action, index) {
            var split;
            if (action !== '') {
                var attr = action.split('.')[1]; //cut out attribute.
                if (attr.match(/==/)) {
                    split = attr.split('==');
                    param[_.trim(split[0])] = _.trim(split[1].replace(/'/gi, ''));
                } else if (attr.match(/~=/)) {
                    split = attr.split('~=');
                    param[_.trim(split[0])] = '!' + _.trim(split[1].replace(/'/gi, ''));
                } else if (attr.match(/=/)) {
                    split = attr.split('=');
                    param[_.trim(split[0])] = _.trim(split[1].replace(/'/gi, ''));
                }
            }
        });

    }

    function parseConditions(attributes) {
        var attrArray = [];
        attributes.forEach(function (action, index) {
            var attrObj = {},
                base;
            var split;
            if (action !== '') {
                base = action.split('.'); //cut out attribute and qualifier
                var attr = base[1];
                if(attr) {
                    if (attr.match(/==/)) {
                        split = attr.split('==');
                        attrObj.key = _.trim(split[0]);
                        attrObj.value = _.trim(split[1].replace(/'/gi, ''));
                    } else if (attr.match(/~=/)) {
                        split = attr.split('~=');
                        attrObj.key = _.trim(split[0]);
                        attrObj.value = '!' + _.trim(split[1].replace(/'/gi, ''));
                    } else if (attr.match(/=/)) {
                        split = attr.split('=');
                        attrObj.key = _.trim(split[0]);
                        attrObj.value = _.trim(split[1].replace(/'/gi, ''));
                    }

                    //add qualifier if exists
                    if (base[0].match(/or\s/)) {
                        attrObj.logic = 'or';
                    }

                    if (base[0].match(/and\s/)) {
                        attrObj.logic = 'and';
                    }
                } else {
                    base = action.replace(/(\()|(\))/g, '').split(',');
                    attrObj.key = _.trim(base[0].replace(/'/gi, ''));
                    attrObj.value = _.trim(base[1].replace(/'/gi, ''));
                    attrObj.method = "attribute_changes_to";
                }
            }
            attrArray.push(attrObj);
        });

        return attrArray;
    }


    Parse.prototype = {
        constructor: Parse,
        toJSON: function (resp) {
            var self = this;
            var key;
            var jsonResp = [];
            var c = 0;
            var obj = x.xml_str2json(resp);

            //this is XML
            if (typeof resp === 'string') {

                if (obj.ruleList && obj.ruleList.rules) {
                    obj.rules = obj.ruleList.rules;
                    delete obj.ruleList;
                }

                //check for remote object
                if (obj.plugins && obj.plugins.plugin.rules) {
                    obj.rules = obj.plugins.plugin.rules;
                    delete obj.plugins;
                }

                if (obj.ruleList && obj.ruleList.errorCode) { //receive an error with the call or an empty list
                    return jsonResp;
                }

                if (obj.rule) {
                    key = obj;
                } else if (!obj.rules) {
                    return jsonResp;
                } else if (obj.rules.rule && obj.rules.rule.length > 1) {
                    key = obj.rules.rule;
                } else if (obj.rules) { //is an object when there is only one rule
                    key = obj.rules;
                } else {
                    return jsonResp;
                }


                _.forEach(key, function (rule, index) {

                    if (typeof(rule) === 'object') {

                        if (rule.enabled === 0) {
                            rule.enabled = 'true';
                        } else if (rule.enabled === 1) {
                            rule.enabled = 'false';
                        }

                        var params = rule.parameters;
                        if (params) {
                            if (params['__text']) {
                                delete params['__text'];
                            }

                            if (params['action-start']) {
                                self.incoming(params['action-start']);
                            }

                            if (params['action-done']) {
                                self.incoming(params['action-done']);
                            }

                            if (params['action-fail']) {
                                self.incoming(params['action-fail']);
                            }

                            /* if (params.condition) {
                             var tempCondition = {};

                             if (!_.isUndefined(params.condition[0])) {
                             params.condition.forEach(function(condition) {
                             self.incoming(condition);
                             });
                             params.condition.forEach(function(condition, index) {
                             _.each(condition, function(value, key) {
                             tempCondition[key] = value;
                             });
                             });
                             } else {
                             self.incoming(params.condition);
                             _.each(params.condition, function(value, key) {
                             tempCondition[key] = value;
                             });
                             }


                             params.condition = tempCondition;
                             delete params.condition.notifications;
                             }*/

                            if (params['conditions']) {
                                var tempCondition = [];
                                if (!_.isArray(params.conditions.condition)) {
                                    tempCondition.push(self.incoming(params.conditions.condition, 'conditions'));
                                    params.conditions.condition = tempCondition;
                                } else {
                                    params.conditions.condition.forEach(function (condition, index) {
                                        tempCondition.push(self.incoming(condition, 'conditions'));
                                    });

                                    params.conditions.condition = tempCondition;

                                }
                                console.error('CONDITIONS', params['conditions']);
                                delete params['conditions'].toString;
                                delete params['conditions'].__text;
                            }

                            if (params['when-days']) {
                                params['when-days'] = params['when-days'].split(',');
                            }
                            delete params.toString;
                        }

                        if (rule._xmlns) delete rule._xmlns;

                        delete rule.toString; //added by the parser, we don't need it now.
                        if (rule.__text) { //might be added by the parser. not needed.
                            delete rule.__text;
                        }


                        jsonResp.push(rule);
                    }
                });

                return jsonResp;


            } else return resp;
        },
        toXML: function (resp) {
            var self = this;
            var key;
            var jsonResp = [];
            var c = 0;
            var rules = [];
            var ruleStr = '';
            resp.forEach(function (rule) {
                rules.push({
                    'rule': rule
                });
            });

            rules.forEach(function (rule) {

                var params = rule.rule.parameters;

                if (params['when-days']) {
                    params['when-days'] = params['when-days'].join(',');
                }

                if (params.conditions) {
                    params.conditions = self.outgoing(params.conditions, 'condition');
                    console.log('CONDITIONS', params.conditions)
                }

                if (params['action-start']) {
                    self.outgoing(params['action-start'], 'action-start');
                }

                if (params['action-done']) {
                    self.outgoing(params['action-done'], 'action-done');
                }

                if (params['action-fail']) {
                    self.outgoing(params['action-fail'], 'action-fail');
                }


                var obj = x.json2xml_str(rule);
                ruleStr += obj;

            });


            return ruleStr;

            // console.log(rules)

            //  var obj = x.json2xml(resp);

            // console.log(resp);
        },
        incoming: function (param, field) {
            var cdata = _.trim(param.__cdata);

            var method = cdata.match(/attribute_changes_to/g),
                attributes,
                notAttributes;

            if(method) {
                attributes = cdata.match(/\(([\S\s]+)\)/g);
            } else {
                attributes = cdata.match(/(or\s|and\s)*attribute\.[a-zA-Z]+(=|==|~=)\'*[a-zA-Z0-9]+\'*/g);
                notAttributes = cdata.replace(/(or\s|and\s)*attribute\.[a-zA-Z]+(=|==|~=)\'*[a-zA-Z0-9]+\'*/g, '~');

                notAttributes = notAttributes.split('~');
                notAttributes = _.filter(notAttributes, function (value) {
                    return _.trim(value) != '';
                });
            }



            if (attributes) {
                if (field === 'conditions') {
                    param = parseConditions(attributes);
                } else {
                    parseAttributes(param, attributes);
                }

            }
            if (notAttributes) {
                parseNotifications(param, notAttributes);
            }


            if (param.toString) {
                delete param.toString;
            }
            if (param.__text) {
                delete param.__text;
            }
            if (param.__cdata) {
                delete param.__cdata;
            }

            return param;
        },
        outgoing: function (param, field) {
            var cdata = '';
            if (field === 'condition') {
                cdata = [];

                if (_.isArray(param.condition)) {
                    param.condition.forEach(function (condition, index) {
                        var conditionObj = {};
                        var cdata = '';
                        condition.forEach(function (string, i) {
                            var changeValue = '';

                            if (string.method === "attribute_changes_to") {
                                cdata += string.method + "('" + string.key + "', ";

                                if (string.value === true || string.value === 'true') {
                                    changeValue = true;
                                } else if (string.value === 'false' || string.value === false) {
                                    changeValue = false;

                                } else if (isNaN(filterInt(string.value))) {
                                    changeValue = "'" + string.value + "'";
                                } else {
                                    changeValue = filterInt(string.value);
                                }

                                cdata += changeValue + ")";

                            } else {
                                if (string.logic) {
                                    cdata += ' ' + string.logic + ' ';
                                }

                                cdata += 'attribute.' + string.key;
                                if (string.value.match(/!/)) {
                                    cdata += '~='
                                } else {
                                    cdata += '=='
                                }

                                if (string.value === true || string.value === 'true') {
                                    changeValue = true;
                                } else if (string.value === 'false' || string.value === false) {
                                    changeValue = false;

                                } else if (isNaN(filterInt(string.value))) {
                                    changeValue = "'" + string.value + "'";
                                } else {
                                    changeValue = filterInt(string.value);
                                }

                                cdata += changeValue;
                            }


                        });
                        conditionObj.__cdata = cdata;
                        param.condition[index] = conditionObj;
                    });
                }
                return param;

            } else {

                _.each(param, function (value, key) {
                    //this is an attribute
                    if (!_.isArray(value)) {
                        var qualifier;
                        var changeValue;
                        var attr;
                        if (field === 'action-start' || field === 'action-done' ||
                            field === 'action-fail') {
                            qualifier = '=';
                        } else if (value.match(/\!/)) {
                            qualifier = '~=';
                            value = value.replace(/\!/, '');
                        } else {
                            qualifier = '==';
                        }

                        if (value === true || value === 'true') {
                            changeValue = true;
                        } else if (value === 'false' || value === false) {
                            changeValue = false;

                        } else if (isNaN(filterInt(value))) {
                            changeValue = "'" + value + "'";
                        } else {
                            changeValue = filterInt(value);
                        }

                        attr = 'attribute.' + key + qualifier + changeValue;

                        if (field !== 'condition') {
                            cdata += attr + ' ';
                        } else {
                            cdata.push({
                                __cdata: attr
                            });
                        }

                        delete param[key];

                    } else {
                        value.forEach(function (notification) {
                            cdata += 'notify(' + notification.platform + ",'" + notification.message + "'";
                            if (notification.replacements.length > 0) {
                                notification.replacements.forEach(function (replacement) {
                                    cdata += ',attribute.' + replacement;
                                });
                            }
                        });

                        cdata += ') ';

                        delete param.notifications;

                    }
                });


                param.__cdata = cdata;

            }
        }
    }


    module.exports = Parse;
});
define('libs/rulesEngine/model',['require','exports','module','Cache','plugins/xml2json','./parse'],function(require, exports, module) {
    var Backbone = require('Cache');
    var xml = require('plugins/xml2json');
    // var PouchInterface = require('libs/pouchInterfaceBaseObject');
    var Parse = require('./parse');

    var parse = new Parse();


    var Model = Backbone.DeepModel.extend({
        rulesService: 'urn:Belkin:service:rules:1',
        initialize: function(options) {
            options = options || {};
            _.extend(this, options);

            if (!this.get('min_version') && !this.get('max_version')) {
                //setup defaults here
                this.set({
                    'min_version': '1',
                    'max_version': '2'
                });
            }

        },
        /**
         * override default backbone collection sync
         * @param  {string} method  [type of sync, always read]
         * @param  {obj} model   [Backbone.model]
         * @param  {obj} options [object literal options]
         * @return {promise}         [resolves on success]
         */
        sync: function(method, model, options) {

            var self = this;
            var dfd = new $.Deferred();


            // Make the request, allowing the user to override any Ajax options.
            function callMeMaybe(resp) {

                if (resp !== 'ERROR') {
                    options.success(resp);
                    dfd.resolve(resp, model, options);
                    self.trigger('request', model, resp, options);
                    if (self.sandbox.device.os !== 'web') {
                        cordova.exec(null, null, 'WeMoSMARTDevicePlugin', 'syncRulesToNative', [self.sandbox.model.baseObject.information.udn, model.toJSON(), '']);
                    }
                } else {
                    dfd.reject(resp);
                }
            }

            var xml = '<rules  action="GetRules" ><rule><id>' + model.get('id') + '</id></rule></rules>';
            console.log('rules model -- sync');

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'GetRules', {
                    data: {
                        ruleList: xml
                    },
                    macAddress: this.sandbox.model.baseObject.information.mac
                }, 'xml']);
            } else {

                //browser
                $.ajax('scripts/libs/rulesEngine/mocks/rules.xml', {
                    dataType: 'text',
                    success: callMeMaybe,
                    error: callMeMaybe,
                    type: 'GET'
                });
            }

            return dfd.promise();
        },
        save: function(model, options) {
            var self = this;
            var dfd = new $.Deferred();

            var xml = parse.toXML(this.toJSON());

            xml = '<rules action="SetRules">' + xml + '</rules>';

            function callMeMaybe(resp) {

                if (resp !== 'ERROR') {
                    dfd.resolve();
                    if (self.sandbox.device.os !== 'web') {
                        cordova.exec(null, null, 'WeMoSMARTDevicePlugin', 'syncRulesToNative', [self.sandbox.model.baseObject.information.udn, self.toJSON(), 'syncToWebview']);
                    }
                } else {
                    dfd.reject(resp);
                }
            }

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'SetRules', {
                    data: {
                        ruleList: xml
                    },
                    macAddress: this.sandbox.model.baseObject.information.mac
                }, 'xml']);
            } else {
                console.error(xml);
                //browser
                $.ajax('scripts/libs/rulesEngine/mocks/rules.xml', {
                    dataType: 'text',
                    data: xml,
                    success: callMeMaybe,
                    error: callMeMaybe,
                    type: 'POST'
                });
            }
            return dfd.promise();
        },
        delete: function() {
            var self = this;
            var dfd = new $.Deferred();
            var id = model.get('id');
            var xml = '<rules action="SetRules" ></rules><rule><id>' + id + '</id></rule></rules>';

            function callMeMaybe(resp) {

                if (resp !== 'ERROR') {
                    dfd.resolve();

                } else {
                    dfd.reject(resp);
                }
            }

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'SetRules', {
                    data: {
                        ruleList: xml
                    },
                    macAddress: this.sandbox.model.baseObject.information.mac
                }, 'xml']);
            } else {
                console.error(xml);
                //browser
                $.ajax('scripts/libs/rulesEngine/mocks/rules.xml', {
                    dataType: 'text',
                    data: xml,
                    success: callMeMaybe,
                    error: callMeMaybe,
                    type: 'POST'
                });
            }
            return dfd.promise();
        },
        /**
         * convert from xml to JSON that can be modeled.
         * @param  {JSON} resp [data in xml format]
         * @return {JSON} jsonResp
         */
        parse: function(resp) {
            return parse.toJSON(resp);
        }
    });


    module.exports = Model;
});

define('libs/rulesEngine/collection',['require','exports','module','Cache','./model','./parse'],function(require, exports, module) {
    var Backbone = require('Cache');
    var Model = require('./model');
    var Parse = require('./parse');

    var parse = new Parse();


    var Collection = Backbone.Collection.extend({
        model: Model,
        rulesService: 'urn:Belkin:service:rules:1',
        syncTimeoutLocal: 7000,
        syncTimeoutRemote: 12000,
        initialize: function(options) {
            options = options || {};
            _.extend(this, options);
        },
        /**
         * override default backbone collection sync
         * @param  {string} method  [type of sync, always read]
         * @param  {obj} model   [Backbone.model]
         * @param  {obj} options [object literal options]
         * @return {promise}         [resolves on success]
         */
        sync: function(method, model, options) {

            var self = this;
            var dfd = new $.Deferred();

            this.sandbox.emit('rules.getRules');
            // Make the request, allowing the user to override any Ajax options.
            function callMeMaybe(resp) {
                //  DEBUG && console.log('RULES:COLLECTION:RESPONSE:' + resp)
                if (typeof resp === 'string' && resp !== 'ERROR' && !resp.match(/java\.lang/)) {
                    self.reset();
                    options.success(resp);
                    self.isSyncing = false;
                    dfd.resolve(resp, model, options);
                    self.trigger('request', model, resp, options);

                    if (self.sandbox.device.os !== 'web') {
                        cordova.exec(null, null, 'WeMoSMARTDevicePlugin', 'syncRulesToNative', [self.sandbox.model.baseObject.information.udn, self.toJSON(), '']);
                    }

                } else {
                    self.isSyncing = false;
                    dfd.reject(resp);
                }

                self.sandbox.emit('rules.getRulesComplete', resp);
            }

            var xml = '<rules action="GetRules" xmlns="http://www.belkin.com/2014/wemo/rulestng"></rules>';
            console.log('collection -- sync');
            if (!this.isSyncing) {
                this.isSyncing = true;
                if (this.sandbox.device.os !== 'web') {
                    cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'GetRules', {
                        data: {
                            ruleList: xml
                        },
                        macAddress: this.sandbox.model.baseObject.information.mac
                    }, 'xml']);
                    var maxTime = (!this.sandbox.model.isRemoteEnabled) ? this.syncTimeoutLocal : this.syncTimeoutRemote;
                    setTimeout(function() {
                        if (self.isSyncing) {
                            self.trigger('getRulesTimeout');
                        }
                    },maxTime);
                } else {

                    //browser
                    $.ajax('scripts/libs/rulesEngine/mocks/rules.xml', {
                        dataType: 'text',
                        success: callMeMaybe,
                        error: callMeMaybe,
                        type: 'GET'
                    });
                }
            }


            return dfd.promise();
        },
        save: function(models, options) {
            var self = this;
            var saveRules = [];
            var deleteRule = false;
            var dfd = new $.Deferred();
            var collectionModels = this.models.slice(0);
            var xml = '';
            console.log('model: -- ' + JSON.stringify(this.toJSON()));

            //Check if a rule has changed
            _.each(collectionModels, function(model) {
                if (model.hasChanged()) {
                    saveRules.push(model.toJSON());
                    model.changed = [];
                }
            });

            xml = parse.toXML(saveRules);

            //Check if a previously saved rule was removed. If yes, remove it from the collection and add the rule id to
            //the payload and remove it from the device.
            if (models) {
                _.each(collectionModels, function(collectionModel) {
                    var found = false;
                    _.each(models, function(model) {
                        if (model.id === collectionModel.get('id')) {
                            found = true;
                            return;
                        }
                    });
                    if (!found) {
                        xml += '<rule><id>' + collectionModel.get('id') + '</id></rule>';
                        self.remove(collectionModel);
                        deleteRule = true;
                    }
                });
            }


            xml = '<rules action="SetRules">' + xml + '</rules>';
            this.sandbox.emit('rules.setRules');

            function callMeMaybe(resp) {
                console.log('RULES:collection:save:' + resp);
                if (typeof resp === 'string' && !resp.match(/java\.lang/)) {
                    /** sample error response: <errorCode>0</errorCode><errorString>Number of Rules to process: 1 Storing/Deletion of Rule ID heat Successful!</errorString>  */
                    /** REMOTE: sample error response: <?xml version="1.0" encoding="UTF-8" standalone="yes"?><plugins><plugin><recipientId>951427</recipientId><macAddress>B4750E764288</macAddress><status>0</status><statusTS>1407360361</statusTS><friendlyName>Holmes® Humidifiernew</friendlyName><modelCode>Humidifier</modelCode><firmwareVersion>WeMo_WW_2.00.6320.DVT</firmwareVersion><signalStrength>100</signalStrength><fwUpgradeStatus>4</fwUpgradeStatus><errorCode>0</errorCode><errorString>Number of Rules to process: 1Storing/Deletion of Rule ID humi-0 Successful!</errorString></plugin></plugins>"  */
                    var respXML= resp.indexOf("<?xml") != -1 ? resp : '<xml>'+resp.trim()+"</xml>";
                    if ($($.parseXML(respXML)).find("errorCode").text() !== '0' ) {
                        dfd.reject(resp);
                    }else{
                        dfd.resolve();
                        if (self.sandbox.device.os !== 'web') {
                            console.log('RULES:collection:syncing rules to native:' + JSON.stringify(self.toJSON()));
                            cordova.exec(null, null, 'WeMoSMARTDevicePlugin', 'syncRulesToNative', [self.sandbox.model.baseObject.information.udn, self.toJSON(), 'syncToWebview']);
                        }
                    }

                } else {
                    dfd.reject(resp);
                }
                self.sandbox.emit('rules.setRulesComplete');
            }

            if (this.sandbox.device.os !== 'web') {
                if (saveRules.length !== 0 || deleteRule) {
                    console.log('RULES:collection:saving:ruleList:' + xml);
                    cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [self.sandbox.model.baseObject.information.udn, this.rulesService, 'SetRules', {
                        data: {
                            ruleList: xml
                        },
                        macAddress: this.sandbox.model.baseObject.information.mac
                    }, 'xml']);
                } else {
                    console.log('RULES:SAVE: No rules to save');
                    callMeMaybe('<errorCode>0</errorCode>');
                }

            } else {
                console.error(xml);
                //browser
                $.ajax('scripts/libs/rulesEngine/mocks/rules.xml', {
                    dataType: 'text',
                    data: xml,
                    success: callMeMaybe,
                    error: callMeMaybe,
                    type: 'POST'
                });
            }
            return dfd.promise();
        },
        delete: function() {
            var self = this;
            var dfd = new $.Deferred();
            var rules = '';
            _.each(this.models, function(model) {
                var id = model.get('id');
                rules += '<rule><id>' + id + '</id></rule>';
            });

            xml = '<rules  action="SetRules">' + rules + '</rules>';

            this.sandbox.emit('rules.deleteRules');

            function callMeMaybe(resp) {

                if (resp !== 'ERROR') {
                    self.reset();
                    dfd.resolve();

                } else {
                    dfd.reject(resp);
                }
                self.sandbox.emit('rules.deleteRulesComplete');
            }

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'SetRules', {
                    data: {
                        ruleList: xml
                    },
                    macAddress: this.sandbox.model.baseObject.information.mac
                }, 'xml']);
            } else {
                console.error(xml);
                //browser
                $.ajax('scripts/libs/rulesEngine/mocks/rules.xml', {
                    dataType: 'text',
                    data: xml,
                    success: callMeMaybe,
                    error: callMeMaybe,
                    type: 'POST'
                });
            }
            return dfd.promise();
        },
        /**
         * convert from xml to JSON that can be modeled.
         * @param  {JSON} resp [data in xml format]
         * @return {JSON} jsonResp
         */
        parse: function(resp) {
            return parse.toJSON(resp);
        }
    });

    module.exports = Collection;
});

define('libs/rulesEngine/templateModel',['require','exports','module','Cache','plugins/xml2json','libs/pouchInterfaceBaseObject'],function(require, exports, module) {
    var Backbone = require('Cache');
    var xml = require('plugins/xml2json');
    var PouchInterface = require('libs/pouchInterfaceBaseObject');


    var Model = Backbone.Model.extend({

    });

    module.exports = Model;
});
define('libs/rulesEngine/templateCollection',['require','exports','module','Cache','./templateModel','plugins/xml2json'],function(require, exports, module) {
    var Backbone = require('Cache');
    var Model = require('./templateModel');
    var Xml = require('plugins/xml2json');



    var Collection = Backbone.Collection.extend({
        model: Model,
        rulesService: 'urn:Belkin:service:rules:1',
        initialize: function(options) {
            options = options || {};
            _.extend(this, options);
        },
        /**
         * sends the xml to the firmware
         * @param  {string} template [xml template as string]
         * @return {promise}          [resolve on success]
         */
        send: function(template) {
            var self = this;
            var dfd = new $.Deferred();

            this.sandbox.emit('rules.setTemplate');

            function callMeMaybe(resp) {
                if (resp !== 'ERROR') {
                    dfd.resolve(resp);
                } else {
                    dfd.reject(resp);
                }
                self.sandbox.emit('rules.setTemplateComplete');
            }

            console.log(template);

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'SetTemplates', {
                    data: {
                        templateList: template
                    },
                    macAddress: this.sandbox.model.baseObject.information.mac
                }, 'xml']);
            } else {
                //browser, always passes
                callMeMaybe();
            }

            return dfd.promise();
        },
        /**
         * override default backbone collection sync
         * @param  {string} method  [type of sync, always read]
         * @param  {obj} model   [Backbone.model]
         * @param  {obj} options [object literal options]
         * @return {promise}         [resolves on success]
         */
        sync: function(method, model, options) {
            var self = this;
            var dfd = new $.Deferred();

            // Make the request, allowing the user to override any Ajax options.
            function callMeMaybe(resp) {

                if (resp !== 'ERROR') {
                    options.success(resp);
                    dfd.resolve(resp, model, options);
                    self.trigger('request', model, resp, options);

                } else {
                    dfd.reject(resp);
                }
            }

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(callMeMaybe, callMeMaybe, 'WeMoSMARTDevicePlugin', 'callAction', [this.sandbox.model.baseObject.information.udn, this.rulesService, 'GetTemplates', {
                    data: {},
                    macAddress: this.sandbox.model.baseObject.information.mac
                }, 'xml']);
            } else {
                console.warn('syncing')
                //browser
                $.ajax('scripts/libs/rulesEngine/mocks/gettemplates.xml', {
                    dataType: 'text',
                    success: callMeMaybe,
                    error: callMeMaybe,
                    type: 'GET'
                });
            }

            return dfd.promise();
        },
        /**
         * convert from xml to JSON that can be modeled.
         * @param  {JSON} resp [data in xml format]
         * @return {JSON} jsonResp
         */
        parse: function(resp) {
            var jsonResp = [];
            var c = 0;
            var x = new Xml();
            var obj = x.xml_str2json(resp);


            _.forEach(obj.templates.template, function(value, index) {
                jsonResp[index] = {
                    id: value.id,
                    body: value.body.__cdata,
                    description: value.description,
                    min_version: value.min_version,
                    max_version: value.max_version
                }
            });

            return jsonResp;

        }
    });

    module.exports = Collection;
});
define('libs/rulesEngine/engine',['require','exports','module','./collection','./parse','./templateCollection','./model'],function (require, exports, module) {
    var Collection = require('./collection');
    var Parse = require('./parse');
    var TemplateCollection = require('./templateCollection');
    var Model = require('./model');


    var parse = new Parse();


    var Engine = function (options) {
        options = options || {};
        this.initialize(options);
    }

    Engine.prototype = {
        constructor: Engine,
        initialize: function (options) {
            _.extend(this, options);
            this.templateCollection = new TemplateCollection({
                sandbox: this.sandbox
            });
            this.collection = new Collection({
                sandbox: this.sandbox
            });
            _.bindAll(this);
        },
        getTemplates: function () {
            var self = this;
            var isTemplateSet = false;
            var udn = this.sandbox.model.baseObject.information.udn;

            if (udn) {
                isTemplateSet = window.sessionStorage.getItem('setTemplates' + udn);
            }

            if (!isTemplateSet) {
                return self.setTemplates();
            } else {
                return self.triggerReady(isTemplateSet);
            }
        },
        defaultRules: function () {
            var rulesToAdd = [],
                self = this;
            _.each(this.sandbox.model.getDefaultRules, function (rule) {
                var location = self.sandbox.name + ':rules.' + rule.parameters['action-start'].notifications[0].message;
                rule.parameters['action-start'].notifications[0].message = self.sandbox.i18n.t(location, {friendlyName: self.sandbox.model.get('friendlyName') });
                rulesToAdd.push(rule);
            });
            console.log(rulesToAdd);
            if (rulesToAdd.length > 0) {
                this.saveRules(rulesToAdd, function () {
                    console.log('default rules saved');
                });
            }
        },
        saveRules: function (arrayRules, callback) {
            var self = this;
            for (var i = 0; i < arrayRules.length; i++) {
                self.addRule(arrayRules[i]);
            }
            self.setRules(arrayRules, callback);
        },
        setTemplates: function () {
            //get the template xml, send it to the firmware/cloud, get rules when finished
            return this.templateCollection.send(this.template).then(this.triggerReady).fail(this.handleException);
        },
        getRules: function () {
            this.collection.fetch().then(function (resp) {
                console.log('fetch result: ' + resp);
            });
        },
        setRules: function (rules, callback) {
            var self = this;
            this.collection.save(rules).then(callback).fail(function (resp) {
                self.collection.trigger('saveError', {resp: resp});
            });
        },
        deleteRules: function (callback) {
            this.collection.delete().then(callback);
        },
        /** we don't want to do anything with rules until this is ready**/
        triggerReady: function (isTemplateSet) {

            var dfd = $.Deferred();

            var udn = this.sandbox.model.baseObject.information.udn;
            if (udn) {
                window.sessionStorage.setItem('setTemplates' + udn, 'set');
            }


            dfd.resolve();
            return dfd.promise();
        },
        nativeRuleChanged: function (ruleJson) {
            var self = this;

            self.collection.reset();
            console.log('engine.nativeRuleChanged:entering engine');
            _.each(ruleJson, function (rule) {
                /*   var existing = _.findWhere(self.collection.models, {
                 id: rule.id
                 });
                 if (existing) {
                 existing.set(rule);
                 } else {*/
                self.addRule(rule);
                //  }
                console.log('RULE:' + JSON.stringify(rule));
            })
            console.log('engine.nativeRuleChanged:my collection:' + JSON.stringify(self.collection.toJSON()));
            self.collection.trigger('sync');

        },
        handleException: function (resp) {
            throw ('ERROR!' + JSON.stringify(resp));
        },
        addRule: function (rule) {
            var modelFound = this.collection.where({id: rule.id});
            if (modelFound.length === 0) { //if not found, it is a new rule
                var model = new Model().set(rule);
                this.collection.add(model);
                console.log(rule);
            } else {
                if (!this.isEqualRule(modelFound[0], rule)) { // if found and has changed, let's update it
                    modelFound[0].unset("parameters");
                    modelFound[0].set(rule);
                }
            }
        },
        isEqualRule: function (modelRule, newRule) {
            var ruleAttr = modelRule.attributes;
            var newRuleAttr = (new Model().set(newRule)).attributes;

            if (_.isEqual(ruleAttr, newRuleAttr)) {
                return true;
            }
            //if the rule is part of the default rules let's say it does not change.
            //needs to be reviewed if default rules need to be updated
            if (this.sandbox.model.getDefaultRules && _.findWhere(this.sandbox.model.getDefaultRules, {id: ruleAttr.id}) !== undefined) {
                return true;
            }
            return false;
        }
    }

    module.exports = Engine;
});

define('extensions/rulesEngine', ['libs/rulesEngine/engine'], function(RulesEngine) {

    'use strict';



    return {
        initialize: function(app) {
            app.sandbox.RulesEngine = RulesEngine;
        }
    };
});
define('libs/serializationTracking/tracking',['require','exports','module','plugins/xml2json'],function (require, exports, module) {
    var Xml = require('plugins/xml2json');

    var x = new Xml(),
        dfd = new $.Deferred();

    var Tracking = function (options) {
        options = options || {};
        this.initialize(options);
    };

    Tracking.prototype = {
        constructor: Tracking,
        initialize: function (options) {
            _.extend(this, options);
            _.bindAll(this);
        },
        /**
         * Function to get the url based on retailer details
         * @param options obj - must have this structure "device" : { "pluginId":pluginId,"macAddress":mac,"serialNumber":sn}
         * @returns {JQueryDeferred}
         */
        getUrl: function (options) {
            var obj = {
                "devices": options
            },
                xml;
            dfd = new $.Deferred();
            xml = x.json2xml_str(obj);

            if (this.sandbox.device.os !== 'web') {
                cordova.exec(this.parseXml, this.errorHandler, 'WeMoSMARTDevicePlugin', 'callActionRemote', [this.sandbox.model.get('udn'), '', 'GetRetailerDetails', {
                    data: {
                        deviceDetails: xml
                    },
                    macAddress: this.sandbox.model.get('macAddress') || ""
                }, 'xml']);
            } else {
                //Just a test XML response
                $.ajax('scripts/libs/serializationTracking/mocks/track.xml', {
                    dataType: 'text',
                    success: this.parseXml,
                    error: this.errorHandler,
                    type: 'GET'
                });
            }

            return dfd.promise();
        },
        /**
         * Function to parse the XML response
         * @param resp
         */
        parseXml: function (resp) {
            var self = this;
            var obj = resp !== "" ? x.xml_str2json(resp) : "";
            if (obj['error'] || obj === "") {
                dfd.reject(obj);
            } else {
                dfd.resolve(obj);
            }

        },
        /**
         * Error Handler
         * @param error
         */
        errorHandler: function (error) {
            dfd.reject(error);
        }


    };


    module.exports = Tracking;
});

define('extensions/serializationTracking', ['libs/serializationTracking/tracking'], function (Tracking) {

    'use strict';

    return {
        initialize: function (app) {
            app.sandbox.SerializationTracking = Tracking;
        }
    };
});

define('libs/execHandler',[], function() {
    var ExecHandler = function() {
        this.initialize.apply(this, arguments);
    };
    if (!window.smartDevicePlugin) {
        window.smartDevicePlugin = {};
    }

    window.smartDevicePlugin.callbackList = {};
    window.smartDevicePlugin.onDeviceChanged = function(id, resp) {
        //find the device, fire off the first callback in the array, then get rid of it.
        DEBUG && console.log('ExecHandler:onDeviceChanged:RESPONDED:' + id);


        var callback = window.smartDevicePlugin.callbackList[id];
        if (callback && id) {
            if (callback.length > 0) {
                var self = callback[0];
                clearTimeout(self.timeout);

                if (typeof resp == 'string') {
                    resp = JSON.parse(resp);
                }

                if (((self.action == 'setDeviceState' || self.action == 'setGroupState') && resp.onDeviceUpdated) || (!resp.onDeviceUpdated && resp.success === 'true') || (self.action == 'setDeviceProperties' && resp.success === 'true')) {
                    DEBUG && console.log('ExecHandler:useWindowMethod:SUCCESS:' + self.plugin + ':' + self.action + ':' + JSON.stringify(resp));
                    if (self.callback) {
                        self.callback(resp);
                    }
                    self.dfd.resolve(resp);
                } else {
                    DEBUG && console.log('ExecHandler:useWindowMethod:ERROR:' + self.plugin + ':' + self.action + ':' + JSON.stringify(resp));
                    self.dfd.reject(resp);
                }

                callback.splice(0, 1);
            }
        }
    }

    ExecHandler.prototype = {
        constructor: ExecHandler,
        initialize: function(options) {
            _.bindAll(this);
            options = options || {};
            _.extend(this, options);
            this.dfd = new $.Deferred();
            this.timeout = setTimeout(function() {}, 0);

        },
        success: function(resp) {
            if (!this.useWindowMethod) {
                DEBUG && console.log('ExecHandler:SUCCESS:' + this.plugin + ':' + this.action + ':' + JSON.stringify(resp));
                if (this.callback) {
                    this.callback(resp);
                }
                this.dfd.resolve(resp);
            }
        },
        initWindowMethod: function() {
            //create an array of callbacks to this device.

            if (!window.smartDevicePlugin.callbackList[this.useWindowMethod]) {
                window.smartDevicePlugin.callbackList[this.useWindowMethod] = [];
            }

            window.smartDevicePlugin.callbackList[this.useWindowMethod].push(this);

        },
        error: function(err) {
            if (!this.useWindowMethod) {
                DEBUG && console.log('ExecHandler:ERROR:' + this.plugin + ':' + this.action + ':' + JSON.stringify(err));
                //in cases where device is not reachable, err = {isDiscovered:false}, update this model to cause greyout
                if (this.errorCallback) {
                    this.errorCallback(err);
                }
                this.dfd.reject(err);
            }
        },
        go: function(plugin, action, data) {
            var self = this;
            data = data || [];
            this.plugin = plugin;
            this.action = action;
            DEBUG && console.log('ExecHandler:' + plugin + ':' + action + ':' + JSON.stringify(data));
            this.isRemote = (window.sessionStorage.getItem('isRemote') === "true");
            this.timeoutLimit = 15000;

            if (this.useWindowMethod) {
                this.initWindowMethod();
            }

            if (window.cordova) {
                DEBUG && console.log('ExecHandler:' + plugin + ':' + action + ':sending to Cordova');
                window.cordova.exec(this.success, this.error, plugin, action, data);
            } else {
                if (this.useWindowMethod) {

                    var success = 'true';

                    var jsonString = JSON.stringify({
                        udn: this.useWindowMethod,
                        success: success
                    });
                    window.smartDevicePlugin.onDeviceChanged(this.useWindowMethod, jsonString);
                } else {
                    this.success({});
                }
            }

            if (!this.ignoreTimeout) {
                this.timeout = setTimeout(function() {
                    window.smartDevicePlugin.onDeviceChanged(self.useWindowMethod, {
                        success: false,
                        error: 'timeout'
                    });
                }, self.timeoutLimit);
            }
            return this.dfd.promise();
        }
    }

    return ExecHandler;

});
/** a common API for devices and the browser. the browser version returns mock data for testing, will be used as part of an extension to mixin with the sandbox  **/
define('libs/smartDevicePlugin',['libs/execHandler', 'libs/constants'], function(ExecHandler, Constants) {
    'use strict';

    var callPlugin = function(plugin, action, data, options) {
        var handler = new ExecHandler(options);
        return handler.go(plugin, action, data);
    }

    var exports = {
        /**
         * sends device to Native layer to update state via UPNP or cloud
         * @param {function} callback a callback method to fire on success, if one is defined.
         * @param {JSON object} model [the entire device model]
         * @param {JSON object} data        [contains state attributes]
         * @return {promise}
         */
        setDeviceState: function(callback, model, data) {
            return callPlugin('SmartDevicePlugin', 'setDeviceState', [model.baseObject.information, data], {
                callback: callback,
                model: model,
                useWindowMethod: model.baseObject.information.udn
            });
        },
        setDeviceProperties: function(callback, model, data) {
            return callPlugin('SmartDevicePlugin', 'setDeviceProperties', [model.baseObject.information, data], {
                callback: callback,
                model: model,
                useWindowMethod: model.baseObject.information.udn
            });
        },
        setNightModeConfiguration: function(callback, model, data) {
            return callPlugin('SmartDevicePlugin', 'setNightModeConfiguration', [data], {
                callback: callback
            });
        },
        /**
         * updates the state for all devices in a group
         * @param {Backbone.Model} model the device model
         * @param {JSON} data  the attributes to save
         */
        setGroupState: function(model, data) {
            return callPlugin('SmartDevicePlugin', 'setGroupState', [model.baseObject.information, data], {
                model: model,
                callback: function() {
                    model.trigger('save');
                },
                useWindowMethod: model.baseObject.properties.groupID
            });
        },
        collectEmailId:function(){
            return callPlugin('SmartDevicePlugin', 'collectEmailID');
        },
        /**
         * gets all discovered devices from smartCache
         * @return {promise}
         */
        getDevices: function() {
            return callPlugin('SmartDevicePlugin', 'getDevices');
        },
        getDevicesInfo: function() {
            return callPlugin('SmartDevicePlugin', 'getDevicesInfo');
        },
        /**
         * gets a single device from smartCache (smartCache must get data from device)
         * @return {promise}
         */
        getDevice: function(callback, model, options) {
            return callPlugin('SmartDevicePlugin', 'getDevice', [model.baseObject.information], {
                callback: callback,
                model: model
            });
        },
        checkNestAuth: function () {
            return callPlugin('SmartDevicePlugin', 'nestTokenExistForGivenHomeId');
        },

        getNestDevices: function () {
            return callPlugin('SmartDevicePlugin', 'getNestDevices');
        },
        /**
         * gets updated insight values every 5 seconds from smartCache (smartCache must get data from device)
         * @return {promise}
         */
        getInsightParameters: function(callback, model, options) {
            return callPlugin('SmartDevicePlugin', 'getInsightParameters', [model.baseObject.information], {
                callback: callback,
                model: model
            });
        },
        setInsightDrawerState: function(deviceInfo) {
            return callPlugin('SmartDevicePlugin', 'setInsightDrawerState', [deviceInfo]);
        },
        /**
         * refreshes device list - triggers re-discovery in smartCache
         * @return {promise}
         */
        refreshDevices: function() {
            return callPlugin('SmartDevicePlugin', 'refreshDevices');
        },
        /**
         * adds a device to a group
         * @param  {string} udn     unique device id
         * @param  {string} groupId unique group id
         * @param {boolean} isNewGroup true when creating a new group
         * @return {promise}
         */
        addToGroup: function(bridgeUDN, payload, isNewGroup) {
            if (!isNewGroup) isNewGroup = false;
            return callPlugin('SmartDevicePlugin', 'addToGroup', [bridgeUDN, payload, isNewGroup], {
                useWindowMethod: bridgeUDN
            });
        },
        /**
         * removes a device/devices from a group
         * @param  {string} udn     unique device id
         * @param  {string} groupId unique group id
         * @return {promise}
         */
        removeFromGroup: function(bridgeUDN, groupID) {
            return callPlugin('SmartDevicePlugin', 'removeFromGroup', [bridgeUDN, groupID, false], {
                useWindowMethod: bridgeUDN
            });
        },
        /** removes a device/devices from a group
         * @param  {string} type
         * @param  {json} deviceInfo
         * @param  {json} stateData
         * @return {promise}
         */
        resetDevice: function(type, deviceInfo, stateData, callback) {
            var dataArray = [type, deviceInfo];

            if (stateData !== null) {
                dataArray.push(stateData);
            }
            return callPlugin('SmartDevicePlugin', 'resetDevice', dataArray, {
                callback: callback
            });
        },
        /**
         * set blob storage from device
         * @param {String} udn
         * @param {JSON} data
         * @param {function} callback
         * @return {promise}
         */
        setBlobStorageData: function(udn, data, callback) {

            return callPlugin('SmartDevicePlugin', 'setBlobStorageData', [udn, data], {
                callback: callback,
                useWindowMethod: udn
            });
        },
        /**
         * get blob storage from device
         * @param {String} udn
         * @param {JSON} data
         * @param {function} callback
         * @return {promise}
         */
        getBlobStorageData: function(udn, data,callback) {
            return callPlugin('SmartDevicePlugin', 'getBlobStorageData', [udn,data],{
                callback: callback,
                useWindowMethod: udn
            });
        },
        /**
         * configure Dimming Range.
         * @param  {json} deviceInfo
         * @return {promise}
         */
        configureDimmingRange: function(deviceInfo) {
            return callPlugin('SmartDevicePlugin', 'configureDimmingRange', [deviceInfo]);
        },
        /**
         * check if Bulb devices are connected.
         * @param  {json} deviceInfo
         * @return {promise}
         */
        adjustIcon: function(deviceInfo, callback) {
            return callPlugin('SmartDevicePlugin', 'adjustIcon', [deviceInfo], {
                callback: callback
            });
        },
        /**
         * check if Bulb devices are connected.
         * @param  {json} deviceInfo
         * @return {promise}
         */
        choosePhoto: function(deviceInfo, callback) {
            return callPlugin('SmartDevicePlugin', 'choosePhoto', [deviceInfo], {
                callback: callback
            });
        },

        /**
         * check if Bulb devices are connected.
         * @param  {json} deviceInfo
         * @return {promise}
         */
        takePicture: function(deviceInfo, callback) {
            return callPlugin('SmartDevicePlugin', 'takePicture', [deviceInfo], {
                callback: callback
            });
        },
        /**
         * check if there is Netcam app installed
         * @return {promise}
         */
        checkNetcam: function() {
            return callPlugin('DevicePlugin', Constants.actions.CHECK_NET_CAM);
        },
        /**
         * launch Netcam app
         * @param  {string} item
         * @param  {json} deviceInfo
         * @param  {integer} extraParam
         * @return {promise}
         */
        launchNetcam: function(item, deviceInfo, extraParam) {
            var dataArray = [item, deviceInfo, extraParam];

            return callPlugin('DevicePlugin', Constants.actions.LAUNCH_NET_CAM_APP, dataArray);
        },
        /**
         * check if Bulb devices are connected.
         * @param  {json} deviceInfo
         * @return {promise}
         */
        findBulb: function(deviceInfo) {
            return callPlugin('SmartDevicePlugin', 'findBulb', [deviceInfo]);
        },
        /**
         * remove device disconnected from device list.
         * @param  {json} deviceInfo
         * @return {promise}
         */
        hideDevice: function(deviceInfo) {
            return callPlugin('SmartDevicePlugin', 'hideDevice', [deviceInfo]);
        },
        /**
         * remove device disconnected from device list.
         * @param  {string} groupID
         * @return {promise}
         */
        hideGroup: function(groupID) {
            return callPlugin('SmartDevicePlugin', 'hideGroup', [groupID]);
        },
        /**
         * initiate App recovery mecahnism
         * @return {promise}
         */
        initiateAppRecovery: function() {
            return callPlugin('SmartDevicePlugin', 'appRecovery');
        },
        /**
         * set bulb type
         * @param  {json} deviceInfo
         * @param {function} callback
         * @return {promise}
         */
        setBulbType: function(deviceInfo, callback) {
            return callPlugin('SmartDevicePlugin', 'setBulbType', [deviceInfo], {
                callback: callback
            });
        },
        /**
         * calibrate bulbs for dimmer
         * @param  {json} deviceInfo
         * @param {function} callback
         * @return {promise}
         */
        calibrateBulb: function(deviceInfo, callback) {
            return callPlugin('SmartDevicePlugin', 'calibrate', [deviceInfo], {
                callback: callback
            });
        },
        configHushMode: function(deviceInfo, callback) {
            return callPlugin('SmartDevicePlugin', 'configureHushMode', [deviceInfo], {
                callback: callback
            });
        },
        /**
        * to check if bohnjour present in network
        * @param {function} callback
        * @return {promise}
        */
        checkBohnjour: function(callback){

            return callPlugin('SmartDevicePlugin', 'checkBohnjour',[], {
                 callback : callback
            });
        },

        /**
         * generat auth code
         * @param {function} callback
         * @return {promise}
         */
        getAuthCode: function(callback) {
            return callPlugin('WebServicePlugin', 'getAuthCode', [], {
                callback: callback
            });
        },
        /**
         * generat auth code
         * @return {promise}
         */
        openAlexa: function() {
            return callPlugin('DevicePlugin', '9106', []);
        },
        /**
         * Smart device uuid
         * @return {promise}
         */
        getUUID: function(callback) {
            return callPlugin('DevicePlugin', '6004', [],{
                callback: callback
            });
        },
        getRemoteAccess: function(callback) {
            return callPlugin('DevicePlugin', '6002', [],{
                callback: callback
            });
        },
        getAnalyticsData: function(callback) {
            return callPlugin('NativeUtilPlugin', '6006', [],{
                callback: callback
            });
        }
    };

    return exports;
});

/* START_TEMPLATE */
define('hbs!extensions/templates/errorBanner',['hbs','handlebars'], function( hbs, Handlebars ){ 
var t = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [3,'>= 1.0.0-rc.4'];
helpers = helpers || Handlebars.helpers;
  


  return "<div class=\"warningNotification\">\n    <span class=\"error-label\"></span>\n    <span class=\"fa fa-angle-right\"></span>\n</div>";
  });
Handlebars.registerPartial('extensions_templates_errorBanner', t);
return t;
});
/* END_TEMPLATE */
;
define('extensions/ui/errorBanner', ['backbone', 'hbs!../templates/errorBanner'], function(Backbone, template) {

    'use strict';


    return Backbone.View.extend({
        name: "error_banner",
        className:"error_banner",
        events: {
            "click" : "showErrorDetailsView"
        },

        template: template,

        initialize: function(options) {
            this.options = options || {};

            this.tileView = options.tile;
            this.sandbox = options.tile.sandbox;
            this.model = options.tile.model;
            this.errorCode = options.errorCode;

            this.render();
            this.listen();
        },

        listen: function(){
            this.sandbox.on('dismissError', this.dismiss.bind(this));
        },

        render: function(){
            this.$el.html(this.template);
            var bannerText = this.tileView.i18n('hardwareError.banner', this.errorCode);
            this.$('.error-label').text(bannerText);
            this.$('.warningNotification').attr('aria-label', bannerText + " double tab to view more information");

            this.tileView.$el.append(this.$el);
            this.delegateEvents();
            return this;
        },

        createErrorViewObject: function(){
            return {
                title: this.model.get("defaultFriendlyName") + " " + this.tileView.i18n('hardwareError.title', this.errorCode),
                titleAria: this.model.get("defaultFriendlyName") + " " + this.tileView.i18n('hardwareError.title', this.errorCode) + " double tab to go back",
                description: this.tileView.i18n('hardwareError.description', this.errorCode),
                descriptionAria: this.tileView.i18n('hardwareError.descriptionAria', this.errorCode),
                buttonLabelPrimary: this.tileView.i18n('hardwareError.buttonLabels.primary', this.errorCode),
                buttonLabelSecondary: this.tileView.i18n('hardwareError.buttonLabels.secondary', this.errorCode),
                buttonLabelPrimaryAria: this.tileView.i18n('hardwareError.buttonLabels.primary', this.errorCode) + " double tab to remove error banner",
                buttonLabelSecondaryAria: this.tileView.i18n('hardwareError.buttonLabels.secondary', this.errorCode) + " double tab to open support pages"
            }
        },

        showErrorDetailsView: function(){
            this.sandbox.emit("global.warning:device_error", {
                sandbox:this.sandbox,
                errorStrings:this.createErrorViewObject()
            });

            console.log(this.createErrorViewObject());

        },

        dismiss:function(){
            this.undelegateEvents();
            this.$el.unbind();
            this.remove();
            //only for devices with a drawer
            if (this.tileView.accordion) {
                this.tileView.accordion.resizeDrawerForBanner();
            }

            this.hideBanner = 1;
        }
    });

});

define('extensions/views/backbone.tileBase', ['Cache', 'libs/smartDevicePlugin', '../ui/errorBanner'],
    function(Backbone, smartDevicePlugin, ErrorBanner) {

        'use strict';

        var aura;

        Backbone.TileBaseView = Backbone.View.extend({
            type: 'tile',
            tagName: 'div',
            timer: setTimeout(function() {}, 0),
            imageBulbName: '',
            isBridgeUpdating: false,
            isRemote: false,
            lng: '',

            /**
             * runs the first time the view is created. Only runs once, unless the widget is destroyed
             * @param options {object}
             */
            initialize: function(options) {
                var self = this;

                _.bindAll(this);

                this.options = options || {};

                if (this.options.sandbox) {
                    this.sandbox = this.options.sandbox;
                    this.model = this.sandbox.model;
                } else {
                    throw ('you need to pass the sandbox to any child views');
                }


                this.$el.addClass('smart-tile');
                this.sandbox.on('rendered', function() {
                    if(self.afterInitialize) self.afterInitialize();
                });

                this.sandbox.on('changeToBrandName', function() {
                    self.changeBrandName();
                });

                //throttle hammer
                this.throttledHideTile = _.throttle(this.hideTile, 1000, {
                    trailing: false
                });

                this.startListening();
                this.setDefaultFriendlyName();
                this.lng = this.options.parentView.options.i18n.split('/')[4];
                this.isRemote = (window.sessionStorage.getItem('isRemote') === "true");
            },
            initialRender: function() {
                DEBUG && console.log('TILE BASE: TILE INITIAL RENDER');
                var self = this;
                var html = this.i18n(this.template);
                this.$el.html(html);

                setTimeout(function() { // timeout to push this stuff to the bottom of the execution stack.
                    //see if we are editing at the time this widget is created/rendered
                    self.addIconBinding();

                    self.stickit();
                    self.$el.css("display", "block");
                    //initial chek for discovery, and then listen for changes.
                    self.isDiscovered();

                    if (self.options.extendedOptions && self.options.extendedOptions.component) {
                        self.startEditing();
                        self.stopEditing();
                    }

                    if(self.model.get('overTemp')){
                        self.onHWError();
                    }

                }, 0);
            },
            /**
             * gets the data
             */
            fetch: function() {
                DEBUG && console.log('TILEANDDRAWER: fetch: should be fetching from the tile');
                this.model.fetch();
            },
            fetchFromCache: function() {
                return this.model.fetchFromCache();
            },
            startEditing: function() {
                var self = this;
                var editHTML;
                var $drawerArrow = self.$('.drawerArrow');

                this.$('.row-tile').addClass('editMode');
                //only for devices with a drawer
                if (self.accordion) {
                    self.accordion.stopControl();
                }
                if ($drawerArrow.length > 0) {
                    $drawerArrow.hide();
                }
                self.$('.powerState').attr('aria-hidden','true');
                self.$('.powerIndicator').attr('aria-hidden','true');


                if(self.$(".warningNotification").is(':visible')) {
                    self.$(".warningNotification").hide();
                    self.$(".warningNotification").addClass("hideForEdit");
                }

                if (self.sandbox.model.get('isDiscovered')) {
                    if (self.$('.order_device').length === 0) {
                        editHTML = '<span class="order_device fa fa-align-justify" aria-label="Reorder Device"></span>';
                        if (!self.sandbox.model.baseObject.component.groupMaster) {
                            editHTML += '<span class="edit_device fa fa-chevron-right" aria-label="Edit Device Settings"></span>';
                        } else {
                            editHTML += '<span class="edit_group fa fa-chevron-right"></span>';
                        }
                        self.$('.tile3').prepend(editHTML);
                    } else {
                        self.$('.edit_device, .order_device, .edit_group').show();
                    }
                } else {
                    this.$el.parents(".isApp").addClass("grayedOut");
                }
            },
            stopEditing: function() {
                var self = this;
                var $drawerArrow = self.$('.drawerArrow');
                this.$('.row-tile').removeClass('editMode');
                //only for devices with a drawer
                if ($drawerArrow.length > 0) {
                    $drawerArrow.show();
                }

                if (self.accordion) {
                    self.accordion.startControl();
                }

                var hwError = this.model.get("overTemp");
                if (!(hwError && parseInt(hwError) !== 0)) {
                    self.$('.powerState').show();
                    self.$('.powerIndicator').show();
                }

                if (self.$(".warningNotification").hasClass("hideForEdit")) {
                    self.$(".warningNotification").show();
                }

                self.$('.powerState').attr('aria-hidden','false');
                self.$('.powerIndicator').attr('aria-hidden','false');

                //DELETE:SC+SFW
                if (self.sandbox.model.get('isDiscovered')) {
                    self.$('.edit_device, .order_device, .edit_group').hide();
                } else {
                    self.$el.parents(".isApp").removeClass("grayedOut");
                }

            },
            /**
             * put non-DOM event listeners here. These need to be removed when no longer necessary to free up memory (this.stopListening())
             */
            startListening: function() {
                var self = this;
                if (window.isSmartCache) {
                    this.listenTo(this.sandbox.model, 'change:isDiscovered', this.isDiscovered);
                    this.sandbox.on('firmwareUpdateStatus', this.firmwareUpdateStatus);
                }

                this.sandbox.on('global.editing', this.startEditing);
                this.sandbox.on('global.editing:stop', this.stopEditing);
                this.sandbox.on('showGroupableIcon', this.showGroupableIcon);
                this.sandbox.on('hideGroupableIcon', this.hideGroupableIcon);
                this.sandbox.on('save:fail', this.failSave);
                this.sandbox.on('drawer:close', function() {
                    self.accordion.close();
                });
                this.sandbox.on('changeBridgeUpdating', function(value) {
                    self.isBridgeUpdating = value;
                });

                self.checkRules();

                this.sandbox.globalsettings.checkForChanges();

                this.sandbox.SerializationTracking = new this.sandbox.SerializationTracking({
                    sandbox: this.sandbox
                });

                this.listenTo(this.model, 'syncFromCache', this.sync);
                this.listenTo(this.model, 'save', this.afterSave);
                this.listenTo(this.model, 'loseConnection', this.loseConnection);
                this.listenTo(this.model, 'change:overTemp', this.onHWError);

                if (this.listen) {
                    this.listen();
                }
            },
            updateFriendlyName: function(friendlyName) {
                this.model.set('friendlyName', friendlyName);
                this.model.saveToCache();
            },
            changeBrandName: function() {
                function callMeMaybe(resp) {
                    if (resp) {
                        DEBUG && console.log('SUCCESS CHANGE FRIENDLY NAME WITH BRAND NAME ' + resp);
                    } else {
                        DEBUG && console.log('ERROR: SET FRIENDLY NAME: ' + resp);
                    }
                }
            },

            onHWError: function() {
                var hwErrorStatus = parseInt(this.model.get('overTemp'));
                if(hwErrorStatus !== 0){
                    if (this.$(".coolDown").length < 1) {
                        this.$(".tile2 .status,.powerState,.firmwareUpdateComplete").hide();
                        this.$(".tile2 .status").attr("aria-hidden", "true");
                        this.$(".tile2").addClass("notClickable").append('<span class="coolDown" aria-label="cooling off">'+ this.i18n('hardwareError.status') +'&#8230;'+'</span>');
                    }

                    if(!this.errorBanner || this.errorBanner.hideBanner) {
                        this.errorBanner = new ErrorBanner({
                            tile: this,
                            errorCode: hwErrorStatus
                        });
                    }
                    this.$(".powerState").attr("aria-hidden", "true");
                } else {
                    this.$(".tile2 .status,.powerState").show();
                    this.$(".tile2 .status").attr("aria-hidden", "false");
                    this.$(".powerState").attr("aria-hidden", "false");
                    this.$(".tile2").removeClass("notClickable");
                    this.$(".tile2 .coolDown").remove();
                }

                this.$('.tile2').show();
            },
            updateCache: function(data) {
                this.model.set(data);
                this.model.saveToCache();
            },
            onFirmwareUpdate: function() {
                var friendlyName = this.sandbox.model.get('friendlyName');
                this.$('.tile3').hide();
                this.$('.tile2').hide();
                this.$('.tile2').after('<div class="tileNotAvailableFW"><section><h1>' + friendlyName + '</h1><span>' + this.sandbox.i18n.t('translation:firmware.update') + '</span></section><div class="progressFW"><div>…</div></div></div>');
            },
            addIconBinding: function() {
                var self = this;

                if (this.setDefaultIcon) {
                    this.setDefaultIcon();
                } else {
                    this.$('.icon').addClass('defaultIcon');
                }

                this.addBinding(null, {
                    '*[data-bind="iconURL"]': {
                        observe: ['icon', 'groupIcon', 'groupID'],
                        update: function(view, values) {
                            var icon = values[0],
                                groupIcon = values[1],
                                groupID = values[2];

                            if (icon !== '' && groupID === '') {
                                if (!self.previousicon || (self.previousicon !== icon)) {
                                    self.$('.icon').removeClass('defaultIcon').css('background-image', 'url("' + icon +'")');
                                    self.previousicon = icon;
                                }
                            }  else if (groupID !== '' && groupIcon !== '') {
                                if (!self.previousicon || (self.previousicon !== groupIcon)) {
                                    self.$('.icon').removeClass('defaultIcon').css('background-image', 'url("' + groupIcon +'")');
                                    self.previousicon = groupIcon;
                                }
                            } else {
                                self.$('.icon').addClass('defaultIcon').css('background-image', '');
                            }
                        }
                    }
                });
            },
            loseConnection: function(connected) {
                if (!connected) {
//                    this.$('.powerState').css('display', 'block');
                } else {
                    this.$('.powerState').removeClass('transitioning');
                }
            },
            /**
             * called when model value changes.
             */
            isDiscovered: function() {
                var isDiscovered = JSON.parse(this.model.get('isDiscovered'));
                var fwStatus = parseInt(this.model.get('fwStatus'), 10);
                DEBUG && console.log('backbone.tileBase:isDiscovered(): isDiscovered: ' + isDiscovered + ' fwStatus: ' + fwStatus);
                if (isDiscovered) {
                    //Give time for DOM to update and model to settle
                    var self = this;
                    setTimeout(function(){
                        if($('#wemo_devices').children().length === 1 && !($('.openAccordion').children().length > 0)){
                            self.accordion.open();
                        }
                    }, 1000);
                    this.syncSuccess();
                } else if (!isDiscovered && (isNaN(fwStatus) || (fwStatus && fwStatus === 4)) && !(this.model.baseObject.information.bridgeUDN && this.isBridgeUpdating)) {
                    this.syncError();

                    if (this.accordion) {
                        this.accordion.close();
                    }

                }

                //make sure the property is synced in the base object
                this.model.baseObject.properties.isDiscovered = isDiscovered;
            },
            /**
             * passes the sync success to the rest of the listeners, this is so we only have to do one fetch from device to update all views
             */
            passSync: function() {
                this.$el.removeClass('hidden').show();
                this.$el.parent().removeClass('hidden').show();
            },
            syncSuccess: function(model, resp) {
                /**
                 * undo sync error if it has been set
                 */
                //window.scmodel = this.model;
                DEBUG && console.log('TILEBASE:syncSuccess:received event', resp);
                this.$el.removeClass('disabled');
                this.sandbox.emit('changeToBrandName');
                //when we are first getting from cache, check to see if it was not detected on last save, if not, it should stay in error state until next fetch.
                if (this.$('.row-tile').hasClass('notAvailableBg')) {
                    this.$('.row-tile').removeClass('notAvailableBg');
                    this.$('.notAvailableBtn').off('tap', this.throttledHideTile);
                    this.$('.notAvailable').remove();
                    this.$('.tileNotAvailable').remove();
                    this.$('.notAvailableBtn').remove();
                    this.$('.tile2').show();
                    this.$('.tile3').show();
                    this.$('.powerIndicator').show();
                    this.$('.drawerArrow').show();

                    var overTempStatus = this.model.get("overTemp");
                    if (overTempStatus && parseInt(overTempStatus) === 1) {
                        this.deviceOverTemp(1);
                    }
                }

                if (this.sync) {
                    this.sync(resp);
                }
            },
            sync: function() {

            },
            /**
             * called when a model error is thrown, usually when communication fails
             */
            syncError: function() {
                //DEBUG && console.log('TILEBASE:syncError:received event:' + method);
                this.clearFirmwareUpdateElements();
                this.$el.removeClass('disabled');
                var self = this;
                if (!self.$('.row-tile').hasClass('notAvailableBg')) {
                    this.isNotDetected = true;
                    //this.model.fetchFromCache().then(function() {
                    self.$('.tileNotAvailableFW').remove();

                    DEBUG && console.log('TILEBASE:syncError:changing DOM', self.$('.row-tile').length);
                    self.$('.row-tile').append('<div class="notAvailableBtn"></div>');
                    self.$('.row-tile').addClass('notAvailableBg');
                    self.$('.tile1').append('<div class="notAvailable"></div>');
                    self.$('.tile2').after('<div class="tileNotAvailable"><h1>' + self.model.get('friendlyName') + '</h1><span>' + self.sandbox.i18n.t('wemo_router:errors.notDetected') + '</span></div>');
                    self.$('.tile2').hide();
                    self.$('.tile3').hide();
                    self.$('.powerIndicator').hide();

                    if (self.$('.heaterOff').length !== 0) {
                        self.$('.heaterOff').hide();
                    }
                    self.$('.drawerArrow').hide();
                    self.$('.notAvailableBtn').hammer().on('tap', self.throttledHideTile);
                    DEBUG && console.log('TILEBASE:syncError:did all the things');

                    //close the drawer
                    if (self.isDrawerOpen && self.accordion) {
                        self.accordion.close();
                    }
                }
            },
            /**
             * receives events from firmware update module, displays fw update messages
             * @param {integer} status the numeric status
             * @param  {string} msg translated update message
             */
            firmwareUpdateStatus: function(status, msg) {
                var self = this;
                setTimeout(function() {
                    //  DEBUG && console.warn('backbone.tileBase:firmwareUpdateStatus:' + 'status:' + status + ',msg:' + msg, self.model.get('isDiscovered'));
                    var fwStatus = parseInt(self.model.get('fwStatus'), 10);
                    var overTemp = self.model.get('overTemp');
                    //hide the power button, drawer arrow, show fw update messaging. only when isDiscovered:true
                    if (self.model.get('isDiscovered') || (fwStatus && fwStatus === 3) || !self.model.get('isDiscovered') && self.model.baseObject.information.bridgeUDN && (fwStatus && fwStatus === 4)) {
                        self.clearFirmwareUpdateElements();

                        if (!overTemp || (parseInt(overTemp) === 0)) {
                            if (status === 'clear') {
                                self.$('.description, .tile3, .status').show();
                            } else {
                                //either complete or failed.
                                if (status === 4 || status === 2 || status === 5 || status === 6) {
                                    self.$('.tile3').show();
                                    self.$('.powerIndicator').show();
                                    self.$('.status').hide();
                                    self.$('.description').show().append('<span class="firmwareUpdateComplete">' + msg + '</span>');
                                } else {
                                    self.$('.status').hide();
                                    self.$('.description, .tile3').hide();
                                    self.$('.powerIndicator').hide();
                                    self.$('.description').after('<div class="tile2 firmwareUpdateStatus status' + status + '"><h1>' + self.model.get('friendlyName') + '</h1><span>' + msg + '</span></div>');
                                }
                            }
                        } else {
                            self.$('.description').show();
                        }
                    }

                }, 0);

            },
            /**
             * take away firmware update elements
             */
            clearFirmwareUpdateElements: function() {
                this.$('.firmwareUpdateStatus').remove();
                this.$('.firmwareUpdateComplete').remove();
            },
            hideTile: function() {
                var self = this;

                this.confirmDialog = new this.sandbox.dom.CustomModal({
                    title: self.sandbox.i18n.t('wemo_router:hide.title'),
                    message: self.sandbox.i18n.t('wemo_router:hide.message'),
                    buttons: [{
                        text: self.sandbox.i18n.t('wemo_router:buttons.cancel'),
                        extraClass: 'passiveBtn',
                        width: '50%'
                    }, {
                        text: self.sandbox.i18n.t('wemo_router:buttons.hide'),
                        extraClass: 'actionBtn',
                        width: '50%',
                        events: [{
                            tap: function() {
                                var udn = self.sandbox.information.udn;

                                if (self.sandbox.model.attributes.groupID === udn) {
                                    smartDevicePlugin.hideGroup(udn).then(self.successRemoving).fail(self.failRemoving);
                                } else {
                                    var info = {
                                        'udn': udn,
                                        'hide': 1
                                    };
                                    smartDevicePlugin.hideDevice(info).then(self.successRemoving).fail(self.failRemoving);
                                }
                            }
                        }]
                    }]
                });
            },
            successRemoving: function() {
                var $parent = this.$el.parent();
                $parent.detach();
                DEBUG && console.log('Success on removing device from device list!!');
            },
            failRemoving: function() {
                DEBUG && console.log('Error on removing device from device list!!');
            },
            /**
             * creates and shows an icon for groupable products
             */
            showGroupableIcon: function() {
                var $tile = this.$('.tile1');
                var $groupable = $('<div class="groupable fa fa-plus-circle"></div>');
                $tile.prepend($groupable);
            },
            /**
             * hides/removes the grouping icon
             */
            hideGroupableIcon: function() {
                this.$('.groupable').remove();
            },
            /**
             * hide the spinner if any
             */
            afterSave: function() {
                this.$('.powerState').removeClass('transitioning');
            },
            /**
             * hide spinner if any, and return to prior model state - saved in added/updated
             */
            failSave: function() {
                this.$('.powerState').removeClass('transitioning');
                this.model.undo();
                this.model.set('isDiscovered', false);
            },
            /**
             * load defaultFriendlyName from translation file to model
             */
            setDefaultFriendlyName: function() {
                var dfn = this.i18n('defaultFriendlyName');
                this.model.attributes.defaultFriendlyName = dfn;
            },
            setCorrectBrandCharacter: function() {
                var fnName = this.model.get('friendlyName');


                if (this.lng === 'fr-FR') {
                    if (fnName.indexOf('®') !== -1) {
                        this.model.set('friendlyName', fnName.replace('®', 'ᴹᴰ'));
                    }
                } else {
                    if (fnName.indexOf('ᴹᴰ') !== -1) {
                        this.model.set('friendlyName', fnName.replace('ᴹᴰ', '®'));
                    }
                }

                if (this.isRemote && fnName.indexOf('Â') !== -1) {
                    this.model.set('friendlyName', fnName.replace('Â®', '®').replace('Âᴹᴰ', 'ᴹᴰ'));
                }
            }
        });

        return {
            initialize: function(app) {
                aura = app;
            }
        };
    });

/*      
 *         ________                                                            ________        
 *         ______(_)_____ ____  __________________  __ _____________________   ______(_)_______
 *         _____  /_  __ `/  / / /  _ \_  ___/_  / / / ___  __ \  _ \__  __ \  _____  /__  ___/
 *         ____  / / /_/ // /_/ //  __/  /   _  /_/ /____  /_/ /  __/_  /_/ /______  / _(__  ) 
 *         ___  /  \__, / \__,_/ \___//_/    _\__, /_(_)  .___/\___/_  .___/_(_)__  /  /____/  
 *         /___/     /_/                     /____/    /_/          /_/        /___/           
 *      
 *        http://pep.briangonzalez.org
 *        Kinetic drag for mobile/desktop.
 *        
 *        Copyright (c) 2013 Brian Gonzalez
 *        Licensed under the MIT license.
 *
 *        Title generated using "Speed" @ 
 *        http://patorjk.com/software/taag/#p=display&f=Speed&t=jquery.pep.js
 */

;(function ( $, window, undefined ) {

  "use strict";

  //  create the defaults once
  var pluginName = 'pep';
  var defaults   = {

    // Options
    // ----------------------------------------------------------------------------------------------
    // See ** https://github.com/briangonzalez/jquery.pep.js ** for fully documented options.
    // It was too hard to manage options here and in the readme.
    // ----------------------------------------------------------------------------------------------
    initiate:                       function(){},
    start:                          function(){},
    drag:                           function(){},
    stop:                           function(){},
    rest:                           function(){},
    startThreshold:                 [0,0],
    debug:                          false,
    activeClass:                    'pep-active',
    multiplier:                     1,
    velocityMultiplier:             1.9,
    shouldPreventDefault:           true,
    allowDragEventPropagation:      true,
    stopEvents:                     '',
    hardwareAccelerate:             true,
    useCSSTranslation:              true,
    disableSelect:                  true,
    cssEaseString:                  "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
    cssEaseDuration:                750,
    shouldEase:                     true,
    droppable:                      false,
    droppableActiveClass:           'pep-dpa',
    overlapFunction:                false,
    constrainTo:                    false,
    removeMargins:                  true,
    place:                          true,
    deferPlacement:                 false,
    axis:                           null,
    forceNonCSS3Movement:           false,
      handle:                 false
  };

  //  ---------------------------------
  //  -----  Our main Pep object  -----
  //  ---------------------------------
  function Pep( el, options ) {

    this.name = pluginName;


    //  merge in defaults
    this.defaults   = defaults;
    this.options    = $.extend( {}, this.defaults, options) ;

      // reference to our DOM object
      // and it's jQuery equivalent.
      this.el         = el;
      this.$el        = $(el);
      this.$target    = this.options.handle ? this.$el.find(this.options.handle) : this.$el;
      this.$movable   = this.options.handle ? this.$el.add( this.$target ) : this.$el;

    // store document/body so we don't need to keep grabbing them
    // throughout the code
    this.$document  = $(this.$el[0].ownerDocument);
    this.$body      = this.$document.find('body');

    //  Create our triggers based on touch/click device
    this.moveTrigger  = "MSPointerMove touchmove mousemove";
    this.startTrigger = "MSPointerDown touchstart mousedown";
    this.stopTrigger  = "MSPointerUp touchend mouseup";

    this.stopEvents   = [ this.stopTrigger, this.options.stopEvents ].join(' ');

    if ( this.options.constrainTo === 'parent' ) {
      this.$container = this.$el.parent();
    } else if ( this.options.constrainTo === 'window' ) {
      this.$container = this.$document;
    }

    // IE need this
    if ( this.isPointerEventCompatible() )
      this.applyMSDefaults();

    this.CSSEaseHash    = this.getCSSEaseHash();
    this.scale          = 1;
    this.started        = false;
    this.disabled       = false;
    this.resetVelocityQueue();

    this.init();
  }

  //  init();
  //    initialization logic
  //    you already have access to the DOM el and the options via the instance,
  //    e.g., this.el and this.options
  Pep.prototype.init = function () {
    var self = this;

    if ( this.options.debug )
      this.buildDebugDiv();

    if ( this.options.disableSelect )
      this.disableSelect();

    // position the parent & place the object, if necessary.
    if ( this.options.place && !this.options.deferPlacement ) {
      this.positionParent();
      this.placeObject();
    }

    this.ev = {};       // to store our event movements
    this.pos = {};      // to store positions
    this.subscribe();
  };

  //  subscribe();
  //    useful in the event we want to programmatically
  //    interact with our Pep object.
  //      e.g.:     $('#pep').trigger('stop')
  Pep.prototype.subscribe = function () {
    var self = this;

    // Subscribe to our start event
      this.$target.bind( this.startTrigger, function(ev){
      self.handleStart(ev);
    });

    // Subscribe to our stop event
    this.$document.bind( this.stopEvents, function(ev) {
      self.handleStop(ev);
    });

    // Subscribe to our move event
    this.$document.bind( this.moveTrigger, function(ev){
      self.moveEvent = ev;
    });
  };

  //  handleStart();
  //    once this.startTrigger occurs, handle all of the logic
  //    that must go on. This is where Pep's heavy lifting is done.
  Pep.prototype.handleStart = function(ev) {
    var self = this;

            // only continue chugging if our start event is a valid move event.
            if ( this.isValidMoveEvent(ev) && !this.disabled ){

                    // IE10 Hack. Me not happy.
                    if ( this.isPointerEventCompatible() && ev.preventManipulation )
                      ev.preventManipulation();

                    // normalize event
                    ev = this.normalizeEvent(ev);

                    // position the parent & place the object, if necessary.
                    if ( this.options.place && this.options.deferPlacement ) {
                      this.positionParent();
                      this.placeObject();
                    }

                    // log it
                    this.log({ type: 'event', event: ev.type });

                    // hardware accelerate, if necessary.
                    if ( this.options.hardwareAccelerate && !this.hardwareAccelerated ) {
                      this.hardwareAccelerate();
                      this.hardwareAccelerated = true;
                    }

                    // fire user's initiate event.
                    this.options.initiate.call(this, ev, this);

                    // cancel the rest timeout
                    clearTimeout( this.restTimeout );

                    // add active class and reset css animation, if necessary
                    this.$el.addClass( this.options.activeClass );
                    this.removeCSSEasing();

                    // store x & y values for later use
                    this.startX = this.ev.x = ev.pep.x;
                    this.startY = this.ev.y = ev.pep.y;

                    // store the initial touch/click event, used to calculate the inital delta values.
                    this.startEvent = this.moveEvent = ev;

                    // make object active, so watchMoveLoop starts looping.
                    this.active     = true;

                    // preventDefault(), is necessary
                    if ( this.options.shouldPreventDefault )
                      ev.preventDefault();

                    // allow / disallow event bubbling
                    if ( !this.options.allowDragEventPropagation )
                      ev.stopPropagation();

                    // animation loop to ensure we don't fire
                    // too many unneccessary repaints
                    (function watchMoveLoop(){
                        if ( !self.active ) return;
                        self.handleMove();
                        self.requestAnimationFrame( watchMoveLoop );
                    })($, self);

            }
  };

  //  handleMove();
  //    the logic for when the move events occur
  Pep.prototype.handleMove = function() {

            // setup our event object
            if ( typeof(this.moveEvent) === 'undefined' )
              return;

            // get our move event's x & y
            var ev      = this.normalizeEvent( this.moveEvent );
            var curX    = ev.pep.x;
            var curY    = ev.pep.y;

            // last in, first out (LIFO) queue to help us manage velocity
            this.addToLIFO( { time: ev.timeStamp, x: curX, y: curY } );

            // calculate values necessary to moving
            var dx, dy;

            if ( this.startTrigger.split(' ').indexOf(ev.type) > -1  ){
              dx = 0;
              dy = 0;
            } else{
              dx = curX - this.ev.x;
              dy = curY - this.ev.y;
            }

            this.dx   = dx;
            this.dy   = dy;
            this.ev.x = curX;
            this.ev.y = curY;

            // no movement in either direction -- so return
            if (dx === 0 && dy === 0){
              this.log({ type: 'event', event: '** stopped **' });
              return;
            }

            // check if object has moved past X/Y thresholds
            // if so, fire users start event
            var initialDx  = Math.abs(this.startX - curX);
            var initialDy  = Math.abs(this.startY - curY);
            if ( !this.started && ( initialDx > this.options.startThreshold[0] || initialDy > this.options.startThreshold[1] ) ){
              this.started = true;
              this.$el.addClass('pep-start');
              this.options.start.call(this, this.startEvent, this);
            }

            // Calculate our drop regions
            if ( this.options.droppable ) {
              this.calculateActiveDropRegions();
            }

            // fire user's drag event.
            var continueDrag = this.options.drag.call(this, ev, this);

            if ( continueDrag === false ) {
              this.resetVelocityQueue();
              return;
            }

            // log the move trigger & event position
            this.log({ type: 'event', event: ev.type });
            this.log({ type: 'event-coords', x: this.ev.x, y: this.ev.y });
            this.log({ type: 'velocity' });

            var hash = this.handleConstraint(dx, dy);

            // if using not using CSS transforms, move object via absolute position
            if ( !this.shouldUseCSSTranslation() ){
              var xOp     = ( dx >= 0 ) ? "+=" + Math.abs(dx/this.scale)*this.options.multiplier : "-=" + Math.abs(dx/this.scale)*this.options.multiplier;
              var yOp     = ( dy >= 0 ) ? "+=" + Math.abs(dy/this.scale)*this.options.multiplier : "-=" + Math.abs(dy/this.scale)*this.options.multiplier;

              if ( this.options.constrainTo ) {
                xOp = (hash.x !== false) ? hash.x : xOp;
                yOp = (hash.y !== false) ? hash.y : yOp;
              }

              this.moveTo(xOp, yOp);
            }
            else {

              dx = (dx/this.scale)*this.options.multiplier;
              dy = (dy/this.scale)*this.options.multiplier;

              if ( this.options.constrainTo ) {
                dx = (hash.x === false) ? dx : 0 ;
                dy = (hash.y === false) ? dy : 0 ;
              }
              this.moveToUsingTransforms( dx, dy );
            }
  };

  //  handleStop();
  //    the logic for when the stop events occur
  Pep.prototype.handleStop = function(ev) {

            // no need to handle stop event if we're not active
            if (!this.active)
              return;

            // log it
            this.log({ type: 'event', event: ev.type });

            // make object inactive, so watchMoveLoop returns
            this.active = false;

            // remove our start class
            this.$el.removeClass('pep-start')
                    .addClass('pep-ease');

            // Calculate our drop regions
            if ( this.options.droppable ) {
              this.calculateActiveDropRegions();
            }

            // ease the object, if necessary
            if (this.options.shouldEase)
              this.ease(ev);

            // fire user's stop event.
            this.options.stop.call(this, ev, this);

            // this must be set to false after
            // the user's stop event is called, so the dev
            // has access to it.
            this.started = false;

            // reset the velocity queue
            this.resetVelocityQueue();

  };

  //  ease();
  //    used in conjunction with the LIFO queue
  //    to ease the object after stop
  Pep.prototype.ease = function(ev){

            var pos       = this.$el.position();
            var vel       = this.velocity();
            var dt        = this.dt;
            var x         = (vel.x/this.scale) * this.options.multiplier;
            var y         = (vel.y/this.scale) * this.options.multiplier;

            var hash      = this.handleConstraint(x, y);

            // ✪  Apply the CSS3 animation easing magic  ✪
            if ( this.cssAnimationsSupported() )
              this.$movable.css( this.getCSSEaseHash() );

            var xOp = ( vel.x > 0 ) ? "+=" + x : "-=" + Math.abs(x);
            var yOp = ( vel.y > 0 ) ? "+=" + y : "-=" + Math.abs(y);

            if ( this.options.constrainTo ) {
              xOp = (hash.x !== false) ? hash.x : xOp;
              yOp = (hash.y !== false) ? hash.y : yOp;
            }

            // ease it via JS, the last true tells it to animate.
            var jsAnimateFallback = !this.cssAnimationsSupported() || this.options.forceNonCSS3Movement;
                   this.moveTo(xOp, yOp, jsAnimateFallback);

            // when the rest occurs, remove active class and call
            // user's rest event.
            var self = this;
            this.restTimeout = setTimeout( function(){

              // Calculate our drop regions
              if ( self.options.droppable ) {
                self.calculateActiveDropRegions();
              }

              // call users rest event.
              self.options.rest.call(self, ev, self);

              // remove active class
              self.$el.removeClass( [self.options.activeClass, 'pep-ease'].join(' ') );

            }, this.options.cssEaseDuration );

  };

  // normalizeEvent()
  Pep.prototype.normalizeEvent = function(ev) {
      ev.pep        = {};

      if ( this.isPointerEventCompatible() || !this.isTouch(ev) ) {
        ev.pep.x      = ev.originalEvent.pageX;
        ev.pep.y      = ev.originalEvent.pageY;
        ev.pep.type   = ev.type;
      }
      else {
        ev.pep.x      = ev.originalEvent.touches[0].pageX;
        ev.pep.y      = ev.originalEvent.touches[0].pageY;
        ev.pep.type   = ev.type;
      }

       return ev;
   };

  // resetVelocityQueue()
  //
  Pep.prototype.resetVelocityQueue = function() {
    this.velocityQueue = new Array(5);
  };

  //  moveTo();
  //    move the object to an x and/or y value
  //    using jQuery's .css function -- this fxn uses the
  //    .css({top: "+=20", left: "-=30"}) syntax
  Pep.prototype.moveTo = function(x,y, animate) {

    animate = ( animate === false || typeof(animate) === 'undefined' ) ?
      false : true;

    if ( this.options.axis  === 'x' ){
      y = "+=0";
    }
    else if ( this.options.axis  === 'y' ){
      x = "+=0";
    }

    var animateDuration = 300;
    this.log({ type: 'delta', x: x, y: y });
    if ( animate ) {
      this.$movable.animate({ top: y, left: x }, animateDuration, 'easeOutCirc', {queue: false});
    } else{
      this.$movable.stop(true, false).css({ top: y , left: x });
    }

  };

  //  moveToUsingTransforms();
  //    move the object to an x and/or y value
  Pep.prototype.moveToUsingTransforms = function(x,y) {

    // only move along single axis, if necessary
    if ( this.options.axis  === 'x' )
      y = 0;

    if ( this.options.axis  === 'y' )
      x = 0;

    // Check for our initial values if we don't have them.
    var matrixArray  = this.matrixToArray( this.matrixString() );
    if ( !this.cssX )
      this.cssX = parseInt(matrixArray[4], 10);

    if ( !this.cssY )
      this.cssY = parseInt(matrixArray[5], 10);

    // CSS3 transforms are additive from current position
    this.cssX = this.cssX + x;
    this.cssY = this.cssY + y;

    this.log({ type: 'delta', x: x, y: y });

    matrixArray[4]    = this.cssX;
    matrixArray[5]    = this.cssY;

    this.translation  = this.arrayToMatrix( matrixArray );

    this.$movable.css({
        '-webkit-transform': this.translation,
           '-moz-transform': this.translation,
            '-ms-transform': this.translation,
             '-o-transform': this.translation,
                'transform': this.translation  });
  };

  // 3 helper functions for working with the
  // objects CSS3 transforms
  // matrixString
  // matrixToArray
  // arrayToMatrix
  Pep.prototype.matrixString = function() {

    var validMatrix = function(o){
      return !( !o || o === 'none' || o.indexOf('matrix') === -1);
    };

    var matrix = "matrix(1, 0, 0, 1, 0, 0)";

    if ( validMatrix( this.$movable.css('-webkit-transform') ) )
      matrix = this.$movable.css('-webkit-transform');

    if ( validMatrix( this.$movable.css('-moz-transform') ) )
      matrix = this.$movable.css('-moz-transform');

    if ( validMatrix( this.$movable.css('-ms-transform') ) )
      matrix = this.$movable.css('-ms-transform');

    if ( validMatrix( this.$movable.css('-o-transform') ) )
      matrix = this.$movable.css('-o-transform');

    if ( validMatrix( this.$movable.css('transform') ) )
      matrix = this.$movable.css('transform');

    return matrix;
  };

  Pep.prototype.matrixToArray = function(str) {
      return str.split('(')[1].split(')')[0].split(',');
  };

  Pep.prototype.arrayToMatrix = function(array) {
      return "matrix(" +  array.join(',')  + ")";
  };

  //  addToLIFO();
  //    a Last-In/First-Out array of the 5 most recent
  //    velocity points, which is used for easing
  Pep.prototype.addToLIFO = function(val){
    // last in, first out
    var arr = this.velocityQueue;
    arr = arr.slice(1, arr.length);
    arr.push(val);
    this.velocityQueue = arr;
  };

  //  velocity();
  //    using the LIFO, calculate velocity and return
  //    velocity in each direction (x & y)
  Pep.prototype.velocity = function(){
    var sumX = 0;
    var sumY = 0;

    for ( var i = 0; i < this.velocityQueue.length -1; i++  ){
      if ( this.velocityQueue[i] ){
        sumX        += (this.velocityQueue[i+1].x - this.velocityQueue[i].x);
        sumY        += (this.velocityQueue[i+1].y - this.velocityQueue[i].y);
        this.dt     = ( this.velocityQueue[i+1].time - this.velocityQueue[i].time );
      }
    }

    // return velocity in each direction.
    return { x: sumX*this.options.velocityMultiplier, y: sumY*this.options.velocityMultiplier};
  };

  //  requestAnimationFrame();
  //    requestAnimationFrame Polyfill
  //    More info:
  //    http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  Pep.prototype.requestAnimationFrame = function(callback) {
    return  window.requestAnimationFrame        && window.requestAnimationFrame(callback)         ||
            window.webkitRequestAnimationFrame  && window.webkitRequestAnimationFrame(callback)   ||
            window.mozRequestAnimationFrame     && window.mozRequestAnimationFrame(callback)      ||
            window.oRequestAnimationFrame       && window.mozRequestAnimationFrame(callback)      ||
            window.msRequestAnimationFrame      && window.msRequestAnimationFrame(callback)       ||
            window.setTimeout(callback, 1000 / 60);
  };

  //  positionParent();
  //    add the right positioning to the parent object
  Pep.prototype.positionParent = function() {

    if ( !this.options.constrainTo || this.parentPositioned )
      return;

    this.parentPositioned = true;

    // make `relative` parent if necessary
    if ( this.options.constrainTo === 'parent' ) {
      this.$container.css({ position: 'relative' });
    } else if ( this.options.constrainTo === 'window' && this.$container.get(0).nodeName !== "#document" &&
                this.$container.css('position') !== 'static' )
    {
      this.$container.css({ position: 'static' });
    }

  };

  //  placeObject();
  //    add the right positioning to the object
  Pep.prototype.placeObject = function() {

    if ( this.objectPlaced )
      return;

    this.objectPlaced = true;
      console.log(this.$movable)
    this.offset = (this.options.constrainTo === 'parent' || this.hasNonBodyRelative() ) ?
                    this.$movable.position() : this.$movable.offset();

    // better to leave absolute position alone if
    // it already has one.
    if ( parseInt( this.$movable.css('left'), 10 ) )
      this.offset.left = this.$movable.css('left');

    if ( parseInt( this.$movable.css('top'), 10 ) )
      this.offset.top = this.$movable.css('top');

    if ( this.options.removeMargins )
      this.$movable.css({margin: 0});

    this.$movable.css({
      position:   'absolute',
      top:        this.offset.top,
      left:       this.offset.left
    });

  };

  //  hasNonBodyRelative()
  //    returns true if any parent other than the body
  //    has relative positioning
  Pep.prototype.hasNonBodyRelative = function() {
    return this.$el.parents().filter(function() {
        var $this = $(this);
        return $this.is('body') || $this.css('position') === 'relative';
    }).length > 1;
  };

  //  setScale()
  //    set the scale of the object being moved.
  Pep.prototype.setScale = function(val) {
    this.scale = val;
  };

  //  setMultiplier()
  //    set the multiplier of the object being moved.
  Pep.prototype.setMultiplier = function(val) {
    this.options.multiplier = val;
  };

  //  removeCSSEasing();
  //    remove CSS easing properties, if necessary
  Pep.prototype.removeCSSEasing = function() {
    if ( this.cssAnimationsSupported() )
      this.$movable.css( this.getCSSEaseHash(true) );
  };

  //  disableSelect();
  //    add the property which causes the object
  //    to not be selected user drags over text areas
  Pep.prototype.disableSelect = function() {

    this.$movable.css({
      '-webkit-touch-callout' : 'none',
        '-webkit-user-select' : 'none',
         '-khtml-user-select' : 'none',
           '-moz-user-select' : 'none',
            '-ms-user-select' : 'none',
                'user-select' : 'none'
    });

  };

  //  handleConstraint();
  //    returns a hash of where to move to
  //    when we constrain to parent/window
  Pep.prototype.handleConstraint = function(dx, dy) {
    var pos               = this.$el.position();
    this.pos.x            = pos.left;
    this.pos.y            = pos.top;
    var hash              = { x: false, y: false };

    var upperYLimit, upperXLimit, lowerXLimit, lowerYLimit;

    // log our positions
    this.log({ type: "pos-coords", x: this.pos.x, y: this.pos.y});

    if ( $.isArray( this.options.constrainTo ) ) {

      if ( this.options.constrainTo[3] !== undefined && this.options.constrainTo[1] !== undefined ) {
        upperXLimit     = this.options.constrainTo[1];
        lowerXLimit     = this.options.constrainTo[3];
      }
      if ( this.options.constrainTo[0] !== false && this.options.constrainTo[2] !== false ) {
        upperYLimit       = this.options.constrainTo[2];
        lowerYLimit       = this.options.constrainTo[0];
      }

      // is our object trying to move outside lower X & Y limits?
      if ( this.pos.x + dx < lowerXLimit)     hash.x = lowerXLimit;
      if ( this.pos.y + dy < lowerYLimit)     hash.y = lowerYLimit;

    } else if ( typeof this.options.constrainTo === 'string' ) {
      upperXLimit       = this.$container.width()  - this.$el.outerWidth();
      upperYLimit       = this.$container.height() - this.$el.outerHeight();
      // is our object trying to move outside lower X & Y limits?
      if ( this.pos.x + dx < 0 )              hash.x = 0;
      if ( this.pos.y + dy < 0 )              hash.y = 0;
    }

    // is our object trying to move outside upper X & Y limits?
    if ( this.pos.x + dx > upperXLimit )    hash.x = upperXLimit;
    if ( this.pos.y + dy > upperYLimit )    hash.y = upperYLimit;

    return hash;
  };

  //  getCSSEaseHash();
  //    returns a hash of params used in conjunction
  //    with this.options.cssEaseString
  Pep.prototype.getCSSEaseHash = function(reset){
    if ( typeof(reset) === 'undefined' ) reset = false;

    var cssEaseString;
    if (reset){
      cssEaseString = '';
    } else if ( this.CSSEaseHash ) {
      return this.CSSEaseHash;
    } else {
      cssEaseString = ['all', this.options.cssEaseDuration + 'ms', this.options.cssEaseString].join(' ');
    }

    return {
                  '-webkit-transition'   : cssEaseString,   // chrome, safari, etc.
                     '-moz-transition'   : cssEaseString,   // firefox
                      '-ms-transition'   : cssEaseString,   // microsoft
                       '-o-transition'   : cssEaseString,   // opera
                          'transition'   : cssEaseString    // future
          };
  };

  // calculateActiveDropRegions()
  //    sets parent droppables of this.
  Pep.prototype.calculateActiveDropRegions = function() {
    var self = this;
    this.activeDropRegions = [];

    $.each( $(this.options.droppable), function(idx, el){
      var $el = $(el);
      if ( self.isOverlapping($el, self.$el) ){
        $el.addClass(self.options.droppableActiveClass);
        self.activeDropRegions.push($el);
      } else {
        $el.removeClass(self.options.droppableActiveClass);
      }
    });

  };

  //  isOverlapping();
  //    returns true if element a over
  Pep.prototype.isOverlapping = function($a,$b) {

    if ( this.options.overlapFunction ) {
      return this.options.overlapFunction($a,$b);
    }

    var rect1 = $a[0].getBoundingClientRect();
    var rect2 = $b[0].getBoundingClientRect();

    return !( rect1.right   < rect2.left  ||
              rect1.left    > rect2.right ||
              rect1.bottom  < rect2.top   ||
              rect1.top     > rect2.bottom  );
  };

  //  isTouch();
  //    returns whether or not event is a touch event
  Pep.prototype.isTouch = function(ev){
    return ev.type.search('touch') > -1;
  };

  // isPointerEventCompatible();
  //    return whether or note our device is pointer
  //    event compatible; typically means where on a
  //    touch Win8 device
  Pep.prototype.isPointerEventCompatible = function() {
    return ("MSPointerEvent" in window);
  };

  // applyMSDefaults();
  Pep.prototype.applyMSDefaults = function(first_argument) {
    this.$body.css({
        '-ms-touch-action' :    'none',
        'touch-action' :        'none',
        '-ms-scroll-chaining':  'none',
        '-ms-scroll-limit':     '0 0 0 0',
        'overflow':             'hidden'
    });
  };

  //  isValidMoveEvent();
  //    returns true if we're on a non-touch device -- or --
  //    if the event is a non-pinch event on a touch device
  Pep.prototype.isValidMoveEvent = function(ev){
    if ( !this.isTouch(ev) || ( this.isTouch(ev) && ev.originalEvent.hasOwnProperty('touches') && ev.originalEvent.touches.length === 1 ) ){
      return true;
    } else{
      return false;
    }
  };

  //  shouldUseCSSTranslation();
  //    return true if we should use CSS transforms for move the object
  Pep.prototype.shouldUseCSSTranslation = function() {

    if ( typeof(this.useCSSTranslation) !== "undefined" )
      return this.useCSSTranslation;

    var useCSSTranslation = false;

    if ( !this.options.useCSSTranslation || ( typeof(Modernizr) !== "undefined" && !Modernizr.csstransforms)){
      useCSSTranslation = false;
    }
    else{
      useCSSTranslation = true;
    }

    this.useCSSTranslation = useCSSTranslation;
    return useCSSTranslation;
  };

  //  cssAnimationsSupported():
  //    returns true if the browser supports CSS animations
  //    which are used for easing..
  Pep.prototype.cssAnimationsSupported = function() {

    if ( typeof(this.cssAnimationsSupport) !== "undefined" ){
      return this.cssAnimationsSupport;
    }

    // If the page has Modernizr, let them do the heavy lifting.
    if ( ( typeof(Modernizr) !== "undefined" && Modernizr.cssanimations) ){
      this.cssAnimationsSupport = true;
      return true;
    }

    var animation = false,
        elm = document.createElement('div'),
        animationstring = 'animation',
        keyframeprefix = '',
        domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
        pfx  = '';

    if( elm.style.animationName ) { animation = true; }

    if( animation === false ) {
      for( var i = 0; i < domPrefixes.length; i++ ) {
        if( elm.style[ domPrefixes[i] + 'AnimationName' ] !== undefined ) {
          pfx = domPrefixes[ i ];
          animationstring = pfx + 'Animation';
          keyframeprefix = '-' + pfx.toLowerCase() + '-';
          animation = true;
          break;
        }
      }
    }

    this.cssAnimationsSupport = animation;
    return animation;
  };

  //  hardwareAccelerate();
  //    add fool-proof CSS3 hardware acceleration.
  Pep.prototype.hardwareAccelerate = function() {
    this.$movable.css({

      '-webkit-backface-visibility':  'hidden',
      'backface-visibility':          'hidden'
    });
   };

  //  getMovementValues();
  //    returns object pos, event position, and velocity in each direction.
  Pep.prototype.getMovementValues = function() {
    return { ev: this.ev, pos: this.pos, velocity: this.velocity() };
   };

  //  buildDebugDiv();
  //    Create a little div in the lower right corner of the window
  //    for extra info about the object currently moving
  Pep.prototype.buildDebugDiv = function() {

    // Build the debugDiv and it's inner HTML -- if necessary
    var $debugDiv;
    if ( $('#pep-debug').length === 0 ){
      $debugDiv = $('<div></div>');
      $debugDiv
        .attr('id', 'pep-debug')
        .append("<div style='font-weight:bold; background: red; color: white;'>DEBUG MODE</div>")
        .append("<div id='pep-debug-event'>no event</div>")
        .append("<div id='pep-debug-ev-coords'>event coords: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>")
        .append("<div id='pep-debug-pos-coords'>position coords: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>")
        .append("<div id='pep-debug-velocity'>velocity: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>")
        .append("<div id='pep-debug-delta'>&Delta; movement: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>")
        .css({
          position:   'fixed',
          bottom:     5,
          right:      5,
          zIndex:     99999,
          textAlign:  'right',
          fontFamily: 'Arial, sans',
          fontSize:   10,
          border:     '1px solid #DDD',
          padding:    '3px',
          background: 'white',
          color:      '#333'
        });
    }

    var self = this;
    setTimeout(function(){
      self.debugElements = {
        $event:      $("#pep-debug-event"),
        $velocityX:  $("#pep-debug-velocity .pep-x"),
        $velocityY:  $("#pep-debug-velocity .pep-y"),
        $dX:         $("#pep-debug-delta .pep-x"),
        $dY:         $("#pep-debug-delta .pep-y"),
        $evCoordsX:  $("#pep-debug-ev-coords .pep-x"),
        $evCoordsY:  $("#pep-debug-ev-coords .pep-y"),
        $posCoordsX: $("#pep-debug-pos-coords .pep-x"),
        $posCoordsY: $("#pep-debug-pos-coords .pep-y")
      };
    }, 0);

    $('body').append( $debugDiv );
  };

  // log()
  Pep.prototype.log = function(opts) {
    if ( !this.options.debug ) return;

    switch (opts.type){
    case "event":
      this.debugElements.$event.text(opts.event);
      break;
    case "pos-coords":
      this.debugElements.$posCoordsX.text(opts.x);
      this.debugElements.$posCoordsY.text(opts.y);
      break;
    case "event-coords":
      this.debugElements.$evCoordsX.text(opts.x);
      this.debugElements.$evCoordsY.text(opts.y);
      break;
    case "delta":
      this.debugElements.$dX.text(opts.x);
      this.debugElements.$dY.text(opts.y);
      break;
    case "velocity":
      var vel = this.velocity();
      this.debugElements.$velocityX.text( Math.round(vel.x) );
      this.debugElements.$velocityY.text( Math.round(vel.y) );
      break;
    }
  };

  // toggle()
  //  toggle the pep object
  Pep.prototype.toggle = function(on) {
    if ( typeof(on) === "undefined"){
      this.disabled = !this.disabled;
    }
    else {
      this.disabled = !on;
    }
  };

  //  wrap it
  //    A really lightweight plugin wrapper around the constructor,
  //    preventing against multiple instantiations.
  $.fn[pluginName] = function ( options ) {

    return this.each(function () {
      if (!$.data(this, 'plugin_' + pluginName)) {
        var pepObj = new Pep( this, options );
        $.data(this, 'plugin_' + pluginName, pepObj);
        $.pep.peps.push(pepObj);
      }
    });
  };

  //  The   _   ___ ___
  //       /_\ | _ \_ _|
  //      / _ \|  _/| |
  //     /_/ \_\_| |___|
  //
  $.pep = {};
  $.pep.peps = [];
  $.pep.toggleAll = function(on){
    $.each(this.peps, function(index, pepObj){
      pepObj.toggle(on);
    });
  };

  $.pep.unbind = function($obj){
    var pep = $obj.data('plugin_' + pluginName);

    if ( typeof pep === 'undefined' )
      return;

    pep.toggle(false);
    $obj.removeData('plugin_' + pluginName);
  };

}(jQuery, window));





define("pep", function(){});

define('mixins/deviceEditing',['Cache','pep'], function (Backbone) {
    'use strict';

    var EditView = Backbone.View.extend({
        tagName: 'div',
        events: {
            'click .edit': 'gotoEditing'
        },
        initialize: function (options) {
            this.sandbox = options.sandbox;
            this.parentView = options.parentView;
            this.render();
        },
        render: function () {
            this.$el.addClass('editing');
            this.$el.append('<anchor class="edit">EDIT</anchor>');
            if($('html').hasClass('web') || $('html').hasClass('android')){
                this.$el.append('<anchor class="order">ORDER</anchor>');
            }
            this.delegateEvents();
        },
        gotoEditing: function () {
            this.sandbox.emit('edit',this.parentView);
        },
        show: function(){
            this.$el.show();
        },
        hide: function(){
            this.$el.hide();
        }
    });

    var exports = {
        startEditing: function () {
            this.$('.power').hide();
            if(!this.editView){
                this.editView = new EditView({model: this.model, sandbox: this.sandbox, parentView:this});
                this.editView.$el.appendTo(this.$el);
            }
            this.editView.show();
            this.isEditing = true;

        },
        cancelEditing: function () {
            /* TODO: hide this edit view*/
            this.editView.hide();
            this.$('.power').show();
            this.isEditing = false;

        }
    };

    return exports;

});
define('extensions/views/backbone.tileanddrawer', ['Cache', 'mixins/deviceEditing', 'plugins/xml2json'], function(Backbone, deviceEditing, XJ) {

    'use strict';

    Backbone.TileAndDrawerView = Backbone.View.extend({});
    Backbone.TileAndDrawerView.prototype = _.extend(_.clone(Backbone.View.prototype), {
        initialize: function() {
            var self = this;
            var modelAttributes;
            var extendedOptions = this.options.extendedOptions;

            if (!this.config) {
                this.config = {};
            }

            for (var i = 0; i < window.localStorage.length; i++) {
                var re = new RegExp(this.name);
                if (window.localStorage.key(i).match(re)) {
                    window.localStorage.removeItem(window.localStorage.key(i));
                }
            }

            if (!this.isRendered) {
                this.sandbox.path = this.options.ref.replace(/main/, '');
                this.sandbox.config = this.config;

                // this.sandbox.database = new this.sandbox.data.Database({sandbox:this.sandbox});

                this.styles = this.styles.replace(/\.\.\//g, this.sandbox.path + '/');

                this.stylesheet = new this.sandbox.util.Stylesheet(this.name, this.styles);

                this.sandbox.model = new this.Model();
                this.sandbox.model.sandbox = this.sandbox;

                this.sandbox.model.baseObject = extendedOptions;
                this.sandbox.model.set(extendedOptions.properties);
                this.sandbox.model.set(extendedOptions.attributes);
                this.sandbox.model.set(extendedOptions.deviceCapabilities);

                //this widget can be part of a group
                if (this.sandbox.config.groupable) {
                    this.setAsGroupable();
                }

                //this widget is part of a group
                if (this.sandbox.model.baseObject.component.groupSandbox) {
                    this.setAsGroupMember();
                }

                if (extendedOptions.attributes) {
                    this.sandbox.model.set(extendedOptions.attributes);
                }

                //store last values coming from device/cloud
                this.sandbox.model.preserveState();
            }


            //this will keep groupOnly devices from creating separate tile and drawers, when they will ever only be part of a group and don't need them.
            if (!window.isSmartCache || this.isGroupMaster || !this.isGroupMember || (this.isGroupMember && this.sandbox.config && !this.sandbox.config.groupOnly)) {
                // THIS SECTION IS FOR ANDROID/WEB

                this.tileView = new this.Tile({
                    sandbox: this.sandbox,
                    parentView: this,
                    extendedOptions: extendedOptions
                });
                if (this.Drawer) {
                    this.drawerView = new this.Drawer({
                        sandbox: this.sandbox,
                        extendedOptions: extendedOptions
                    });
                }
            }
            this.listen();


            this.$el.addClass('isSmartFramework');
            this.$el.addClass(this.name);

            var information = this.sandbox.model.baseObject.information;

            if (information.modelCode) {
                this.$el.addClass(information.modelCode);
            }

            if (information.productName) {
                this.$el.addClass(information.productName);
            }

            this.render();

        },
        /**
         * this tile can be grouped with similar tiles. uses modelname right now, might need to use something else for device/capabilities grouping
         */
        setAsGroupable: function() {
            var self = this;
            var groupProperties = '';
            if (this.sandbox.config.groupOn) {
                this.sandbox.config.groupOn.forEach(function(groupVar) {
                    groupProperties += '-' + self.sandbox.model.baseObject.information[groupVar];
                });
            }

            if (this.sandbox.config.groupKeys) {
                this.sandbox.config.groupKeys.forEach(function(key) {
                    groupProperties += '-' + key;
                });
            }
            DEBUG && console.log('GROUP PROPERTIES:' + groupProperties);
            this.sandbox.model.baseObject.properties.groupable = groupProperties;
            this.$el.attr('data-groupable', groupProperties);
            this.$el.attr('data-groupID', this.sandbox.model.get('groupID'));

        },
        /**
         * prepare the tile and drawer to be part of a group
         */
        setAsGroupMember: function() {
            var self = this;
            this.isGroupMember = true;

            if (this.sandbox.component.groupMaster) {
                this.isGroupMaster = true;
                this.sandbox.on('drawer.open', function() {
                    self.sandbox.component.groupSandbox.emit('drawer.open');
                });
                this.$el.addClass('isGroupMember');
                /** the master is what is visible on the UI. State is changed through the master, pushed up to the group controller, and then reflected to other grouped devices. **/
            }
        },
        listen: function() {
            var self = this;
            this.sandbox.on('deviceUpdated', this.update);
        },
        update: function(resp) {
            //take the existing baseObject and extend each part of it, then set to the model
            var params;
            var baseObject = this.model.baseObject;

            var checkResponse = function(resp) {
                /*var changed = {};
                _.each(resp, function(value, key) {
                    if (value != '') {
                        changed[key] = value;
                    }
                })*/ //take this out for now - it was causing a problem
                return resp;
            }

            if (resp.attributes) {
                params = checkResponse(resp.attributes);
                _.extend(baseObject.attributes, params);
                this.model.set(baseObject.attributes);
            }

            if (resp.deviceCapabilities) {
                params = checkResponse(resp.deviceCapabilities);
                _.extend(baseObject.deviceCapabilities, params);
                this.model.set(baseObject.deviceCapabilities);
            }

            if (resp.properties) {
                params = checkResponse(resp.properties);
                _.extend(baseObject.properties, params);
                this.model.set(baseObject.properties);
            }

            if (resp.information) {
                params = checkResponse(resp.information);
                _.extend(baseObject.information, params);
                this.model.set(baseObject.information);
            }

            //store last values coming from device/cloud
            this.model.preserveState();
        },
        render: function() {
            var self = this;

            this.sandbox.view = this;
            if (this.tileView) {
                this.tileView.initialRender();
                this.tileView.render();
                this.tileView.parentView = this;
                this.$el.prepend(this.tileView.$el);
            }
            this.$el.removeClass('hidden').show();

            // this.drawerView.render();
            if (this.Drawer && this.drawerView) {
//                if (!window.isSmartCache) {
//                    this.$el.append(this.drawerView.$el);
//                } else {
                    this.drawerView.parentView = this;
                    this.drawerView.$el.addClass('isSmartFramework').addClass(this.name);
                    this.$drawerParentView = $('<div class="smart-drawer-parent" />');
                    this.$drawerParentView.append(this.drawerView.$el);
                    $('.container').append(this.$drawerParentView);
//                }
            }

            this.sandbox.emit('rendered');
            this.isRendered = true;


//            if (window.devicelistEvents) {
//                window.devicelistEvents.emit('packageLoaded', {
//                    udn: self.$el.attr('wemo-device-udn'),
//                    el: self.$el,
//                    sandbox: self.sandbox
//                });
//            }


        }
    });

    return {
        initialize: function(app) {
            app.core.registerWidgetType('TileAndDrawer', Backbone.TileAndDrawerView.prototype);
        }
    };
});
/**
 * Lawnchair!
 * ---
 * clientside json store
 *
 */
var Lawnchair = function (options, callback) {
    // ensure Lawnchair was called as a constructor
    if (!(this instanceof Lawnchair)) return new Lawnchair(options, callback);

    // lawnchair requires json
    if (!JSON) throw 'JSON unavailable! Include http://www.json.org/json2.js to fix.'
    // options are optional; callback is not
    if (arguments.length <= 2 && arguments.length > 0) {
        callback = (typeof arguments[0] === 'function') ? arguments[0] : arguments[1];
        options  = (typeof arguments[0] === 'function') ? {} : arguments[0];
    } else {
        throw 'Incorrect # of ctor args!'
    }
    // TODO perhaps allow for pub/sub instead?
    if (typeof callback !== 'function') throw 'No callback was provided';

    // default configuration
    this.record = options.record || 'record'  // default for records
    this.name   = options.name   || 'records' // default name for underlying store

    // mixin first valid  adapter
    var adapter
    // if the adapter is passed in we try to load that only
    if (options.adapter) {
        for (var i = 0, l = Lawnchair.adapters.length; i < l; i++) {
            if (Lawnchair.adapters[i].adapter === options.adapter) {
                adapter = Lawnchair.adapters[i].valid() ? Lawnchair.adapters[i] : undefined;
                break;
            }
        }
        // otherwise find the first valid adapter for this env
    }
    else {
        for (var i = 0, l = Lawnchair.adapters.length; i < l; i++) {
            adapter = Lawnchair.adapters[i].valid() ? Lawnchair.adapters[i] : undefined
            if (adapter) break
        }
    }

    // we have failed
    if (!adapter) throw 'No valid adapter.'

    // yay! mixin the adapter
    for (var j in adapter)
        this[j] = adapter[j]

    // call init for each mixed in plugin
    for (var i = 0, l = Lawnchair.plugins.length; i < l; i++)
        Lawnchair.plugins[i].call(this)

    // init the adapter
    this.init(options, callback)
}

Lawnchair.adapters = []

/**
 * queues an adapter for mixin
 * ===
 * - ensures an adapter conforms to a specific interface
 *
 */
Lawnchair.adapter = function (id, obj) {
    // add the adapter id to the adapter obj
    // ugly here for a  cleaner dsl for implementing adapters
    obj['adapter'] = id
    // methods required to implement a lawnchair adapter
    var implementing = 'adapter valid init keys save batch get exists all remove nuke'.split(' ')
        ,   indexOf = this.prototype.indexOf
    // mix in the adapter
    for (var i in obj) {
        if (indexOf(implementing, i) === -1) throw 'Invalid adapter! Nonstandard method: ' + i
    }
    // if we made it this far the adapter interface is valid
    // insert the new adapter as the preferred adapter
    Lawnchair.adapters.splice(0,0,obj)
}

Lawnchair.plugins = []

/**
 * generic shallow extension for plugins
 * ===
 * - if an init method is found it registers it to be called when the lawnchair is inited
 * - yes we could use hasOwnProp but nobody here is an asshole
 */
Lawnchair.plugin = function (obj) {
    for (var i in obj)
        i === 'init' ? Lawnchair.plugins.push(obj[i]) : this.prototype[i] = obj[i]
}

/**
 * helpers
 *
 */
Lawnchair.prototype = {

    isArray: Array.isArray,

    /**
     * this code exists for ie8... for more background see:
     * http://www.flickr.com/photos/westcoastlogic/5955365742/in/photostream
     */
    indexOf: function(ary, item, i, l) {
        if (ary.indexOf) return ary.indexOf(item)
        for (i = 0, l = ary.length; i < l; i++) if (ary[i] === item) return i
        return -1
    },

    // awesome shorthand callbacks as strings. this is shameless theft from dojo.
    lambda: function (callback) {
        return this.fn(this.record, callback)
    },

    // first stab at named parameters for terse callbacks; dojo: first != best // ;D
    fn: function (name, callback) {
        return typeof callback == 'string' ? new Function(name, callback) : callback
    },

    // returns a unique identifier (by way of Backbone.localStorage.js)
    // TODO investigate smaller UUIDs to cut on storage cost
    uuid: function () {
        var S4 = function () {
            return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
        }
        return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
    },

    // a classic iterator
    each: function (callback) {
        var cb = this.lambda(callback)
        // iterate from chain
        if (this.__results) {
            for (var i = 0, l = this.__results.length; i < l; i++) cb.call(this, this.__results[i], i)
        }
        // otherwise iterate the entire collection
        else {
            this.all(function(r) {
                for (var i = 0, l = r.length; i < l; i++) cb.call(this, r[i], i)
            })
        }
        return this
    }
// --
};
/**
 * dom storage adapter
 * ===
 * - originally authored by Joseph Pecoraro
 *
 */
//
// TODO does it make sense to be chainable all over the place?
// chainable: nuke, remove, all, get, save, all
// not chainable: valid, keys
//
Lawnchair.adapter('dom', (function() {
    var storage = window.localStorage
    // the indexer is an encapsulation of the helpers needed to keep an ordered index of the keys
    var indexer = function(name) {
        return {
            // the key
            key: name + '._index_',
            // returns the index
            all: function() {
                var a  = storage.getItem(this.key)
                if (a) {
                    a = JSON.parse(a)
                }
                if (a === null) storage.setItem(this.key, JSON.stringify([])) // lazy init
                return JSON.parse(storage.getItem(this.key))
            },
            // adds a key to the index
            add: function (key) {
                var a = this.all()
                a.push(key)
                storage.setItem(this.key, JSON.stringify(a))
            },
            // deletes a key from the index
            del: function (key) {
                var a = this.all(), r = []
                // FIXME this is crazy inefficient but I'm in a strata meeting and half concentrating
                for (var i = 0, l = a.length; i < l; i++) {
                    if (a[i] != key) r.push(a[i])
                }
                storage.setItem(this.key, JSON.stringify(r))
            },
            // returns index for a key
            find: function (key) {
                var a = this.all()
                for (var i = 0, l = a.length; i < l; i++) {
                    if (key === a[i]) return i
                }
                return false
            }
        }
    }

    // adapter api
    return {

        // ensure we are in an env with localStorage
        valid: function () {
            return !!storage
        },

        init: function (options, callback) {
            this.indexer = indexer(this.name)
            if (callback) this.fn(this.name, callback).call(this, this)
        },

        save: function (obj, callback) {
            var key = obj.key ? this.name + '.' + obj.key : this.name + '.' + this.uuid()
            // if the key is not in the index push it on
            if (this.indexer.find(key) === false) this.indexer.add(key)
            // now we kil the key and use it in the store colleciton
            delete obj.key;
            storage.setItem(key, JSON.stringify(obj))
            obj.key = key.slice(this.name.length + 1)
            if (callback) {
                this.lambda(callback).call(this, obj)
            }
            return this
        },

        batch: function (ary, callback) {
            var saved = []
            // not particularily efficient but this is more for sqlite situations
            for (var i = 0, l = ary.length; i < l; i++) {
                this.save(ary[i], function(r){
                    saved.push(r)
                })
            }
            if (callback) this.lambda(callback).call(this, saved)
            return this
        },

        // accepts [options], callback
        keys: function(callback) {
            if (callback) {
                var name = this.name
                    ,   keys = this.indexer.all().map(function(r){ return r.replace(name + '.', '') })
                this.fn('keys', callback).call(this, keys)
            }
            return this // TODO options for limit/offset, return promise
        },

        get: function (key, callback) {
            if (this.isArray(key)) {
                var r = []
                for (var i = 0, l = key.length; i < l; i++) {
                    var k = this.name + '.' + key[i]
                    var obj = storage.getItem(k)
                    if (obj) {
                        obj = JSON.parse(obj)
                        obj.key = key[i]
                        r.push(obj)
                    }
                }
                if (callback) this.lambda(callback).call(this, r)
            } else {
                var k = this.name + '.' + key
                var  obj = storage.getItem(k)
                if (obj) {
                    obj = JSON.parse(obj)
                    obj.key = key
                }
                if (callback) this.lambda(callback).call(this, obj)
            }
            return this
        },

        exists: function (key, cb) {
            var exists = this.indexer.find(this.name+'.'+key) === false ? false : true ;
            this.lambda(cb).call(this, exists);
            return this;
        },
        // NOTE adapters cannot set this.__results but plugins do
        // this probably should be reviewed
        all: function (callback) {
            var idx = this.indexer.all()
                ,   r   = []
                ,   o
                ,   k
            for (var i = 0, l = idx.length; i < l; i++) {
                k     = idx[i] //v
                o     = JSON.parse(storage.getItem(k))
                o.key = k.replace(this.name + '.', '')
                r.push(o)
            }
            if (callback) this.fn(this.name, callback).call(this, r)
            return this
        },

        remove: function (keyOrObj, callback) {
            var key = this.name + '.' + ((keyOrObj.key) ? keyOrObj.key : keyOrObj)
            this.indexer.del(key)
            storage.removeItem(key)
            if (callback) this.lambda(callback).call(this)
            return this
        },

        nuke: function (callback) {
            this.all(function(r) {
                for (var i = 0, l = r.length; i < l; i++) {
                    this.remove(r[i]);
                }
                if (callback) this.lambda(callback).call(this)
            })
            return this
        }
    }})());

define("lawnchair", function(){});

define('libs/pouchInterface',['jquery', 'Cache', 'pouchDB', 'lawnchair'], function($, Backbone, PouchDB) {
    'use strict';



    var PouchInterface = function(options) {
        this.initialize(options);
    };

    //tracks revisions based on puts
    var storeName = 'wemo-discovered-devices';
    var revisionStore = {};
    var discoveredStore = {} || window.localStorage.getItem(storeName);

    // PouchDB.destroy('wemoDeviceList');

    _.extend(PouchInterface.prototype, Backbone.Events, {
        initialize: function(options) {


        },
        setStorage: function() {

            if (!this.storage && !this.platform && window.device) {
                this.platform = window.device.platform;
                /*  if(this.platform === 'iOS'){
                    this.storage = 'pouch';
                }
                else{
                    this.storage ='local';
                    this.localPrefix = this.dbName + ':';
                }
                */
                this.storage = 'local';
                this.localPrefix = this.dbName + ':';
            } else if (!this.storage) {
                this.storage = 'local';
                this.localPrefix = this.dbName + ':';
            }
        },
        dbName: 'websql://wemoSmartDevices',
        createDatabase: function() {
            var dfd = $.Deferred();
            var self = this;

            this.setStorage();
            if (this.storage === 'pouch' && !this.db) {

                this.db = new PouchDB(this.dbName, {}, function(err, result) {
                    if (err) dfd.reject(err);
                    else dfd.resolve(result);
                });
            } else if (!this.db) {
                this.db = new Lawnchair({}, function() {});
                this.db.put = function(data, callback) {

                    data.key = self.localPrefix + data.udn;
                    if (data._rev) {
                        data._rev = data._rev + 1;
                    } else {
                        data._rev = 1;
                    }
                    self.db.save(data, function(obj) {
                        if (!discoveredStore[data.key]) {
                            discoveredStore[data.key] = Date.now();
                            window.localStorage.setItem(storeName, JSON.stringify(discoveredStore));
                        }
                        callback(null, {
                            id: data._id,
                            rev: data._rev
                        });
                    });

                };
                dfd.resolve();
            } else {
                dfd.resolve();
            }

            return dfd.promise();
        },
        getAll: function() {
            var dfd = $.Deferred();

//            this.setPlatform();
            if (this.platform === 'Android') {
                dfd.resolve();
                return dfd.promise();
            }

            this.db.allDocs({
                include_docs: true
            }, function(err, result) {
                if (err) {
                    dfd.reject(err);
                } else {
                    dfd.resolve(result);
                }
            });
            return dfd.promise();
        },
        getKey: function(model) {
            return model.baseObject.information.udn
        },
        get: function(model) {
            var dfd = $.Deferred();
            var self = this;


            this.createDatabase().then(function() {
                if (self.storage === 'pouch') {
                    self.db.get(self.getKey(model), {}, function(err, result) {
                        if (err && err.status !== 404 && err.status !== 409) {
                            dfd.reject(err);
                        } else if (err) {
                            dfd.resolve();
                        } else {
                            revisionStore[result._id] = result._rev;
                            dfd.resolve(result);
                        }
                    });
                } else {
                    var key = self.localPrefix + self.getKey(model);
                    self.db.exists(key, function(exists) {
                        if (exists) {
                            self.db.get(key, function(result) {
                                dfd.resolve(result);
                            });
                        } else {
                            dfd.resolve();
                        }
                    });

                }

            }).fail(dfd.reject);

            return dfd.promise();
        },
        remove: function(doc) {
            var self = this;
            var dfd = $.Deferred();

            this.createDatabase().then(function() {
                if (self.storage === 'pouch') {
                    self.db.remove(doc, function(err, resp) {
                        DEBUG && console.log('POUCH: REMOVING:' + JSON.stringify(err) + ':' + JSON.stringify(resp));
                        if (err) {
                            dfd.reject(err);
                        } else {
                            dfd.resolve(resp);
                        }

                    });
                } else {
                    self.db.remove(this.localPrefix + doc._id, function() {
                        dfd.resolve();
                    });
                }

            });

            return dfd.promise();
        },
        put: function(model) {
            var self = this;
            var dfd = $.Deferred();

            var checkProperty = function(property, key) {
                if (model.baseObject[property] && model.baseObject[property][key]) {
                    return true;
                } else {
                    return false;
                }
            }


            var finishPut = function(extendedData) {
                var data;
                extendedData = extendedData || {};

                if (model.baseObject) {
                    //update the baseObject with current values and put it into the DB.
                    //    model.updateBaseObject('attributes');
                    //    model.updateBaseObject('properties');

                    //lets only put stuff in the db that isn't coming from cache. we don't need the same data stored in 2 places.
                    var attributes = model.toJSON();

                    _.forEach(attributes, function(value, key) {
                        if (checkProperty('attributes', key) || checkProperty('deviceCapabilities', key) || checkProperty('properties', key)) {
                            delete attributes[key];
                        }
                    });

                    data = _.extend(extendedData, attributes, {
                        _id: self.getKey(model),
                        timestamp: Date.now()
                    });

                } else {
                    data = _.extend(extendedData, model.attributes, {
                        _id: self.getKey(model),
                        timestamp: Date.now()
                    });
                }

                if (data.sandbox) {
                    delete data.sandbox;
                }

                //need to remove properties that are not part of device data to be stored.
                if (data.Component) {
                    delete data.Component;
                }

                DEBUG && console.log('POUCHINTERFACE:putting data:' + JSON.stringify(data))

                self.db.put(data, function(err, response) {

                    if (err) {
                        dfd.reject(err);
                        DEBUG && console.log('POUCHINTERFACE:put error:' + JSON.stringify(err) + ':' + JSON.stringify(response) + ':' + JSON.stringify(data))
                    } else {
                        DEBUG && console.log('POUCHINTERFACE:data successfully put into db:' + JSON.stringify(response) + ':' + JSON.stringify(data));
                        model.set('_rev', response.rev);
                        revisionStore[response.id] = response.rev;
                        dfd.resolve(response);

                    }

                });
            };

            this.createDatabase().then(function() {

                if (!revisionStore[self.getKey(model)]) {
                    self.get(model).done(function(resp) {
                        finishPut(resp);
                    }).fail(function(resp) {
                        if (resp.status === 404) {
                            finishPut();
                        } else {
                            DEBUG && console.warn('POUCH: PUT ERROR:' + JSON.stringify(resp));
                            dfd.resolve({});
                        }
                    });
                } else {
                    finishPut({
                        _rev: revisionStore[self.getKey(model)]
                    });
                }


            }).fail(dfd.reject);


            return dfd.promise();
        }
    });

    var pouchInterface = new PouchInterface();


    return pouchInterface;

});
define('extensions/models/backbone.wemodevicemodel', ['Cache', 'feature!dataInterface', 'libs/smartDevicePlugin', 'mixins/pickerArrays', 'libs/pouchInterface', 'plugins/xml2json'], function(Backbone, dataInterface, smartDevicePlugin, picker, pouchInterface, XJ) {

    'use strict';

    // var devicePlugin = dataInterface.prototype.devicePlugin;


    Backbone.WemoDeviceModel = Backbone.DeepModel.extend({
        eventService: 'urn:Belkin:service:basicevent:1',
        rulesService: 'urn:Belkin:service:rules:1',
        setCommand: 'SetAttribute',
        getCommand: 'GetAttribute',
        idAttribute: 'udn',
        // getDevice: devicePlugin.getBaseDevice,
        callActionRetry: 0,
        dataInterface: dataInterface,
        setUserEvents: function() {
            /* if (!this.userEvents && !window.isSmartCache) {
                this.userEvents = devicePlugin.subscribeUserEvents(this);
            }*/
        },
        checkIfRemote: function() {
            /*   if (!window.isSmartCache) {
                return devicePlugin.checkIfRemote(this);
            }*/
        },
        /**
         * if it uses callAction to get the status of the device, all devices should have this
         */
        hasStatus: true,
        // Fetch the model from the server. If the server's representation of the
        // model differs from its current attributes, they will be overridden,
        // triggering a `"change"` event.
        fetchFromCache: function(when) {
            var model = this;
            var now = Date.now();


            //  this.setUserEvents();


            var dfd = $.Deferred();
            if (!model.get('serialNumber') && !model.baseObject) {
                dfd.resolve();
            } else {
                pouchInterface.get(model).then(function(resp) {
                    DEBUG && console.log('GOT FROM CACHE');

                    if (!resp) {
                        dfd.reject()
                    } else {
                        if (parseInt(resp.timestamp, 10) > parseInt((now - 3600000), 10)) {

                            if (!model.set(model.parse(resp))) {
                                return false;
                            }

                            DEBUG && console.log('TIMER: triggering sync from cache');
                            model.trigger('syncFromCache', model, resp);

                        }

                        dfd.resolve();
                    }
                });
            }
            return dfd.promise();

        },
        fetch: function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) options.parse = true;
            var model = this;
            var success = options.success;

            //every time we fetch, we reset the interval.
            this.checkIfRemote(model);


            options.success = function(resp) {
                var isValid = true; //assume it is valid, unless we have a verification method in our model
                if (!model.set(model.parse(resp, options), options)) return false;


                if (model.validateResponse) {
                    isValid = model.validateResponse();
                }

                if (success && isValid) {
                    success(model, resp, options);
                }

                DEBUG && console.log('SYNC:fetch:PUTTING IN THE POUCH ON FETCH:isValid=' + isValid + 'model=' + model.get('udn'));
                if (isValid) {
                    model.trigger('sync', model, resp, options);
                    pouchInterface.put(model).then(function() {
                        DEBUG && console.log('SYNC: triggering syncDeviceAndStatus');
                        model.trigger('syncDeviceAndStatus');
                    });
                } else {
                    model.trigger('syncError', 'fetch');
                }

            };
            wrapError(this, options);
            return this.sync('read', this, options);
            //return $.when(this.fetchFromCache(),this.sync('read', this, options));
        },
        /**
         * Fetch the model from the device_list.js - based on subscription changes - called in refresh
         * @param resp {Object} Device object - loseConnection/inactive states
         */
        fetchFromDeviceList: function(resp) {
            var model = this,
                isValid = true;
            if (!resp.attributeList && !resp.inactive && !resp.loseConnection) {
                resp.BinaryState = resp.state;
            }

            if (!model.set(model.parse(resp))) return false;


            if (_.has(resp, 'inactive') || _.has(resp, 'loseConnection')) {
                isValid = false;
            }

            DEBUG && console.log('FETCH:FROM-DEVICELIST: isValid: ' + isValid + ' resp: ' + JSON.stringify(resp));
            if (isValid) {
                model.trigger('sync', model, resp);
                pouchInterface.put(model).then(function() {
                    DEBUG && console.log('SYNC: triggering syncDeviceAndStatus');
                    model.trigger('syncDeviceAndStatus');
                });
            } else if (resp.loseConnection) {
                model.trigger('loseConnection', false);
            } else if (!resp.loseConnection && !resp.inactive) {
                model.trigger('loseConnection', true);
            } else {
                model.trigger('syncError', 'fetchFromDeviceList');
                model.trigger('loseConnection', true);
            }
        },

        //saves current state only to cache
        saveToCache: function() {
            return pouchInterface.put(this);
        },

        getBlobStorage: function(options) {
            //  return this.dataInterface.prototype.devicePlugin.blobStorage(options);
        },
        setBlobStorage: function(options) {
            //  return this.dataInterface.prototype.devicePlugin.blobStorage(options);
        },

        /**
         * Run validation against the next complete set of model attributes,
         * returning `true` if all is well. Otherwise, fire an `"invalid"` event.
         * @param attrs {Object} attributes to validate
         * @param options {Object}
         */
        _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger('invalid', this, error, _.extend(options || {}, {
                validationError: error
            }));
            return false;
        },
        save: function(key, val, options) {
            var model = this;
            var preSaved = false;
            var setToModel = false;
            var attrs, method, xhr, attributes = this.attributes;
            options = {} || options;
            // Handle both `'key', value` and `{key: value}` -style arguments.
            //


            //reset the timer interval, since we are actively changing data
            this.checkIfRemote();


            /** michael forbes - added ability to pass array of model attributes to be saved **/

            if (_.isArray(key)) {
                attrs = {};
                key.forEach(function(item) {
                    attrs[item] = model.attributes[item];
                    if (item === "fader" && typeof val === 'string') {
                        attrs[item] = val;
                        setToModel = true;
                    }
                });

                if (typeof val === 'object') {
                    options = val;
                }

                options.attrs = attrs;
            } else if (key == null || typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
            if (!setToModel) {
                if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;
            }


            options = _.extend({
                validate: true
            }, options);

            // Do not persist invalid models.
            if (!this._validate(attrs, options)) return false;

            // Set temporary attributes if `{wait: true}`.
            if (attrs && options.wait) {
                this.attributes = _.extend({}, attributes, attrs);
            }

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            if (options.parse === void 0) options.parse = true;

            var success = options.success;

            options.success = function(resp) {
                // Ensure attributes are restored during synchronous saves.
                model.attributes = attributes;
                var serverAttrs = model.parse(resp, options);
                if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
                if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                    return false;
                }

                DEBUG && console.log('SYNC: I AM IN THE SUCCESS FUNCTION');

                model.finishSave(preSaved);

                if (success) success(model, resp, options);
                model.trigger('sync', model, resp, options);

            };
            wrapError(this, options);

            method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
            if (method === 'patch') options.attrs = attrs;
            if (!options.preSave) {
                xhr = this.sync(method, this, options);
            }


            // Restore attributes.
            if (attrs && options.wait) this.attributes = attributes;


            if (!options.preSave) {
                return xhr;
            } else {

                preSaved = true;

                return $.Deferred(function(dfd) {
                    model.finishSave();
                    dfd.resolve();
                }).promise();
            }
        },
        preSave: function(key, options) {
            options = options || {};
            _.extend(options, {
                preSave: true
            });
            this.save(key, options);
        },
        finishSave: function(saved) {
            var model = this;
            if (!saved) {
                pouchInterface.put(model).then(function(resp) {
                    model.trigger('save', model, resp);
                }).fail(function(resp) {
                    model.trigger('save', model, resp);
                    // model.trigger('error',resp)
                });
            } else {
                model.trigger('save', model, resp);
            }

        },
        sync: function(method, model, options) {
            var type = 'set';
            var xhr;
            var params = {};

            var callback = function() {
                var resp = arguments[0];
                if (typeof resp === 'string') {
                    options.error(resp);
                } else {
                    DEBUG && console.log('SYNC:I SHOULD BE CALLING THE SUCCESS FUNCTION');
                    options.success(resp);
                }
            };


            if (method === 'read') {
                type = 'get';
            }

            // devicePlugin.type = type;

            // Ensure that we have the appropriate request data.
            if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
                params.contentType = 'application/json';
                params.data = options.attrs || model.toJSON(options);
            }



            if (type === 'set') {
                //check against global flag. DELETE THIS WHEN 100% SC+SFW


                //if we're doing the group thing - send the master model up to the group controller to do the save for the group
                if (model.sandbox && (model.baseObject.component && model.baseObject.component.groupMaster)) {
                    xhr = model.baseObject.component.parent.save(model, params.data);
                } else {
                    var isSettingState = false;
                    var isSettingProps = false;
                    var isSettingCapabilities = false;
                    var isSettingNightModeConfiguration = false;
                    var props = {};
                    var state = {};
                    var nightModeProps = {};
                    var nightModeConfigurationArr = ["nightMode", "nightModeBrightness", "startTime", "endTime"];

                    //check to see if we are saving an attribute or a property
                    _.each(params.data, function(value, key) {
                        if (model.baseObject.attributes && model.baseObject.attributes[key] !== undefined) {
                            if (nightModeConfigurationArr.indexOf(key) === -1) {
                                isSettingState = true;
                                state[key] = params.data[key];
                            } else {
                                isSettingNightModeConfiguration = true;
                                nightModeProps[key] = params.data[key];
                            }
                        }
                        if (model.baseObject.properties[key] !== undefined) {
                            isSettingProps = true;
                            props[key] = params.data[key];
                        }

                        if (model.baseObject.deviceCapabilities && model.baseObject.deviceCapabilities[key] !== undefined) {
                            isSettingCapabilities = true;
                            isSettingState = true;
                            state[key] = params.data[key];
                        }
                    });

                    if (isSettingState && isSettingProps) {
                        xhr = $.when(smartDevicePlugin.setDeviceState(callback, model, state), smartDevicePlugin.setDeviceProperties(callback, model, props));
                    } else if (isSettingState) {
                        xhr = smartDevicePlugin.setDeviceState(callback, model, state);
                    } else if (isSettingProps) {
                        xhr = smartDevicePlugin.setDeviceProperties(callback, model, props);
                    } else if (isSettingNightModeConfiguration) {
                        nightModeProps["udn"] = model.baseObject.information.udn;
                        xhr = smartDevicePlugin.setNightModeConfiguration(callback, model, nightModeProps);
                    } else {
                        throw ('data was not found in Attributes or Properties:' + JSON.stringify(params.data));
                    }
                }



            } else {
                xhr = smartDevicePlugin.getDevice(callback, model, options);
            }


            // Make the request, allowing the user to override any Ajax options.
            // var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
            model.trigger('request', model, xhr, options);
            return xhr;

        },
        /**
         * is run from tileanddrawer, parses the original remote XML results for a SMART device to insert into the UI
         * @param  {string} resp
         * @return {JSON}
         */
        parseOriginalRemote: function(resp) {
            /** resp looks like this:
             <plugin><pluginId>810004611</pluginId><macAddress>EC1A59C09824</macAddress><serialNumber>221337S0000081</serialNumber><uniqueId>uuid:Crockpot-1_0-221337S0000081</uniqueId><modelCode>Crockpot</modelCode><privateKey/><status>50</status><statusTS>1392062097</statusTS><description>Crock-PotÂ® Slow Cooker</description><notificationType>0</notificationType><createPluginTS>2014-02-05T18:39:45Z</createPluginTS><connectErrorTS xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nil="true"/><statusDateTS>2014-02-10T19:54:57Z</statusDateTS><signalStrength>100</signalStrength><eventDuration>323</eventDuration><cookedTime>52</cookedTime></plugin>
             **/

            /** for generic firmware, response looks like this:
             <plugins><plugin><macAddress>EC1A59F2131C</macAddress><status>0</status><statusTS>1400657773</statusTS><dbVersion>18</dbVersion><friendlyName>HolmesÂ® Humidifier0ee</friendlyName><rOverriden></rOverriden><modelCode>HolmesÂ® Humidifier0ee</modelCode><firmwareVersion>WeMo_WW_2.00.5327.DVT</firmwareVersion><signalStrength>100</signalStrength><fwUpgradeStatus>4</fwUpgradeStatus><iconVersion>1</iconVersion><attributeLists action="SetAttributes"><attribute><name>FanMode</name><value>5</value></attribute></attributeLists></plugin></plugins>
             **/

            // resp = '<plugins><plugin><macAddress>EC1A59F2131C</macAddress><status>0</status><statusTS>1400657773</statusTS><dbVersion>18</dbVersion><friendlyName>HolmesÂ® Humidifier0ee</friendlyName><rOverriden></rOverriden><modelCode>HolmesÂ® Humidifier0ee</modelCode><firmwareVersion>WeMo_WW_2.00.5327.DVT</firmwareVersion><signalStrength>100</signalStrength><fwUpgradeStatus>4</fwUpgradeStatus><iconVersion>1</iconVersion><attributeLists action="SetAttributes"><attribute><name>TestMode</name><value>1</value></attribute><attribute><name>FanMode</name><value>5</value></attribute></attributeLists></plugin></plugins>'
            DEBUG && console.log('REMOTE: PARSE ORIGINAL REMOTE:' + resp);
            var self = this;
            var X = new XJ();
            var obj = X.xml_str2json(resp);
            var cleanResp = {};
            console.log(obj)
            _.each(obj.plugin, function(value, key) {
                if (plugin.attributeLists) {
                    if (_.isArray(plugin.attributeLists.attribute)) {
                        _.each(plugin.attributeLists.attribute, function(attribute, index) {
                            cleanResp[attribute.name] = attribute.value;
                        });
                    } else {
                        cleanResp[plugin.attributeLists.attribute.name] = plugin.attributeLists.attribute.value;
                    }
                } else if (typeof value !== 'function') {
                    cleanResp[key] = value;
                }
            });


            if (this.mapToLocal) {
                cleanResp = this.mapToLocal(cleanResp);
            }

            _.each(cleanResp, function(value, key) {
                if (!self.validation()[key]) {
                    delete cleanResp[key];
                }
            });

            DEBUG && console.log('CLEANRESP: PARSE ORIGINAL REMOTE: FINAL:' + JSON.stringify(cleanResp));

            return cleanResp;
        },
        parse: function(resp) {
            /** TODO: need to parse data coming from cloud - identify as XML and convert **/

            /* if nodes are set, then it is XML */
            if (resp.firstChild) {
                var self = this;
                var X = new XJ();
                var obj = X.xml2json(resp);
                var cleanResp = {};

                if (obj.plugins) {
                    _.each(obj.plugins.plugin, function(plugin, key) {
                        if (plugin.attribute) {
                            if (_.isArray(plugin.attribute)) {
                                _.each(plugin.attribute, function(attribute, index) {
                                    cleanResp[attribute.name] = attribute.value;
                                });
                            } else {
                                cleanResp[plugin.attribute.name] = plugin.attribute.value;
                            }
                        } else if (typeof plugin !== 'function') {
                            cleanResp[key] = plugin;
                        }
                    });

                    /** function to convert state to mode etc... **/
                    DEBUG && console.log('REMOTE: RESPONSE PARSING:' + JSON.stringify(cleanResp));
                    if (this.mapToLocal) {
                        cleanResp = this.mapToLocal(cleanResp);
                    }

                    DEBUG && console.log('CLEANRESP:' + JSON.stringify(cleanResp));
                }

                _.each(cleanResp, function(value, key) {
                    var isFriendlyName = key.match(/friendlyname/gi);
                    if (isFriendlyName) {
                        cleanResp[key] = value.match('Â') ? value.replace('Â', '') : value;
                    } else if (!self.validation()[key]) {
                        delete cleanResp[key];
                    }
                });

                DEBUG && console.log('CLEANRESP: FINAL:' + JSON.stringify(cleanResp));


                return cleanResp;

            } else {
                if (_.isArray(resp)) {
                    // return rulesEngine.parseRules(resp[0]);
                } else {
                    if (resp.attributeList) {
                        resp.attributeList = _.isObject(resp.attributeList) ? resp.attributeList : JSON.parse(resp.attributeList);
                        _.each(resp.attributeList, function(data, attribute) {
                            resp[attribute] = _.isObject(data) ? data.value : data;
                        });
                        delete resp.attributeList;
                    }
                    DEBUG && console.log('LOCAL RESPONSE' + JSON.stringify(resp));

                    return resp;
                }
            }
        },
        trimResponse: function(data) {
            var trimmed = {};
            if (data) {
                _.each(this.defaults, function(value, key) {
                    if (data[key] || key === 'udn') {
                        trimmed[key] = data[key];
                    }
                });
            }

            return trimmed;
        },
        updateBaseObject: function(key) {

            var self = this;
            _.each(self.baseObject[key], function(value, index) {
                if (self.attributes[index]) {
                    self.baseObject[key][index] = self.attributes[index];
                }
            })
        }
    });

    _.extend(Backbone.WemoDeviceModel.prototype, picker);

    // Wrap an optional error callback with a fallback error event.
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error) error(model, resp, options);
            model.trigger('error', model, resp, options);
        };
    };



    /** return empty function, using extension to split it into wemo app more easily **/
    return {
        initialize: function(app) {
            //DEBUG && console.log(app.core.dataInterface)

        }
    };
});

define('extensions/views/backbone.overlay', ['Cache', 'shifty'], function(Backbone, Tweenable) {

    'use strict';

    var transition;
    var duration;
    var transform;
    var aura;

    Backbone.OverlayView = Backbone.View.extend({
        type: 'overlay',
        tagName: 'div',
        waitTime: 0,
        /**
         * runs the first time the view is created. Only runs once, unless the widget is destroyed
         * @param options
         */
        initialize: function(options) {
            var self = this;
            _.bindAll(this);
            _.extend(this, options);

            if (this.sandbox) {
                if (!this.model) {
                    this.model = this.sandbox.model; //set as default
                }

                if (!this.model) {
                    this.model = new Backbone.Model();
                    this.sandbox.model = this.model;
                }

                this.modelToSave = _.extend({}, this.sandbox.model); //set a copy to save temp new data to

                //need to have udn to start rules

            } else {
                throw ('you need to pass the sandbox to any child views');
            }

            /* open can be called within the overlay, or externally depending on need. prevent duplicate calls*/
            this.open = _.throttle(this.throttledOpen, 1000, {
                trailing: false
            });

            if (this.viewName) {
                this.$el.addClass(this.viewName);
            } else {
                this.$el.addClass('settings');
            }

            if (this.afterInitialize) {
                this.afterInitialize();
            }

            this.defaultDuration = 300;
            this.duration = this.defaultDuration;

        },
        initialRender: function() {
            var self = this;

            this.verticalTransform = 0;

            if (this.parentElement) {
                this.$previousEl = this.parentElement;
                this.previousEl = this.$previousEl[0];
            } else if (this.parentView) {
                this.$previousEl = this.parentView.$el.parent().parent();
                this.previousEl = this.$previousEl[0];
            }

            if (!this.$el.hasClass('overlay')) {
                this.$el.addClass(this.sandbox.name + '  smart-overlay overlay-' + this.sandbox.name)
                    .attr('id', 'overlay-' + this.cid).css({
                        display: 'block'
                    });
            }
            if(this.template){
                var html = this.i18n(this.template);
                this.$el.html(html);
            }
            var headerHeight = parseInt($("#headerComponent").outerHeight(), 10);
            var height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
            if (!this.$el.hasClass('noMainHeader')) {
                this.$el.height(height - headerHeight);
                this.$el.css('top', headerHeight);
            }

            if (this.$previousEl) {

                this.$appendTo = $('body');
                this.$appendTo.append(this.$el);

                this.el.style.webkitTransform = 'translate3d(100%,0,0)';

            } else {
                throw ('You need to set an element to transition from. options.parentElement OR this.setPreviousElement')
            }
            this.isRendered = true;

            if (!this.$previousEl) {

                this.sandbox.on('settingsClose', function() {
                    self.finishClose();
                });

                if (self.beforeOpen) {
                    self.beforeOpen();
                }
                self.finishOpen();
            }

            if (this.render) {
                this.render();
            }

            if (this.afterRender) {
                this.afterRender();
            }

            self.$el.show();
            self.stickit();

            if (this.$previousEl) {
                this.open();
            }

            //Close overlay when lose internet
            this.sandbox.on('global.onNetworkChanged', function(status){
                if (!status.isNetworkenabled) {
                    self.duration = 0
                    self.close();
                }
            });
        },
        /**
         * update the element that the overlay transitions to - used in firmware update to skip confirm screen, for example
         */
        setPreviousElement: function($el) {
            this.parentElement = $el;
            this.$previousEl = $el;
            this.previousEl = $el[0];
        },
        /**
         * sets a speed of open and close for 1 instance of opening and closing. is reset after close.
         * @param {int} duration time in ms
         */
        setDuration: function(duration) {
            this.duration = duration;
        },
        throttledOpen: function() {
            if (this.beforeOpen) {
                this.beforeOpen();
            }

            setTimeout(this.move, this.waitTime);
        },
        move: function() {
            var self = this;

            if (self.previousEl.style.webkitTransform) {
                var currentTransform = self.previousEl.style.webkitTransform;
                var split = currentTransform.split(',');
                this.verticalTransform = split[1];
            }

            var transition = 'webkitTransform ' + self.duration + 'ms ease-out, transform ' + self.duration + 'ms ease-out';
            self.previousEl.style.webkitTransition = transition;
            self.el.style.webkitTransition = transition;


            //Avoid a rendering race condition due to the transition being partially applied
            setTimeout(function(){
                self.el.style.webkitTransform = 'translate3d(0%,0,0)';
                self.previousEl.style.webkitTransform = 'translate3d(-100%,' + self.verticalTransform + ',0)';
            }, 0);

            setTimeout(function(){
                self.finishOpen();
            }, self.duration);
        },
        finishOpen: function() {

            var self = this;
            self.checkRules();

            if (self.afterOpen) {
                self.afterOpen();
            }
            self.delegateEvents();

            self.backButton();

            if (self.listen) {
                self.stopListening();
                self.listen();
            }

            //plugins/backbone.overrides
            if (!this.$el.hasClass('noScroll')) {
                self._makeScrollable();
            }

            self.sandbox.emit('finishOpen');

        },
        /**
         * add mobile device back button control
         */
        backButton: function() {
            var self = this;
            self.addBackButtonCommand({
                key: 'cancel',
                callback: function() {
                    self.sandbox.uiInterface.dismissSettings.call(self, {
                        cancel: true
                    });
                }
            });
        },
        backClose: function() {
        },
        close: function() {
            var self = this;
            var timeout = 0;

            //see if there are any mobiscrolls, and if so, close them.

            this.$('select').each(function() {
                var $el = $(this);
                if ($el.mobiscroll) {
                    $el.mobiscroll('hide');
                    timeout = 0;
                }
            });

            var arg = Array.prototype.slice.call(arguments)[0];

            this.backClose();
            setTimeout(function() {

                //remove any back button commands set to this screen
                self.removeBackButtonCommand();
                if (self.previousEl) {

                    if (self.previousEl.style.webkitTransform) {
                        var currentTransform = self.previousEl.style.webkitTransform;
                        var split = currentTransform.split(',');
                        self.verticalTransform = split[1];

                    }

                    self.el.style.webkitTransform = 'translate3d(100%,0,0)';
                    self.previousEl.style.webkitTransform = 'translate3d(0%,' + self.verticalTransform + ',0)';

                    setTimeout(function(){
                        self.finishClose();
                    }, self.duration);
                }
            }, timeout);

            if (arg && arg.preventDefault) {
                arg.preventDefault();
            }
        },
        finishClose: function(arg) {
            var self = this;

            if (this.sandbox.processedView) {
                this.sandbox.processedView._clearActiveAndOpen.call(this);
            }
            this.sandbox.emit('finishClose');

            //clear listeners
            self.stopListening();

            if (self.endListening) {
                self.endListening();
            }

            self.undelegateEvents();
            if (self.rulesEngine) {
                self.rulesEngine.collection.off('sync', self.rulesSync);
            }

            self.unstickit();
            self.$el.hide();
            if (arg && arg.cancel) {
                self.sandbox.emit('undo');
            }
            if (self.afterClose) {
                self.afterClose();
            }

            this.$el.remove();
            this.duration = this.defaultDuration;
            //delete this;
        },
        bind: function() {

        },
        /** methods to manage confirmation dialogs **/
        /**
         * initialize the confirm dialog
         * @param options
         */
        createConfirmDialog: function(options) {
            DEBUG && console.log('CONFIRM:CREATING:' + this.sandbox.ref);
            var self = this;


            var defaultOptions = {
                title: this.i18n('settings', 'confirmTitle'),
                message: this.i18n('settings', 'confirmMessage'),
                buttonLabels: this.i18n('settings', 'confirmLabels'),
                confirmCallback: function() {},
                cancelCallback: function() {}
            }



            options = options || {};

            this.confirmOptions = _.extend(defaultOptions, options);
        },
        /**
         * open the confirm dialog, add back button support
         */
        openConfirmDialog: function() {
            var self = this;
            this.confirmDialog = new this.sandbox.dom.Alert(this.confirmOptions);
            this.addBackButtonCommand({
                key: 'confirm',
                callback: function() {
                    self.confirmDialog.cancel();
                }
            });
        },
        stopConfirmDialog: function() {

            if (this.confirmDialogTimer) {
                DEBUG && console.log('CONFIRM:STOPPING');
                clearTimeout(this.confirmDialogTimer);
                this.confirmDialogTimer = null;
            }
        },
        startConfirmDialog: function() {
            var self = this;
            if (!this.confirmDialogTimer) {
                DEBUG && console.log('CONFIRM:STARTING');
                // this.confirmDialogTimer = setTimeout(self.openConfirmDialog, 5000);
            }
        }
    });

    return {
        initialize: function(app) {
            aura = app;
        }
    };
});

/* Mobiscroll License Key:75b37c4f-6d57-4757-aa3a-868ed8906ddf */
(function(a){function k(a){for(var b in a)if(void 0!==G[a[b]])return!0;return!1}function q(a,b){var c=a.originalEvent,f=a.changedTouches;return f||c&&c.changedTouches?c?c.changedTouches[0]["page"+b]:f[0]["page"+b]:a["page"+b]}function Y(b,h,c){var f=b;if("object"===typeof h)return b.each(function(){this.id||(this.id="mobiscroll"+ ++v);j[this.id]&&j[this.id].destroy();new a.mobiscroll.classes[h.component||"Scroller"](this,h)});"string"===typeof h&&b.each(function(){var a;if((a=j[this.id])&&a[h])if(a=
    a[h].apply(this,Array.prototype.slice.call(c,1)),void 0!==a)return f=a,!1});return f}function o(a){if("touchstart"==a.type)f[a.target]=!0;else if(f[a.target])return delete f[a.target],!1;return!0}var v=+new Date,f={},j={},i=a.extend,G=document.createElement("modernizr").style,H=k(["perspectiveProperty","WebkitPerspective","MozPerspective","OPerspective","msPerspective"]),p=function(){var a=["Webkit","Moz","O","ms"],b;for(b in a)if(k([a[b]+"Transform"]))return"-"+a[b].toLowerCase()+"-";return""}(),
    b=p.replace(/^\-/,"").replace(/\-$/,"").replace("moz","Moz");a.fn.mobiscroll=function(b){i(this,a.mobiscroll.components);return Y(this,b,arguments)};a.mobiscroll=a.mobiscroll||{util:{prefix:p,jsPrefix:b,has3d:H,getCoord:q,testTouch:o},presets:{},themes:{},i18n:{},instances:j,classes:{},components:{},defaults:{},setDefaults:function(a){i(defaults,a)},presetShort:function(a,b){this.components[a]=function(c){return Y(this,i(c,{component:b,preset:a}),arguments)}}};a.scroller=a.scroller||a.mobiscroll;
    a.fn.scroller=a.fn.scroller||a.fn.mobiscroll})(jQuery);(function(a){function k(){f=!0;setTimeout(function(){f=!1},300)}function q(a,b,c){return Math.max(b,Math.min(a,c))}function Y(b){var c={values:[],keys:[]};a.each(b,function(a,b){c.keys.push(a);c.values.push(b)});return c}a.mobiscroll.classes.Scroller=function(d,w){function A(a,t,b){a.stopPropagation();a.preventDefault();if(!ma&&!l(t)&&!t.hasClass("dwa")){ma=!0;var e=t.find(".dw-ul");H(e);clearInterval(va);va=setInterval(function(){b(e)},g.delay);b(e)}}function l(m){return a.isArray(g.readonly)?(m=
    a(".dwwl",x).index(m),g.readonly[m]):g.readonly}function z(m){var t='<div class="dw-bf">',m=Ca[m],m=m.values?m:Y(m),g=1,b=m.labels||[],e=m.values,c=m.keys||e;a.each(e,function(a,m){0==g%20&&(t+='</div><div class="dw-bf">');t+='<div role="option" aria-selected="false" class="dw-li dw-v" data-val="'+c[a]+'"'+(b[a]?' aria-label="'+b[a]+'"':"")+' style="height:'+Q+"px;line-height:"+Q+'px;"><div class="dw-i">'+m+"</div></div>";g++});return t+="</div>"}function H(m){Z=a(".dw-li",m).index(a(".dw-v",m).eq(0));
    $=a(".dw-li",m).index(a(".dw-v",m).eq(-1));T=a(".dw-ul",x).index(m)}function R(a){var t=g.headerText;return t?"function"===typeof t?t.call(da,a):t.replace(/\{value\}/i,a):""}function y(){e.temp=e.values?e.values.slice(0):g.parseValue(O.val()||"",e);ca()}function aa(m){var t=window.getComputedStyle?getComputedStyle(m[0]):m[0].style,g;C?(a.each(["t","webkitT","MozT","OT","msT"],function(a,m){if(void 0!==t[m+"ransform"])return g=t[m+"ransform"],!1}),g=g.split(")")[0].split(", "),m=g[13]||g[5]):m=t.top.replace("px",
    "");return Math.round(s-m/Q)}function ea(a,t){clearTimeout(qa[t]);delete qa[t];a.closest(".dwwl").removeClass("dwa")}function U(a,t,g,e,c){var d=(s-g)*Q,u=a[0].style;d==wa[t]&&qa[t]||(e&&d!=wa[t]&&E("onAnimStart",[x,t,e]),wa[t]=d,u[b+"Transition"]="all "+(e?e.toFixed(3):0)+"s ease-out",C?u[b+"Transform"]="translate3d(0,"+d+"px,0)":u.top=d+"px",qa[t]&&ea(a,t),e&&c&&(a.closest(".dwwl").addClass("dwa"),qa[t]=setTimeout(function(){ea(a,t)},1E3*e)),sa[t]=g)}function N(m,t,g){var m=a('.dw-li[data-val="'+
    m+'"]',t),t=a(".dw-li",t),e=t.index(m),b=t.length;if(!m.hasClass("dw-v")){for(var c=m,d=0,u=0;0<=e-d&&!c.hasClass("dw-v");)d++,c=t.eq(e-d);for(;e+u<b&&!m.hasClass("dw-v");)u++,m=t.eq(e+u);(u<d&&u&&2!==g||!d||0>e-d||1==g)&&m.hasClass("dw-v")?e+=u:(m=c,e-=d)}return{cell:m,v:e,val:m.attr("data-val")}}function P(m,t,b,c,d){!1!==E("validate",[x,t,m,c])&&(a(".dw-ul",x).each(function(b){var u=a(this),f=b==t||void 0===t,Aa=N(e.temp[b],u,c),s=Aa.cell;if(!s.hasClass("dw-sel")||f)e.temp[b]=Aa.val,g.multiple||
    (a(".dw-sel",u).removeAttr("aria-selected"),s.attr("aria-selected","true")),a(".dw-sel",u).removeClass("dw-sel"),s.addClass("dw-sel"),U(u,b,Aa.v,f?m:0.1,f?d:!1)}),fa=g.formatResult(e.temp),e.live&&ca(b,b,0,!0),a(".dwv",x).html(R(fa)),b&&E("onChange",[fa]))}function E(m,g){var b;g.push(e);a.each([Da,Ea,w],function(a,e){e&&e[m]&&(b=e[m].apply(da,g))});return b}function V(m,b,c,d,u){var b=q(b,Z,$),f=a(".dw-li",m).eq(b),s=void 0===u?b:u,h=void 0!==u,l=T,x=d?b==s?0.1:Math.abs((b-s)*g.timeUnit):0;e.temp[l]=
    f.attr("data-val");U(m,l,b,x,h);setTimeout(function(){P(x,l,!0,c,h)},10)}function na(a){var b=sa[T]+1;V(a,b>$?Z:b,1,!0)}function ga(a){var b=sa[T]-1;V(a,b<Z?$:b,2,!0)}function ca(a,b,c,d,u,f){oa&&!d&&P(c,void 0,f);fa=g.formatResult(e.temp);u||(e.values=e.temp.slice(0),e.val=fa);a&&(ra&&(O.val(fa),b&&(pa=!0,O.change())),E("onValueFill",[fa,b]))}function u(a,b){var g;ha.on(a,function(){clearTimeout(g);g=setTimeout(function(){(xa&&b||!b)&&e.position(!b)},200)})}var s,Q,fa,x,ya,Ha,Ia,Ja,ta,ia,xa,ja,Da,
    Fa,ma,L,I,F,ka,Ka,W,ua,Z,$,M,S,T,va,la,pa,Ga,ha,za,ba,X,e=this,da=d,O=a(da),g=n({},J),Ea={},qa={},sa={},wa={},Ca=[],La=[],ra=O.is("input"),oa=!1,Pa=function(b){c(b)&&!v&&!ma&&!X&&!l(this)&&(b.preventDefault(),v=!0,I="clickpick"!=g.mode,S=a(".dw-ul",this),H(S),ua=(F=void 0!==qa[T])?aa(S):sa[T],ka=h(b,"Y"),Ka=new Date,W=ka,U(S,T,ua,0.0010),I&&S.closest(".dwwl").addClass("dwa"),a(document).on(K,Ma).on(B,Na))},Ma=function(a){I&&(a.preventDefault(),a.stopPropagation(),W=h(a,"Y"),U(S,T,q(ua+(ka-W)/Q,Z-
        1,$+1)));ka!==W&&(F=!0)},Na=function(){var b=new Date-Ka,e=q(ua+(ka-W)/Q,Z-1,$+1),c,d=S.offset().top;300>b?(b=(W-ka)/b,c=b*b/g.speedUnit,0>W-ka&&(c=-c)):c=W-ka;b=Math.round(ua-c/Q);if(!c&&!F){var d=Math.floor((W-d)/Q),u=a(a(".dw-li",S)[d]);c=I;!1!==E("onValueTap",[u])?b=d:c=!0;c&&(u.addClass("dw-hl"),setTimeout(function(){u.removeClass("dw-hl")},200))}I&&V(S,b,0,!0,Math.round(e));v=!1;S=null;a(document).off(K,Ma).off(B,Na)},Qa=function(b){X&&X.removeClass("dwb-a");X=a(this);a(document).on(B,Oa);!X.hasClass("dwb-d")&&
        !X.hasClass("dwb-nhl")&&X.addClass("dwb-a");X.hasClass("dwwb")&&c(b)&&A(b,X.closest(".dwwl"),X.hasClass("dwwbp")?na:ga)},Oa=function(){ma&&(clearInterval(va),ma=!1);X&&(X.removeClass("dwb-a"),X=null);a(document).off(B,Oa)},Ra=function(b){38==b.keyCode?A(b,a(this),ga):40==b.keyCode&&A(b,a(this),na)},Sa=function(){ma&&(clearInterval(va),ma=!1)},Ta=function(b){if(!l(this)){b.preventDefault();var b=b.originalEvent||b,b=b.wheelDelta?b.wheelDelta/120:b.detail?-b.detail/3:0,e=a(".dw-ul",this);H(e);V(e,Math.round(sa[T]-
        b),0>b?1:2)}};e.position=function(b){var c=ya.width(),d=ha[0].innerHeight||ha.innerHeight();if(!(Ia===c&&Ja===d&&b)&&!Ga&&!1!==E("onPosition",[x,c,d])&&M){var u,f,s,h,l,r,v,i,P,j=0,N=0,b=ha.scrollLeft(),p=ha.scrollTop();h=a(".dwwr",x);var A=a(".dw",x),V={};l=void 0===g.anchor?O:g.anchor;/modal|bubble/.test(g.display)&&(a(".dwc",x).each(function(){u=a(this).outerWidth(!0);j+=u;N=u>N?u:N}),u=j>c?N:j,h.width(u).css("white-space",j>c?"":"nowrap"));ta=A.outerWidth();ia=A.outerHeight(!0);xa=ia<=d&&ta<=
    c;e.scrollLock=xa;"modal"==g.display?(f=(c-ta)/2,s=p+(d-ia)/2):"bubble"==g.display?(P=!0,i=a(".dw-arrw-i",x),s=l.offset(),r=Math.abs(a(g.context).offset().top-s.top),v=Math.abs(a(g.context).offset().left-s.left),h=l.outerWidth(),l=l.outerHeight(),f=q(v-(A.outerWidth(!0)-h)/2-b,3,c-ta-3),s=r-ia,s<p||r>p+d?(A.removeClass("dw-bubble-top").addClass("dw-bubble-bottom"),s=r+l):A.removeClass("dw-bubble-bottom").addClass("dw-bubble-top"),i=i.outerWidth(),h=q(v+h/2-(f+(ta-i)/2)-b,0,i),a(".dw-arr",x).css({left:h})):
    "top"==g.display?s=p:"bottom"==g.display&&(s=p+d-ia);V.top=0>s?0:s;V.left=f;A.css(V);ya.height(0);f=Math.max(s+ia,"body"==g.context?a(document).height():za.scrollHeight);ya.css({height:f,left:b});if(P&&(s+ia>p+d||r>p+d))Ga=!0,setTimeout(function(){Ga=false},300),ha.scrollTop(Math.min(s+ia-d,f-d))}Ia=c;Ja=d};e.enable=function(){g.disabled=!1;ra&&O.prop("disabled",!1)};e.disable=function(){g.disabled=!0;ra&&O.prop("disabled",!0)};e.setValue=function(b,c,d,u,s){e.temp=a.isArray(b)?b.slice(0):g.parseValue.call(da,
    b+"",e);ca(c,void 0===s?c:s,d,!1,u,c)};e.getValue=function(){return e.values};e.getValues=function(){var a=[],b;for(b in e._selectedValues)a.push(e._selectedValues[b]);return a};e.changeWheel=function(b,c,d){if(x){var u=0,s=b.length;a.each(g.wheels,function(g,f){a.each(f,function(g,f){if(-1<a.inArray(u,b)&&(Ca[u]=f,a(".dw-ul",x).eq(u).html(z(u)),s--,!s))return e.position(),P(c,void 0,d),!1;u++});if(!s)return!1})}};e.isVisible=function(){return oa};e.tap=function(a,b){var c,e;if(g.tap)a.on("touchstart.dw mousedown.dw",
    function(a){a.preventDefault();c=h(a,"X");e=h(a,"Y")}).on("touchend.dw",function(a){20>Math.abs(h(a,"X")-c)&&20>Math.abs(h(a,"Y")-e)&&b.call(this,a);k()});a.on("click.dw",function(a){f||b.call(this,a);a.preventDefault()})};e.show=function(b){var c,d=0,s="";if(!g.disabled&&!oa){"top"==g.display&&(ja="slidedown");"bottom"==g.display&&(ja="slideup");y();E("onBeforeShow",[]);ja&&!b&&(s="dw-"+ja+" dw-in");var f='<div role="dialog" class="'+g.theme+" dw-"+g.display+(p?" dw"+p.replace(/\-$/,""):"")+(L?"":
    " dw-nobtn")+'"><div class="dw-persp">'+(!M?'<div class="dw dwbg dwi">':'<div class="dwo"></div><div class="dw dwbg '+s+'"><div class="dw-arrw"><div class="dw-arrw-i"><div class="dw-arr"></div></div></div>')+'<div class="dwwr"><div aria-live="assertive" class="dwv'+(g.headerText?"":" dw-hidden")+'"></div><div class="dwcc">',h=a.isArray(g.minWidth),l=a.isArray(g.maxWidth),i=a.isArray(g.fixedWidth);a.each(g.wheels,function(b,e){f+='<div class="dwc'+("scroller"!=g.mode?" dwpm":" dwsc")+(g.showLabel?
    "":" dwhl")+'"><div class="dwwc dwrc"><table cellpadding="0" cellspacing="0"><tr>';a.each(e,function(a,b){Ca[d]=b;c=void 0!==b.label?b.label:a;f+='<td><div class="dwwl dwrc dwwl'+d+'">'+("scroller"!=g.mode?'<a href="#" tabindex="-1" class="dwb-e dwwb dwwbp" style="height:'+Q+"px;line-height:"+Q+'px;"><span>+</span></a><a href="#" tabindex="-1" class="dwb-e dwwb dwwbm" style="height:'+Q+"px;line-height:"+Q+'px;"><span>&ndash;</span></a>':"")+'<div class="dwl">'+c+'</div><div tabindex="0" aria-live="off" aria-label="'+
    c+'" role="listbox" class="dwww"><div class="dww" style="height:'+g.rows*Q+"px;"+(g.fixedWidth?"width:"+(i?g.fixedWidth[d]:g.fixedWidth)+"px;":(g.minWidth?"min-width:"+(h?g.minWidth[d]:g.minWidth)+"px;":"min-width:"+g.width+"px;")+(g.maxWidth?"max-width:"+(l?g.maxWidth[d]:g.maxWidth)+"px;":""))+'"><div class="dw-ul">';f+=z(d);f+='</div><div class="dwwol"></div></div><div class="dwwo"></div></div><div class="dwwol"></div></div></td>';d++});f+="</tr></table></div></div>"});f+="</div>";M&&L&&(f+='<div class="dwbc">',
    a.each(ba,function(a,b){b="string"===typeof b?e.buttons[b]:b;f+="<span"+(g.btnWidth?' style="width:'+100/ba.length+'%"':"")+' class="dwbw '+b.css+'"><a href="#" class="dwb dwb'+a+' dwb-e" role="button">'+b.text+"</a></span>"}),f+="</div>");f+="</div></div></div></div>";x=a(f);ya=a(".dw-persp",x);Ha=a(".dwo",x);oa=!0;P();E("onMarkupReady",[x]);M?(x.appendTo(g.context),ja&&!b&&(x.addClass("dw-trans"),setTimeout(function(){x.removeClass("dw-trans").find(".dw").removeClass(s)},350))):O.is("div")?O.html(x):
    x.insertAfter(O);E("onMarkupInserted",[x]);if(M){a(window).on("keydown.dw",function(a){a.keyCode==13?e.select():a.keyCode==27&&e.cancel()});if(g.scrollLock)x.on("touchmove",function(a){xa&&a.preventDefault()});a("input,select,button",za).each(function(){if(!this.disabled){a(this).attr("autocomplete")&&a(this).data("autocomplete",a(this).attr("autocomplete"));a(this).addClass("dwtd").prop("disabled",true).attr("autocomplete","off")}});u("scroll.dw",!0)}e.position();u("orientationchange.dw resize.dw",
    !1);x.on("DOMMouseScroll mousewheel",".dwwl",Ta).on("keydown",".dwwl",Ra).on("keyup",".dwwl",Sa).on("selectstart mousedown",r).on("click",".dwb-e",r).on("touchend",function(){g.tap&&k()}).on("keydown",".dwb-e",function(b){if(b.keyCode==32){b.preventDefault();b.stopPropagation();a(this).click()}});setTimeout(function(){a.each(ba,function(b,c){e.tap(a(".dwb"+b,x),function(a){c=typeof c==="string"?e.buttons[c]:c;c.handler.call(this,a,e)})});g.closeOnOverlay&&e.tap(Ha,function(){e.cancel()});x.on(D,".dwwl",
    Pa).on(D,".dwb-e",Qa)},300);E("onShow",[x,fa])}};e.hide=function(b,c,e){if(oa&&(e||!1!==E("onClose",[fa,c])))a(".dwtd",za).each(function(){a(this).prop("disabled",!1).removeClass("dwtd");a(this).data("autocomplete")?a(this).attr("autocomplete",a(this).data("autocomplete")):a(this).removeAttr("autocomplete")}),x&&((c=M&&ja&&!b)&&x.addClass("dw-trans").find(".dw").addClass("dw-"+ja+" dw-out"),b?x.remove():setTimeout(function(){x.remove();o&&(j=!0,o.focus())},c?350:1),ha.off(".dw")),wa={},oa=!1};e.select=
    function(){!1!==e.hide(!1,"set")&&(ca(!0,!0,0,!0),E("onSelect",[e.val]))};e.attachShow=function(a,b){La.push(a);if("inline"!==g.display)a.on((g.showOnFocus?"focus.dw":"")+(g.showOnTap?" click.dw":""),function(c){if(("focus"!==c.type||"focus"===c.type&&!j)&&!f)b&&b(),o=a,e.show();setTimeout(function(){j=!1},300)})};e.cancel=function(){!1!==e.hide(!1,"cancel")&&E("onCancel",[e.val])};e.init=function(b){Da=i.themes[b.theme||g.theme];Fa=i.i18n[b.lang||g.lang];n(w,b);E("onThemeLoad",[Fa,w]);n(g,Da,Fa,
    w);g.buttons=g.buttons||["set","cancel"];g.headerText=void 0===g.headerText?"inline"!==g.display?"{value}":!1:g.headerText;e.settings=g;O.off(".dw");if(b=i.presets[g.preset])Ea=b.call(da,e),n(g,Ea,w);s=Math.floor(g.rows/2);Q=g.height;ja=g.animate;M="inline"!==g.display;ba=g.buttons;ha=a("body"==g.context?window:g.context);za=a(g.context)[0];g.setText||ba.splice(a.inArray("set",ba),1);g.cancelText||ba.splice(a.inArray("cancel",ba),1);g.button3&&ba.splice(a.inArray("set",ba)+1,0,{text:g.button3Text,
    handler:g.button3});e.context=ha;e.live=!M||-1==a.inArray("set",ba);e.buttons.set={text:g.setText,css:"dwb-s",handler:e.select};e.buttons.cancel={text:e.live?g.closeText:g.cancelText,css:"dwb-c",handler:e.cancel};e.buttons.clear={text:g.clearText,css:"dwb-cl",handler:function(){e.trigger("onClear",[x]);O.val("");e.live||e.hide()}};L=0<ba.length;oa&&e.hide(!0,!1,!0);M?(y(),ra&&(void 0===la&&(la=da.readOnly),da.readOnly=!0),e.attachShow(O)):e.show();if(ra)O.on("change.dw",function(){pa||e.setValue(O.val(),
    false,0.2);pa=false})};e.option=function(a,b){var c={};"object"===typeof a?c=a:c[a]=b;e.init(c)};e.destroy=function(){e.hide(!0,!1,!0);a.each(La,function(a,b){b.off(".dw")});a(window).off(".dwa");ra&&(da.readOnly=la);delete G[da.id];E("onDestroy",[])};e.getInst=function(){return e};e.getValidCell=N;e.trigger=E;G[da.id]=e;e.values=null;e.val=null;e.temp=null;e.buttons={};e._selectedValues={};e.init(w)};var o,v,f,j,i=a.mobiscroll,G=i.instances,H=i.util,p=H.prefix,b=H.jsPrefix,C=H.has3d,h=H.getCoord,
    c=H.testTouch,r=function(a){a.preventDefault()},n=a.extend,D="touchstart mousedown",K="touchmove mousemove",B="touchend mouseup",J=n(i.defaults,{width:70,height:40,rows:3,delay:300,disabled:!1,readonly:!1,closeOnOverlay:!0,showOnFocus:!0,showOnTap:!0,showLabel:!0,wheels:[],theme:"",display:"modal",mode:"scroller",preset:"",lang:"en-US",context:"body",scrollLock:!0,tap:!0,btnWidth:!0,speedUnit:0.0012,timeUnit:0.1,formatResult:function(a){return a.join(" ")},parseValue:function(b,c){var f=b.split(" "),
        h=[],r=0,i;a.each(c.settings.wheels,function(b,c){a.each(c,function(b,c){c=c.values?c:Y(c);i=c.keys||c.values;-1!==a.inArray(f[r],i)?h.push(f[r]):h.push(i[0]);r++})});return h}});i.i18n.en=i.i18n["en-US"]={setText:"Set",selectedText:"Selected",closeText:"Close",cancelText:"Cancel",clearText:"Clear"};a(window).on("focus",function(){o&&(j=!0)});a(document).on("mouseover mouseup mousedown click",function(a){if(f)return a.stopPropagation(),a.preventDefault(),!1})})(jQuery);(function(a){var k={dateOrder:"Mddyy",mode:"mixed",rows:5,minWidth:70,height:36,showLabel:!1,useShortLabels:!0};a.mobiscroll.themes["android-ics"]=k;a.mobiscroll.themes["android-ics light"]=k})(jQuery);(function(a){a.mobiscroll.themes.ios7={dateOrder:"MMdyy",rows:5,height:34,minWidth:55,headerText:!1,showLabel:!1,btnWidth:!1,useShortLabels:!0}})(jQuery);(function(a){var k=a.mobiscroll,q={wheelOrder:"hhiiss",useShortLabels:!1,minTime:0,maxTime:Infinity};k.i18n.en=a.extend(k.i18n.en,{labels:"Years,Months,Days,Hours,Minutes,Seconds".split(","),labelsShort:"Yrs,Mths,Days,Hrs,Mins,Secs".split(",")});k.presetShort("timespan");k.presets.timespan=function(k){function o(b){var c={};a(A).each(function(a,d){c[d]=R[d]?Math.floor(b/l[d].limit):0;b-=c[d]*l[d].limit});return c}function v(a,b){var d=!1,f=Ba[R[a]-1]||1,h=l[a],i=h.wheel,v=h.prefix;c=0;r=h.until;a==
    y&&(c=Math.max(K[a],b[a]-50*f),r=Math.min(B[a],c+100*f),H=c+5*f,p=r-5*f);i.keys=[];i.values=[];i.label=h.label;w.match(RegExp(h.re+h.re,"i"))&&(d=!0);for(j=c;j<=r;j+=f)i.keys.push(j),i.values.push((v||"")+(10>j&&d?"0":"")+j+'<span class="dwtlbl">'+h.label+"</span>")}function f(b){var c=0;a.each(z,function(a,d){isNaN(+b[0])||(c+=l[d.v].limit*b[a])});return c}var j,i,G,H,p,b,C,h,c,r,n,D,K,B;a(this);var J=a.extend({},k.settings),d=a.extend(k.settings,q,J),w=d.wheelOrder,J=d.useShortLabels?d.labelsShort:
    d.labels,A="years,months,days,hours,minutes,seconds".split(","),l={years:{index:6,until:10,limit:31536E6,label:J[0],re:"y",wheel:{}},months:{index:5,until:11,limit:2592E6,label:J[1],re:"m",wheel:{}},days:{index:4,until:31,limit:864E5,label:J[2],re:"d",wheel:{}},hours:{index:3,until:23,limit:36E5,label:J[3],re:"h",wheel:{}},minutes:{index:2,until:59,limit:6E4,label:J[4],re:"i",wheel:{}},seconds:{index:1,until:59,limit:1E3,label:J[5],re:"s",wheel:{}}},z=[],Ba=d.steps||[],R={},y="seconds",aa=0,ea=d.defaultValue||
    Math.max(d.minTime,Math.min(0,d.maxTime)),U=[[]];G=0;h=o(G);K=o(d.minTime);B=o(d.maxTime);a(A).each(function(a,b){i=w.search(RegExp(l[b].re,"i"));-1<i&&(z.push({o:i,v:b}),l[b].index>l[y].index&&(y=b))});z.sort(function(a,b){return a.o>b.o?1:-1});a.each(z,function(a,b){b.v==y&&(aa=a);R[b.v]=a+1;U[0].push(l[b.v].wheel);v(b.v,h)});return{wheels:U,parseValue:function(b){var c=[];b?(a(d.labels).each(function(a,c){b=b.replace(c,"")}),a(d.labelsShort).each(function(a,c){b=b.replace(c,"")}),c=b.replace(/\s+/g,
    " ").split(" ")):(h=o(ea),a.each(z,function(a,b){c.push(h[b.v])}));a(c).each(function(a,b){c[a]=Math.floor(b/(Ba[a]||1))*(Ba[a]||1)});return c},formatResult:function(b){var c="";a(z).each(function(a,d){c+=b[a]+" "+l[d.v].label+" "});return c},validate:function(d,h,i){var l,j;G=f(k.temp);l=o(G);if(h===aa||!b&&(k.temp[aa]<H||k.temp[aa]>p))if(v(y,l),n!==c||D!==r)j=k.temp[aa],C=setTimeout(function(){n=c;D=r;b=!0;k.temp[aa]=j;k.changeWheel([aa],void 0,void 0!==h)},1E3*i);var w=!0,z=!0;a(A).each(function(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            c){if(void 0!==R[c]){var f=a(".dw-ul",d).eq(R[c]-1),h=a(".dw-li",f).index(a('.dw-li[data-val="'+B[c]+'"]',f)),i=a(".dw-li",f).index(a('.dw-li[data-val="'+K[c]+'"]',f));a(".dw-li",f).addClass("dw-v");w&&-1<h&&a(".dw-li",f).slice(h+1).removeClass("dw-v");z&&-1<i&&a(".dw-li",f).slice(0,i).removeClass("dw-v");w=w&&l[c]==B[c];z=z&&l[c]==K[c]}});b=!1},onBeforeShow:function(){d.mode="scroller";d.showLabel=!0;G=f(k.temp);h=o(G);K=o(d.minTime);B=o(d.maxTime);v(y,h)},onMarkupReady:function(b){b.addClass("dw-timespan");
    a(".dwwl"+aa,b).on("mousedown touchstart",function(){clearTimeout(C)})}}}})(jQuery);(function(a){var k=a.mobiscroll,q=new Date,Y={startYear:q.getFullYear()-100,endYear:q.getFullYear()+1,shortYearCutoff:"+10",showNow:!1,stepHour:1,stepMinute:1,stepSecond:1,separator:" "},o=function(v){function f(a,b,c){return void 0!==l[b]?+a[l[b]]:void 0!==c?c:P[z[b]]?P[z[b]]():z[b](P)}function j(a,b,c,d){a.push({values:c,keys:b,label:d})}function i(a,b){return Math.floor(a/b)*b}function G(a){var b=f(a,"h",0);return new Date(f(a,"y"),f(a,"m"),f(a,"d",1),f(a,"a")?b+12:b,f(a,"i",0),f(a,"s",0))}function H(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     c){return a(".dw-li",b).index(a('.dw-li[data-val="'+c+'"]',b))}var p=a(this),b={},C;if(p.is("input")){switch(p.attr("type")){case "date":C="yy-mm-dd";break;case "datetime":C="yy-mm-ddTHH:ii:ssZ";break;case "datetime-local":C="yy-mm-ddTHH:ii:ss";break;case "month":C="yy-mm";b.dateOrder="mmyy";break;case "time":C="HH:ii:ss"}var h=p.attr("min"),p=p.attr("max");h&&(b.minDate=k.parseDate(C,h));p&&(b.maxDate=k.parseDate(C,p))}var c,r,n,D,o,B,J,h=a.extend({},v.settings),d=a.extend(v.settings,Y,b,h),w=0,
    p=[],A=[],l={},z={y:"getFullYear",m:"getMonth",d:"getDate",h:function(a){a=a.getHours();a=U&&12<=a?a-12:a;return i(a,E)},i:function(a){return i(a.getMinutes(),V)},s:function(a){return i(a.getSeconds(),na)},a:function(a){return ea&&11<a.getHours()?1:0}},q=d.preset,R=d.dateOrder,y=d.timeWheels,aa=R.match(/D/),ea=y.match(/a/i),U=y.match(/h/),N="datetime"==q?d.dateFormat+d.separator+d.timeFormat:"time"==q?d.timeFormat:d.dateFormat,P=new Date,E=d.stepHour,V=d.stepMinute,na=d.stepSecond,ga=d.minDate||new Date(d.startYear,
        0,1),ca=d.maxDate||new Date(d.endYear,11,31,23,59,59);C=C||N;if(q.match(/date/i)){a.each(["y","m","d"],function(a,b){c=R.search(RegExp(b,"i"));-1<c&&A.push({o:c,v:b})});A.sort(function(a,b){return a.o>b.o?1:-1});a.each(A,function(a,b){l[b.v]=a});h=[];for(b=0;3>b;b++)if(b==l.y){w++;n=[];r=[];D=ga.getFullYear();o=ca.getFullYear();for(c=D;c<=o;c++)r.push(c),n.push(R.match(/yy/i)?c:(c+"").substr(2,2));j(h,r,n,d.yearText)}else if(b==l.m){w++;n=[];r=[];for(c=0;12>c;c++)D=R.replace(/[dy]/gi,"").replace(/mm/,
    9>c?"0"+(c+1):c+1).replace(/m/,c+1),r.push(c),n.push(D.match(/MM/)?D.replace(/MM/,'<span class="dw-mon">'+d.monthNames[c]+"</span>"):D.replace(/M/,'<span class="dw-mon">'+d.monthNamesShort[c]+"</span>"));j(h,r,n,d.monthText)}else if(b==l.d){w++;n=[];r=[];for(c=1;32>c;c++)r.push(c),n.push(R.match(/dd/i)&&10>c?"0"+c:c);j(h,r,n,d.dayText)}p.push(h)}if(q.match(/time/i)){J=!0;A=[];a.each(["h","i","s","a"],function(a,b){a=y.search(RegExp(b,"i"));-1<a&&A.push({o:a,v:b})});A.sort(function(a,b){return a.o>
    b.o?1:-1});a.each(A,function(a,b){l[b.v]=w+a});h=[];for(b=w;b<w+4;b++)if(b==l.h){w++;n=[];r=[];for(c=0;c<(U?12:24);c+=E)r.push(c),n.push(U&&0==c?12:y.match(/hh/i)&&10>c?"0"+c:c);j(h,r,n,d.hourText)}else if(b==l.i){w++;n=[];r=[];for(c=0;60>c;c+=V)r.push(c),n.push(y.match(/ii/)&&10>c?"0"+c:c);j(h,r,n,d.minuteText)}else if(b==l.s){w++;n=[];r=[];for(c=0;60>c;c+=na)r.push(c),n.push(y.match(/ss/)&&10>c?"0"+c:c);j(h,r,n,d.secText)}else b==l.a&&(w++,r=y.match(/A/),j(h,[0,1],r?["AM","PM"]:["am","pm"],d.ampmText));
    p.push(h)}v.setDate=function(a,b,c,d,f){for(var h in l)v.temp[l[h]]=a[z[h]]?a[z[h]]():z[h](a);v.setValue(v.temp,b,c,d,f)};v.getDate=function(a){return G(a?v.temp:v.values)};v.convert=function(b){var c=b;a.isArray(b)||(c=[],a.each(b,function(b,d){a.each(d,function(a,d){"daysOfWeek"===b&&(d.d?d.d="w"+d.d:d="w"+d);c.push(d)})}));return c};v.format=N;v.buttons.now={text:d.nowText,css:"dwb-n",handler:function(){v.setDate(new Date,!1,0.3,!0,!0)}};d.showNow&&d.buttons.splice(a.inArray("set",d.buttons)+1,
    0,"now");B=d.invalid?v.convert(d.invalid):!1;return{wheels:p,headerText:d.headerText?function(){return k.formatDate(N,G(v.temp),d)}:!1,formatResult:function(a){return k.formatDate(C,G(a),d)},parseValue:function(a){var a=k.parseDate(C,a,d),b,c=[];for(b in l)c[l[b]]=a[z[b]]?a[z[b]]():z[b](a);return c},validate:function(b,c,h,r){var j=v.temp,p={y:ga.getFullYear(),m:0,d:1,h:0,i:0,s:0,a:0},A={y:ca.getFullYear(),m:11,d:31,h:i(U?11:23,E),i:i(59,V),s:i(59,na),a:1},n={h:E,i:V,s:na,a:1},k=f(j,"y"),w=f(j,"m"),
    G=!0,C=!0;a.each("y,m,d,a,h,i,s".split(","),function(c,h){if(l[h]!==void 0){var i=p[h],n=A[h],e=31,s=f(j,h),o=a(".dw-ul",b).eq(l[h]);if(h=="d"){n=e=32-(new Date(k,w,32)).getDate();aa&&a(".dw-li",o).each(function(){var b=a(this),c=b.data("val"),e=(new Date(k,w,c)).getDay(),c=R.replace(/[my]/gi,"").replace(/dd/,c<10?"0"+c:c).replace(/d/,c);a(".dw-i",b).html(c.match(/DD/)?c.replace(/DD/,'<span class="dw-day">'+d.dayNames[e]+"</span>"):c.replace(/D/,'<span class="dw-day">'+d.dayNamesShort[e]+"</span>"))})}G&&
    ga&&(i=ga[z[h]]?ga[z[h]]():z[h](ga));C&&ca&&(n=ca[z[h]]?ca[z[h]]():z[h](ca));if(h!="y"){var g=H(o,i),q=H(o,n);a(".dw-li",o).removeClass("dw-v").slice(g,q+1).addClass("dw-v");h=="d"&&a(".dw-li",o).removeClass("dw-h").slice(e).addClass("dw-h")}s<i&&(s=i);s>n&&(s=n);G&&(G=s==i);C&&(C=s==n);if(B&&h=="d"){for(var y,n=(new Date(k,w,1)).getDay(),g=[],i=0;i<B.length;i++){q=B[i];y=q+"";if(!q.start)if(q.getTime)q.getFullYear()==k&&q.getMonth()==w&&g.push(q.getDate()-1);else if(y.match(/w/i)){y=+y.replace("w",
    "");for(q=y-n;q<e;q=q+7)q>=0&&g.push(q)}else{y=y.split("/");y[1]?y[0]-1==w&&g.push(y[1]-1):g.push(y[0]-1)}}a.each(g,function(b,c){a(".dw-li",o).eq(c).removeClass("dw-v")});s=v.getValidCell(s,o,r).val}j[l[h]]=s}});if(J&&B){var o,D,q,y,L,I,F,K,N,W,P,Z,$,M,S,T,Y={},la=f(j,"d"),pa=new Date(k,w,la),ea=["a","h","i","s"];a.each(B,function(a,b){if(b.start&&(b.apply=!1,o=b.d,D=o+"",y=D.split("/"),o&&(o.getTime&&k==o.getFullYear()&&w==o.getMonth()&&la==o.getDate()||!D.match(/w/i)&&(y[1]&&la==y[1]&&w==y[0]-
    1||!y[1]&&la==y[0])||D.match(/w/i)&&pa.getDay()==+D.replace("w",""))))b.apply=!0,Y[pa]=!0});a.each(B,function(c,d){if(d.start&&(d.apply||!d.d&&!Y[pa])){L=d.start.split(":");I=d.end.split(":");for(F=0;3>F;F++)void 0===L[F]&&(L[F]=0),void 0===I[F]&&(I[F]=59),L[F]=+L[F],I[F]=+I[F];L.unshift(11<L[0]?1:0);I.unshift(11<I[0]?1:0);U&&(12<=L[1]&&(L[1]-=12),12<=I[1]&&(I[1]-=12));$=Z=!0;a.each(ea,function(c,d){if(l[d]!==void 0){q=f(j,d);W=T=S=0;P=void 0;M=a(".dw-ul",b).eq(l[d]);for(F=c+1;F<4;F++){L[F]>0&&(S=
    n[d]);I[F]<A[ea[F]]&&(T=n[d])}K=i(L[c]+S,n[d]);N=i(I[c]-T,n[d]);Z&&(W=K<0?0:K>A[d]?a(".dw-li",M).length:H(M,K)+0);$&&(P=N<0?0:N>A[d]?a(".dw-li",M).length:H(M,N)+1);(Z||$)&&a(".dw-li",M).slice(W,P).removeClass("dw-v");q=v.getValidCell(q,M,r).val;Z=Z&&q==i(L[c],n[d]);$=$&&q==i(I[c],n[d]);j[l[d]]=q}})}})}}}};k.i18n.en=a.extend(k.i18n.en,{dateFormat:"mm/dd/yy",dateOrder:"mmddy",timeWheels:"hhiiA",timeFormat:"hh:ii A",monthNames:"January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthNamesShort:"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),dayNames:"Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),dayNamesShort:"Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),monthText:"Month",dayText:"Day",yearText:"Year",hourText:"Hours",minuteText:"Minutes",secText:"Seconds",ampmText:"&nbsp;",nowText:"Now"});a.each(["date","time","datetime"],function(a,f){k.presets[f]=o;k.presetShort(f)});k.formatDate=function(v,f,j){if(!f)return null;var j=a.extend({},Y,j),
    i=function(a){for(var b=0;p+1<v.length&&v.charAt(p+1)==a;)b++,p++;return b},k=function(a,b,f){b=""+b;if(i(a))for(;b.length<f;)b="0"+b;return b},q=function(a,b,f,h){return i(a)?h[b]:f[b]},p,b="",o=!1;for(p=0;p<v.length;p++)if(o)"'"==v.charAt(p)&&!i("'")?o=!1:b+=v.charAt(p);else switch(v.charAt(p)){case "d":b+=k("d",f.getDate(),2);break;case "D":b+=q("D",f.getDay(),j.dayNamesShort,j.dayNames);break;case "o":b+=k("o",(f.getTime()-(new Date(f.getFullYear(),0,0)).getTime())/864E5,3);break;case "m":b+=
    k("m",f.getMonth()+1,2);break;case "M":b+=q("M",f.getMonth(),j.monthNamesShort,j.monthNames);break;case "y":b+=i("y")?f.getFullYear():(10>f.getYear()%100?"0":"")+f.getYear()%100;break;case "h":var h=f.getHours(),b=b+k("h",12<h?h-12:0==h?12:h,2);break;case "H":b+=k("H",f.getHours(),2);break;case "i":b+=k("i",f.getMinutes(),2);break;case "s":b+=k("s",f.getSeconds(),2);break;case "a":b+=11<f.getHours()?"pm":"am";break;case "A":b+=11<f.getHours()?"PM":"AM";break;case "'":i("'")?b+="'":o=!0;break;default:b+=
    v.charAt(p)}return b};k.parseDate=function(k,f,j){var i=a.extend({},Y,j),j=i.defaultValue||new Date;if(!k||!f)return j;var f="object"==typeof f?f.toString():f+"",q=i.shortYearCutoff,o=j.getFullYear(),p=j.getMonth()+1,b=j.getDate(),C=-1,h=j.getHours(),c=j.getMinutes(),r=0,n=-1,D=!1,K=function(a){(a=w+1<k.length&&k.charAt(w+1)==a)&&w++;return a},B=function(a){K(a);a=f.substr(d).match(RegExp("^\\d{1,"+("@"==a?14:"!"==a?20:"y"==a?4:"o"==a?3:2)+"}"));if(!a)return 0;d+=a[0].length;return parseInt(a[0],
    10)},J=function(a,b,c){a=K(a)?c:b;for(b=0;b<a.length;b++)if(f.substr(d,a[b].length).toLowerCase()==a[b].toLowerCase())return d+=a[b].length,b+1;return 0},d=0,w;for(w=0;w<k.length;w++)if(D)"'"==k.charAt(w)&&!K("'")?D=!1:d++;else switch(k.charAt(w)){case "d":b=B("d");break;case "D":J("D",i.dayNamesShort,i.dayNames);break;case "o":C=B("o");break;case "m":p=B("m");break;case "M":p=J("M",i.monthNamesShort,i.monthNames);break;case "y":o=B("y");break;case "H":h=B("H");break;case "h":h=B("h");break;case "i":c=
    B("i");break;case "s":r=B("s");break;case "a":n=J("a",["am","pm"],["am","pm"])-1;break;case "A":n=J("A",["am","pm"],["am","pm"])-1;break;case "'":K("'")?d++:D=!0;break;default:d++}100>o&&(o+=(new Date).getFullYear()-(new Date).getFullYear()%100+(o<=("string"!=typeof q?q:(new Date).getFullYear()%100+parseInt(q,10))?0:-100));if(-1<C){p=1;b=C;do{i=32-(new Date(o,p-1,32)).getDate();if(b<=i)break;p++;b-=i}while(1)}h=new Date(o,p-1,b,-1==n?h:n&&12>h?h+12:!n&&12==h?0:h,c,r);return h.getFullYear()!=o||h.getMonth()+
    1!=p||h.getDate()!=b?j:h}})(jQuery);

define("mobiscroll", function(){});

define('libs/mobiscroll.i18n.amd',['mobiscroll'], function() {
    'use strict';

    $.mobiscroll.i18n.fr = {
        // Core
        setText: 'Terminer',
        cancelText: 'Annuler',
        clearText: 'Effacer',
        selectedText: 'sélectionné',
        selectedPluralText: 'sélectionnés',
        // Datetime component
        dateFormat: 'dd/mm/yy',
        dateOrder: 'ddmmyy',
        dayNames: ['&#68;imanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
        dayNamesShort: ['&#68;im.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
        dayNamesMin: ['&#68;', 'L', 'M', 'M', 'J', 'V', 'S'],
        dayText: 'Jour',
        monthText: 'Mois',
        monthNames: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
        monthNamesShort: ['Janv.', 'Févr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Août', 'Sept.', 'Oct.', 'Nov.', 'Déc.'],
        hourText: 'Heures',
        minuteText: 'Minutes',
        secText: 'Secondes',
        timeFormat: 'hh:ii A',
        timeWheels: 'hhiiA',
        yearText: 'Année',
        nowText: 'Maintenant',
        pmText: 'après-midi',
        amText: 'avant-midi',
        // Calendar component
        firstDay: 1,
        dateText: 'Date',
        timeText: 'Heure',
        calendarText: 'Calendrier',
        closeText: 'Fermer',
        // Daterange component
        fromText: 'Démarrer',
        toText: 'Fin',
        // Measurement components
        wholeText: 'Entier',
        fractionText: 'Fraction',
        unitText: 'Unité',
        // Time / Timespan component
        labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
        labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs', ''],
        // Timer component
        startText: 'Démarrer',
        stopText: 'Arrêter',
        resetText: 'Réinitialiser',
        lapText: 'Lap',
        hideText: 'Cachez',
        // Listview
        backText: 'Arrière',
        undoText: 'Défaire',
        // Form
        offText: 'Non',
        onText: 'Oui'
    };
    return $.mobiscroll;

});
define('extensions/ui/timers/types/minuteCountUpTimer',['mobiscroll', 'libs/mobiscroll.i18n.amd'], function() {

    'use strict';

    var exports = {
        defaultOptions: {
            stepTime: 15, //in minutes
            hoursString: 'hrs',
            minutesString: 'mins',
            appendMinuteZeroes: true
        },
        createPicker: function(options) {
            this.options = options || {};
            this.options = _.extend(this.defaultOptions, options);

            this.createPickerDropdown();
        },
        createPickerDropdown: function() {
            var self = this,
                lang = window.localStorage.getItem("DEVICE_LANG");

            var langFin = lang ? lang.slice(0,2) : navigator.language;

            this.$select.mobiscroll().timespan({
                    wheelOrder: 'hhii',
                    theme: 'wemoModal minuteCountUpTimer',
                    steps: [1, self.options.stepTime],
                    minTime: 900000,
                    maxTime: 85500000,
                    display: 'modal',
                    rows: 3,
                    headerText: "Start Time",
                    lang: langFin,
                    labels: ['Years', 'Months', 'Days', 'H', 'M', 'Seconds'],
                    buttons: [
                        'cancel',
                        'set'
                    ],
                    closeOnOverlay: false,
                    onBeforeShow: function(inst) {
                        self.onOpen();
                        self.isOpen = true;
                    },
                    onShow: function() {
                        self.isOpen = true;
                    },
                    onClose: function(value, btn) {
                        if (btn === 'set') {
                            var vals = value.split(' ');
                            var hours = parseInt(vals[0], 10);
                            var minutes = parseInt(vals[2], 10);

                            var hoursToMinutes = hours * 60;

                            var time = hoursToMinutes + minutes;
                            self.onClose(time);
                            self.isOpen = false;
                        }
                    }
            });

        },
        onChange: function() {
            var val = parseInt(this.activeView.model.get(this.dataKey), 10);
            console.log('SETTINGS:SYNC:onChange:' + val);
            var hm = this.sandbox.util.secondsToHoursAndMinutes(val * 60, {
                hoursString: ':',
                minutesString: ':',
                appendMinuteZeroes: false
            });

            var $tempEl = $('<div>').append(hm);
            var hours = $tempEl.find('.hourNum').text();
            var minutes = $tempEl.find('.minNum').text();

            this.$select.mobiscroll('setValue', [hours, minutes], true, 1, false);
        }
    };

    return exports;

});

define('extensions/ui/timers/types/timeSelector',['mobiscroll', 'libs/mobiscroll.i18n.amd'], function() {

    'use strict';

    var exports = {
        defaultOptions: {
            hoursString: 'hrs',
            minutesString: 'mins',
            appendMinuteZeroes: true
        },
        createPicker: function(options) {
            this.options = options || {};
            this.options = _.extend(this.defaultOptions, options);
            this.createPickerDropdown();
        },
        createPickerDropdown: function() {
            var select = this.$select[0];
            this.timerType = this.$select.attr('time-picker-key');

            var self = this,
                lang = window.localStorage.getItem("DEVICE_LANG");

            var langFin = lang ? lang.slice(0,2) : navigator.language;


            this.$select.mobiscroll().time({
                wheelOrder: 'hhii',
                theme: 'wemoModal',
                display: 'modal',
                rows: 3,
                steps: [1, self.options.stepTime],
                minTime: 900000,
                maxTime: 82800000,
                lang: langFin,
                closeOnOverlay: false,
                buttons: [
                    'cancel',
                    'set'
                ],
                headerText: function() {
                    var lable = self.$select.parent().find('.realTime').hasClass("timeON");
                    return lable ? "On" : "Off";
                },
                onBeforeShow: function() {
                    self.onOpen();
                    self.isOpen = true;
                    self.activeView.addBackButtonCommand({
                        key: 'closeTimerSelector',
                        callback: function () {
                            self.$select.mobiscroll('hide', false, 'softBackButton');
                        }
                    });
                    var value = self.$select.parent().find('.realTime').text();
                    value = value.replace("am", ":0").replace("pm", ":1").split(":");
                    var h = value[0],
                        m = value[1],
                        d = value[2];
                    h === "12" ? h = "0" : h = h;
                    self.$select.mobiscroll('setValue', [h, m, d]);

                    self.options.selectorType = (self.$select.parent().find('.realTime').hasClass("timeON")) ? "Start" : "End";

                    var blockValue = '';
                    if (self.options.selectorType === 'Start') {
                        blockValue = self.$select.parents().find('.timeOFF').text();
                    } else {
                        blockValue = self.$select.parents().find('.timeON').text();
                    }

                    blockValue = blockValue.replace("am", ":0").replace("pm", ":1").split(":");

                    if (blockValue[2] === '1' && blockValue[0] !== '12') {
                        blockValue[0] = parseInt(blockValue[0],10)+12;
                    }

                    if (blockValue[2] === '0' && blockValue[0] === '12') {
                        blockValue[0] = '00';
                    }

                    var timerOptions = blockValue[0]+":"+blockValue[1];

                    self.$select.mobiscroll('option', { invalid: [{ start: timerOptions, end:  timerOptions }] });

                },
                onShow: function() {
                    self.isOpen = true;
                    $(".dwwl2 .dwwbp").html('<span class="upArrow"></span>');
                    $(".dwwl2 .dwwbm").html('<span class="downArrow"></span>');
                },
                onClose: function(value, btn) {
                    if (btn === 'set') {

                        var seconds = self.sandbox.util.getSecondsFromTime(value);

                        var minutes = seconds / 60;

                        var sec_num = parseInt(seconds, 10);
                        var hours = Math.floor(sec_num / 3600);

                        var minutes = Math.floor((sec_num - (hours * 3600)) / 60);

                        var seconds = sec_num - (hours * 3600) - (minutes * 60);


                        if (minutes < 10) {
                            minutes = "0" + minutes;
                        }

                        var time = hours + ':' + minutes + '<em>am</em>';

                        if (hours > 12) {
                            hours = hours - 12;
                            time = hours + ':' + minutes + '<em>pm</em>';
                        } else if (hours === 0) {
                            hours = 12;
                            time = hours + ':' + minutes + '<em>am</em>';
                        } else if (hours === 12) {
                            time = hours + ':' + minutes + '<em>pm</em>';
                        }

                        $(select).parent().find('.realTime').html(time);

                        self.onClose(seconds);
                        self.isOpen = false;
                        self.activeView.removeBackButtonCommand('closeTimerSelector');
                        if (self.timerType) {
                            if (!self.$select.parents().find('.currentDaySelect').hasClass('daySelect')){
                                self.$select.parents().find('.currentDaySelect').addClass('daySelect');
                                if (typeof self.model.attributes.selectedDaysCounter !== 'undefined'){
                                    self.model.attributes.selectedDaysCounter ++;
                                }

                            }

                        }
                    }
                },
                onCancel: function(){
                    self.activeView.removeBackButtonCommand('closeTimerSelector');
                }

            });

            this.$select.on('click pointerup', function() {

                self.$select.mobiscroll('show');

                if (self.$el.data('picker-header')) {
                    $('.dw-timespan .dwv').after('<div class="dwv-replacement-header">' + self.$el.data('picker-header') + '</div>').hide();
                }
            });
        },
        onChange: function() {
            if (this.dataKey) {

                var val = parseInt(this.activeView.model.get(this.dataKey), 10);

                console.log('SETTINGS:SYNC:onChange:' + val);
                var hm = this.sandbox.util.secondsToHoursAndMinutes(val * 60, {
                    hoursString: ':',
                    minutesString: ':',
                    appendMinuteZeroes: false
                });

                var $tempEl = $('<div>').append(hm);
                var hours = $tempEl.find('.hourNum').text();
                var minutes = $tempEl.find('.minNum').text();

                this.$select.mobiscroll('setValue', [hours, minutes], true, 1, false);
            }
        },
        /**
         * Function to convert seconds to HH:MM ampm
         * @param seconds
         * @returns {string}
         */
        convertTime: function(seconds) {

            var sec_num = parseInt(seconds, 10);
            var hours = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);

            var seconds = sec_num - (hours * 3600) - (minutes * 60);

            if (minutes < 10) {
                minutes = "0" + minutes;
            }
            if (seconds < 10) {
                seconds = "0" + seconds;
            }

            var time = hours + ':' + minutes + '<em>am</em>';

            if (hours > 12) {
                hours = hours - 12;
                time = hours + ':' + minutes + '<em>pm</em>';
            } else if (hours === 0) {
                hours = 12;
                time = hours + ':' + minutes + '<em>am</em>';
            } else if (hours === 12) {
                time = hours + ':' + minutes + '<em>pm</em>';
            }

            return time;

        }
    };

    return exports;

});

define('extensions/ui/timers/types/customMinTimer',['mobiscroll', 'libs/mobiscroll.i18n.amd'], function() {

    'use strict';

    var exports = {
        defaultOptions: {
            appendMinuteZeroes: true
        },
        createPicker: function(options) {
            this.options = options || {};
            this.options = _.extend(this.defaultOptions, options);
            this.createPickerDropdown();
        },
        createPickerDropdown: function() {
            var self = this,
                lang = window.localStorage.getItem("DEVICE_LANG");

            var langFin = lang ? lang.slice(0,2) : navigator.language;

            this.$select.mobiscroll().timespan({
                wheelOrder: 'i',
                theme: 'wemoModal customMinTimer',
                minTime: 60000,
                maxTime: 3600000,
                display: 'modal',
                rows: 3,
                minWidth:200,
                lang: langFin,
                headerText: 'Custom Time',
                labels: ['Y', 'M', 'D', 'H', 'M', 'S'],
                buttons: [
                    'cancel',
                    'set'
                ],
                closeOnOverlay: false,
                onBeforeShow: function(inst) {
                    self.onOpen();
                    self.isOpen = true;
                    self.activeView.addBackButtonCommand({
                        key: 'closeTimerSelector',
                        callback: function() {
                            self.$select.mobiscroll('hide', false, 'softBackButton');
                        }
                    });
                    var value = self.activeView.model.get(self.dataKey);

                    inst.setValue([value]);

                },
                onShow: function() {
                    self.isOpen = true;
                },
                onClose: function(value, btn) {
                    if (btn === 'set') {
                        var m = parseInt(value.split(' ')[0]);
                        self.activeView.model.set(self.dataKey, m);
                        self.isOpen = false;
                        self.activeView.removeBackButtonCommand('closeTimerSelector');
                    }
                },
                onCancel: function() {
                    self.activeView.removeBackButtonCommand('closeTimerSelector');
                    self.activeView.model.set(self.dataKey, '');
                }

            });

            this.$select.on('click pointerup', function() {

                self.$select.mobiscroll('show');
            });
        },
        onChange: function() {
            if (this.dataKey) {

            }
        }

    };

    return exports;

});

/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2012 Rico Sta. Cruz <rico@ricostacruz.com>
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */

(function($) {
    $.transit = {
        version: "0.9.9",

        // Map of $.css() keys to values for 'transitionProperty'.
        // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated
        propertyMap: {
            marginLeft    : 'margin',
            marginRight   : 'margin',
            marginBottom  : 'margin',
            marginTop     : 'margin',
            paddingLeft   : 'padding',
            paddingRight  : 'padding',
            paddingBottom : 'padding',
            paddingTop    : 'padding'
        },

        // Will simply transition "instantly" if false
        enabled: true,

        // Set this to false if you don't want to use the transition end property.
        useTransitionEnd: false
    };

    var div = document.createElement('div');
    var support = {};

    if(!$.fx){
        $.fx = {
            speeds:{
                _default:400
            }
        }
    }

    // Helper function to get the proper vendor property name.
    // (`transition` => `WebkitTransition`)
    function getVendorPropertyName(prop) {
        // Handle unprefixed versions (FF16+, for example)
        if (prop in div.style) return prop;

        var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
        var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

        if (prop in div.style) { return prop; }

        for (var i=0; i<prefixes.length; ++i) {
            var vendorProp = prefixes[i] + prop_;
            if (vendorProp in div.style) { return vendorProp; }
        }
    }

    // Helper function to check if transform3D is supported.
    // Should return true for Webkits and Firefox 10+.
    function checkTransform3dSupport() {
        div.style[support.transform] = '';
        div.style[support.transform] = 'rotateY(90deg)';
        return div.style[support.transform] !== '';
    }

    var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

    // Check for the browser's transitions support.
    support.transition      = getVendorPropertyName('transition');
    support.transitionDelay = getVendorPropertyName('transitionDelay');
    support.transform       = getVendorPropertyName('transform');
    support.transformOrigin = getVendorPropertyName('transformOrigin');
    support.transform3d     = checkTransform3dSupport();

    var eventNames = {
        'transition':       'transitionEnd',
        'MozTransition':    'transitionend',
        'OTransition':      'oTransitionEnd',
        'WebkitTransition': 'webkitTransitionEnd',
        'msTransition':     'MSTransitionEnd'
    };

    // Detect the 'transitionend' event needed.
    var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

    // Populate jQuery's `$.support` with the vendor prefixes we know.
    // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),
    // we set $.support.transition to a string of the actual property name used.
    for (var key in support) {
        if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
            $.support[key] = support[key];
        }
    }

    // Avoid memory leak in IE.
    div = null;

    // ## $.cssEase
    // List of easing aliases that you can use with `$.fn.transition`.
    $.cssEase = {
        '_default':       'ease',
        'in':             'ease-in',
        'out':            'ease-out',
        'in-out':         'ease-in-out',
        'snap':           'cubic-bezier(0,1,.5,1)',
        // Penner equations
        'easeOutCubic':   'cubic-bezier(.215,.61,.355,1)',
        'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
        'easeInCirc':     'cubic-bezier(.6,.04,.98,.335)',
        'easeOutCirc':    'cubic-bezier(.075,.82,.165,1)',
        'easeInOutCirc':  'cubic-bezier(.785,.135,.15,.86)',
        'easeInExpo':     'cubic-bezier(.95,.05,.795,.035)',
        'easeOutExpo':    'cubic-bezier(.19,1,.22,1)',
        'easeInOutExpo':  'cubic-bezier(1,0,0,1)',
        'easeInQuad':     'cubic-bezier(.55,.085,.68,.53)',
        'easeOutQuad':    'cubic-bezier(.25,.46,.45,.94)',
        'easeInOutQuad':  'cubic-bezier(.455,.03,.515,.955)',
        'easeInQuart':    'cubic-bezier(.895,.03,.685,.22)',
        'easeOutQuart':   'cubic-bezier(.165,.84,.44,1)',
        'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
        'easeInQuint':    'cubic-bezier(.755,.05,.855,.06)',
        'easeOutQuint':   'cubic-bezier(.23,1,.32,1)',
        'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
        'easeInSine':     'cubic-bezier(.47,0,.745,.715)',
        'easeOutSine':    'cubic-bezier(.39,.575,.565,1)',
        'easeInOutSine':  'cubic-bezier(.445,.05,.55,.95)',
        'easeInBack':     'cubic-bezier(.6,-.28,.735,.045)',
        'easeOutBack':    'cubic-bezier(.175, .885,.32,1.275)',
        'easeInOutBack':  'cubic-bezier(.68,-.55,.265,1.55)'
    };

    // ## 'transform' CSS hook
    // Allows you to use the `transform` property in CSS.
    //
    //     $("#hello").css({ transform: "rotate(90deg)" });
    //
    //     $("#hello").css('transform');
    //     //=> { rotate: '90deg' }
    //
    $.cssHooks['transit:transform'] = {
        // The getter returns a `Transform` object.
        get: function(elem) {
            return $(elem).data('transform') || new Transform();
        },

        // The setter accepts a `Transform` object or a string.
        set: function(elem, v) {
            var value = v;

            if (!(value instanceof Transform)) {
                value = new Transform(value);
            }

            // We've seen the 3D version of Scale() not work in Chrome when the
            // element being scaled extends outside of the viewport.  Thus, we're
            // forcing Chrome to not use the 3d transforms as well.  Not sure if
            // translate is affectede, but not risking it.  Detection code from
            // http://davidwalsh.name/detecting-google-chrome-javascript
            if (support.transform === 'WebkitTransform' && !isChrome) {
                elem.style[support.transform] = value.toString(true);
            } else {
                elem.style[support.transform] = value.toString();
            }

            $(elem).data('transform', value);
        }
    };

    // Add a CSS hook for `.css({ transform: '...' })`.
    // In jQuery 1.8+, this will intentionally override the default `transform`
    // CSS hook so it'll play well with Transit. (see issue #62)
    $.cssHooks.transform = {
        set: $.cssHooks['transit:transform'].set
    };

    // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not
    // be necessary.
    if ($.fn.jquery < "1.8") {
        // ## 'transformOrigin' CSS hook
        // Allows the use for `transformOrigin` to define where scaling and rotation
        // is pivoted.
        //
        //     $("#hello").css({ transformOrigin: '0 0' });
        //
        $.cssHooks.transformOrigin = {
            get: function(elem) {
                return elem.style[support.transformOrigin];
            },
            set: function(elem, value) {
                elem.style[support.transformOrigin] = value;
            }
        };

        // ## 'transition' CSS hook
        // Allows you to use the `transition` property in CSS.
        //
        //     $("#hello").css({ transition: 'all 0 ease 0' });
        //
        $.cssHooks.transition = {
            get: function(elem) {
                return elem.style[support.transition];
            },
            set: function(elem, value) {
                elem.style[support.transition] = value;
            }
        };
    }

    // ## Other CSS hooks
    // Allows you to rotate, scale and translate.
    registerCssHook('scale');
    registerCssHook('translate');
    registerCssHook('rotate');
    registerCssHook('rotateX');
    registerCssHook('rotateY');
    registerCssHook('rotate3d');
    registerCssHook('perspective');
    registerCssHook('skewX');
    registerCssHook('skewY');
    registerCssHook('x', true);
    registerCssHook('y', true);

    // ## Transform class
    // This is the main class of a transformation property that powers
    // `$.fn.css({ transform: '...' })`.
    //
    // This is, in essence, a dictionary object with key/values as `-transform`
    // properties.
    //
    //     var t = new Transform("rotate(90) scale(4)");
    //
    //     t.rotate             //=> "90deg"
    //     t.scale              //=> "4,4"
    //
    // Setters are accounted for.
    //
    //     t.set('rotate', 4)
    //     t.rotate             //=> "4deg"
    //
    // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)
    // functions.
    //
    //     t.toString()         //=> "rotate(90deg) scale(4,4)"
    //     t.toString(true)     //=> "rotate(90deg) scale3d(4,4,0)" (WebKit version)
    //
    function Transform(str) {
        if (typeof str === 'string') { this.parse(str); }
        return this;
    }

    Transform.prototype = {
        // ### setFromString()
        // Sets a property from a string.
        //
        //     t.setFromString('scale', '2,4');
        //     // Same as set('scale', '2', '4');
        //
        setFromString: function(prop, val) {
            var args =
                (typeof val === 'string')  ? val.split(',') :
                    (val.constructor === Array) ? val :
                        [ val ];

            args.unshift(prop);

            Transform.prototype.set.apply(this, args);
        },

        // ### set()
        // Sets a property.
        //
        //     t.set('scale', 2, 4);
        //
        set: function(prop) {
            var args = Array.prototype.slice.apply(arguments, [1]);
            if (this.setter[prop]) {
                this.setter[prop].apply(this, args);
            } else {
                this[prop] = args.join(',');
            }
        },

        get: function(prop) {
            if (this.getter[prop]) {
                return this.getter[prop].apply(this);
            } else {
                return this[prop] || 0;
            }
        },

        setter: {
            // ### rotate
            //
            //     .css({ rotate: 30 })
            //     .css({ rotate: "30" })
            //     .css({ rotate: "30deg" })
            //     .css({ rotate: "30deg" })
            //
            rotate: function(theta) {
                this.rotate = unit(theta, 'deg');
            },

            rotateX: function(theta) {
                this.rotateX = unit(theta, 'deg');
            },

            rotateY: function(theta) {
                this.rotateY = unit(theta, 'deg');
            },

            // ### scale
            //
            //     .css({ scale: 9 })      //=> "scale(9,9)"
            //     .css({ scale: '3,2' })  //=> "scale(3,2)"
            //
            scale: function(x, y) {
                if (y === undefined) { y = x; }
                this.scale = x + "," + y;
            },

            // ### skewX + skewY
            skewX: function(x) {
                this.skewX = unit(x, 'deg');
            },

            skewY: function(y) {
                this.skewY = unit(y, 'deg');
            },

            // ### perspectvie
            perspective: function(dist) {
                this.perspective = unit(dist, 'px');
            },

            // ### x / y
            // Translations. Notice how this keeps the other value.
            //
            //     .css({ x: 4 })       //=> "translate(4px, 0)"
            //     .css({ y: 10 })      //=> "translate(4px, 10px)"
            //
            x: function(x) {
                this.set('translate', x, null);
            },

            y: function(y) {
                this.set('translate', null, y);
            },

            // ### translate
            // Notice how this keeps the other value.
            //
            //     .css({ translate: '2, 5' })    //=> "translate(2px, 5px)"
            //
            translate: function(x, y) {
                if (this._translateX === undefined) { this._translateX = 0; }
                if (this._translateY === undefined) { this._translateY = 0; }

                if (x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }
                if (y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }

                this.translate = this._translateX + "," + this._translateY;
            }
        },

        getter: {
            x: function() {
                return this._translateX || 0;
            },

            y: function() {
                return this._translateY || 0;
            },

            scale: function() {
                var s = (this.scale || "1,1").split(',');
                if (s[0]) { s[0] = parseFloat(s[0]); }
                if (s[1]) { s[1] = parseFloat(s[1]); }

                // "2.5,2.5" => 2.5
                // "2.5,1" => [2.5,1]
                return (s[0] === s[1]) ? s[0] : s;
            },

            rotate3d: function() {
                var s = (this.rotate3d || "0,0,0,0deg").split(',');
                for (var i=0; i<=3; ++i) {
                    if (s[i]) { s[i] = parseFloat(s[i]); }
                }
                if (s[3]) { s[3] = unit(s[3], 'deg'); }

                return s;
            }
        },

        // ### parse()
        // Parses from a string. Called on constructor.
        parse: function(str) {
            var self = this;
            str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
                self.setFromString(prop, val);
            });
        },

        // ### toString()
        // Converts to a `transition` CSS property string. If `use3d` is given,
        // it converts to a `-webkit-transition` CSS property string instead.
        toString: function(use3d) {
            var re = [];

            for (var i in this) {
                if (this.hasOwnProperty(i)) {
                    // Don't use 3D transformations if the browser can't support it.
                    if ((!support.transform3d) && (
                        (i === 'rotateX') ||
                            (i === 'rotateY') ||
                            (i === 'perspective') ||
                            (i === 'transformOrigin'))) { continue; }

                    if (i[0] !== '_') {
                        if (use3d && (i === 'scale')) {
                            re.push(i + "3d(" + this[i] + ",1)");
                        } else if (use3d && (i === 'translate')) {
                            re.push(i + "3d(" + this[i] + ",0)");
                        } else {
                            re.push(i + "(" + this[i] + ")");
                        }
                    }
                }
            }

            return re.join(" ");
        }
    };

    function callOrQueue(self, queue, fn) {
        if (queue === true) {
            self.queue(fn);
        } else if (queue) {
            self.queue(queue, fn);
        } else {
            fn();
        }
    }

    // ### getProperties(dict)
    // Returns properties (for `transition-property`) for dictionary `props`. The
    // value of `props` is what you would expect in `$.css(...)`.
    function getProperties(props) {
        var re = [];

        $.each(props, function(key) {
            key = $.camelCase(key); // Convert "text-align" => "textAlign"
            key = $.transit.propertyMap[key] || $.cssProps[key] || key;
            key = uncamel(key); // Convert back to dasherized

            if ($.inArray(key, re) === -1) { re.push(key); }
        });

        return re;
    }

    // ### getTransition()
    // Returns the transition string to be used for the `transition` CSS property.
    //
    // Example:
    //
    //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');
    //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'
    //
    function getTransition(properties, duration, easing, delay) {
        // Get the CSS properties needed.
        var props = getProperties(properties);

        // Account for aliases (`in` => `ease-in`).
        if ($.cssEase[easing]) { easing = $.cssEase[easing]; }

        // Build the duration/easing/delay attributes for it.
        var attribs = '' + toMS(duration) + ' ' + easing;
        if (parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }

        // For more properties, add them this way:
        // "margin 200ms ease, padding 200ms ease, ..."
        var transitions = [];
        $.each(props, function(i, name) {
            transitions.push(name + ' ' + attribs);
        });

        return transitions.join(', ');
    }

    // ## $.fn.transition
    // Works like $.fn.animate(), but uses CSS transitions.
    //
    //     $("...").transition({ opacity: 0.1, scale: 0.3 });
    //
    //     // Specific duration
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500);
    //
    //     // With duration and easing
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');
    //
    //     // With callback
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });
    //
    //     // With everything
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });
    //
    //     // Alternate syntax
    //     $("...").transition({
    //       opacity: 0.1,
    //       duration: 200,
    //       delay: 40,
    //       easing: 'in',
    //       complete: function() { /* ... */ }
    //      });
    //
    $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
        var self  = this;
        var delay = 0;
        var queue = true;

        // Account for `.transition(properties, callback)`.
        if (typeof duration === 'function') {
            callback = duration;
            duration = undefined;
        }

        // Account for `.transition(properties, options)`.
        if (typeof duration === 'object') {
            easing = duration.easing;
            delay = duration.delay || 0;
            queue = duration.queue || true;
            callback = duration.complete;
            duration = duration.duration;
        }

        // Account for `.transition(properties, duration, callback)`.
        if (typeof easing === 'function') {
            callback = easing;
            easing = undefined;
        }

        // Alternate syntax.
        if (typeof properties.easing !== 'undefined') {
            easing = properties.easing;
            delete properties.easing;
        }

        if (typeof properties.duration !== 'undefined') {
            duration = properties.duration;
            delete properties.duration;
        }

        if (typeof properties.complete !== 'undefined') {
            callback = properties.complete;
            delete properties.complete;
        }

        if (typeof properties.queue !== 'undefined') {
            queue = properties.queue;
            delete properties.queue;
        }

        if (typeof properties.delay !== 'undefined') {
            delay = properties.delay;
            delete properties.delay;
        }

        // Set defaults. (`400` duration, `ease` easing)
        if (typeof duration === 'undefined') { duration = $.fx.speeds._default; }
        if (typeof easing === 'undefined')   { easing = $.cssEase._default; }

        duration = toMS(duration);

        // Build the `transition` property.
        var transitionValue = getTransition(properties, duration, easing, delay);

        // Compute delay until callback.
        // If this becomes 0, don't bother setting the transition property.
        var work = $.transit.enabled && support.transition;
        var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

        // If there's nothing to do...
        if (i === 0) {
            var fn = function(next) {
                self.css(properties);
                if (callback) { callback.apply(self); }
                if (next) { next(); }
            };

            callOrQueue(self, queue, fn);
            return self;
        }

        // Save the old transitions of each element so we can restore it later.
        var oldTransitions = {};

        var run = function(nextCall) {
            var bound = false;

            // Prepare the callback.
            var cb = function() {
                if (bound) { self.unbind(transitionEnd, cb); }

                if (i > 0) {
                    self.each(function() {
                        this.style[support.transition] = (oldTransitions[this] || null);
                    });
                }

                if (typeof callback === 'function') { callback.apply(self); }
                if (typeof nextCall === 'function') { nextCall(); }
            };

            if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
                // Use the 'transitionend' event if it's available.
                bound = true;
                self.bind(transitionEnd, cb);
            } else {
                // Fallback to timers if the 'transitionend' event isn't supported.
                window.setTimeout(cb, i);
            }

            // Apply transitions.
            self.each(function() {
                if (i > 0) {
                    this.style[support.transition] = transitionValue;
                }
                $(this).css(properties);
            });
        };

        // Defer running. This allows the browser to paint any pending CSS it hasn't
        // painted yet before doing the transitions.
        var deferredRun = function(next) {
            this.offsetWidth; // force a repaint
            run(next);
        };

        // Use jQuery's fx queue.
        callOrQueue(self, queue, deferredRun);

        // Chainability.
        return this;
    };

    function registerCssHook(prop, isPixels) {
        // For certain properties, the 'px' should not be implied.
        if (!isPixels) { $.cssNumber[prop] = true; }

        $.transit.propertyMap[prop] = support.transform;

        $.cssHooks[prop] = {
            get: function(elem) {
                var t = $(elem).css('transit:transform');
                return t.get(prop);
            },

            set: function(elem, value) {
                var t = $(elem).css('transit:transform');
                t.setFromString(prop, value);

                $(elem).css({ 'transit:transform': t });
            }
        };

    }

    // ### uncamel(str)
    // Converts a camelcase string to a dasherized string.
    // (`marginLeft` => `margin-left`)
    function uncamel(str) {
        return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
    }

    // ### unit(number, unit)
    // Ensures that number `number` has a unit. If no unit is found, assume the
    // default is `unit`.
    //
    //     unit(2, 'px')          //=> "2px"
    //     unit("30deg", 'rad')   //=> "30deg"
    //
    function unit(i, units) {
        if ((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
            return i;
        } else {
            return "" + i + units;
        }
    }

    // ### toMS(duration)
    // Converts given `duration` to a millisecond string.
    //
    //     toMS('fast')   //=> '400ms'
    //     toMS(10)       //=> '10ms'
    //
    function toMS(duration) {
        var i = duration;

        // Allow for string durations like 'fast'.
        if (typeof i === 'string') { i = $.fx.speeds[i] || $.fx.speeds._default; }

        return unit(i, 'ms');
    }

    // Export some functions for testable-ness.
    $.transit.getTransitionValue = getTransition;
})(jQuery);
define("plugins/jquery.transit", function(){});

//
define('extensions/ui/timers/formlistselect', ['backbone', 'extensions/ui/timers/types/minuteCountUpTimer', 'extensions/ui/timers/types/timeSelector','extensions/ui/timers/types/customMinTimer', 'plugins/jquery.transit', 'mobiscroll'], function(Backbone, MinuteCountUpTimer, TimeSelector,CustomMinTimer) {

    'use strict';


    var aura;

    var FormListSelect = Backbone.View.extend({
        initialize: function(options) {

            _.extend(this, options);
            _.bindAll(this);

            this.dataKey = this.$el.attr('data-picker-key');
            this.$select = this.$('select');
            this.liHtml = this.$('.form-list-select');

            this.model = this.activeView.model;
            this.listenTo(this.model, 'change', this.onChange);

            this.create();

        },
        create: function() {
            this.createPicker();
            /* if (this.activeView.modelToSave) {
             this.stopListening(this.model);
             this.model = this.activeView.modelToSave;
             this.listenTo(this.model, 'change', this.onChange);
             }*/
        },
        onOpen: function() {
            this.sandbox.emit('stopConfirm');
        },
        onClose: function(time) {
            this.sandbox.emit('startConfirm');
            this.model.set(this.dataKey, time);
        }
    });



    var exports = {
        MinuteCountUpTimer: FormListSelect.extend(MinuteCountUpTimer)
    };
    var exportsTimeSelector = {
        TimeSelector: FormListSelect.extend(TimeSelector)
    };
    var exportsCustomMinTimer = {
        CustomMinTimer: FormListSelect.extend(CustomMinTimer)
    };


    var init = {
        initialize: function(app) {
            aura = app;
            app.core.dom.FormListSelect = exports;
        }
    };



    return _.extend(init, exports, exportsTimeSelector,exportsCustomMinTimer);

});

define('extensions/ui/formlistaccordion', ['backbone', 'plugins/jquery.transit'], function(Backbone) {

    'use strict';


    var FormListAccordion = Backbone.View.extend({
        events: {
            'select open': 'onOpen',
            'select close': 'onClose',
            'select change': 'onChange',
            'select blur': 'onChange'
        },
        initialize: function(options) {
            _.extend(this, options);
            _.bindAll(this);

            this.sandbox.off('finishOpen', this.create);
            this.sandbox.on('finishOpen', this.create);

        },
        create: function() {

            //add a timeout for functions that require the template to be in the regular DOM
            var height = 0;
            var self = this;
            var $previous = this.$el.prev();
            var $input = this.$el.find('input');
            var $anchors = this.$el.find('anchor');
            var alter = false;

            if (this.sandbox.device.os !== 'ios' && this.$el.attr('data-visibility') && this.$el.attr('data-visibility') === 'alwaysOpen') {
                alter = true;
            }


            if (!alter) {
                $previous.hammer().on('tap', function(e) {
                    self.handle(e, $input);
                });
            }

            $anchors.hammer().on('tap', function(e) {

                self.sandbox.emit('stopConfirm');
                self.sandbox.emit('startConfirm');
                var $el = $(e.currentTarget);

                var currentVal = $input.val();
                var key = $input.attr('data-key');
                var $prevValue = $previous.find('.value');
                var newVal = $el.attr('data-value');


                $input.val(newVal);
                $input.trigger('change');
                $anchors.removeClass('selected');
                $el.addClass('selected');
                $prevValue.removeClass('selected').removeClass(key + '-' + currentVal);
                $prevValue.addClass(key + '-' + newVal);
                $prevValue.attr('data-value', newVal);
                //  $previous.find('.value').removeClass('selected');

                //triggers select if we close too fast.
                if (!alter) {
                    setTimeout(function() {
                        self.parent._clearActiveAndOpen();
                    }, 400);
                }

            });

            $anchors.each(function() {
                height += parseInt($(this).outerHeight(), 10);
            });

            this.$el.data('height', height);


        },
        handle: function(e) {
            //  console.log(e);
            var $el = $(e.currentTarget);
            var $html = $('html');
            var listHeight = 0;
            var $value = $el.find('.value');

            var $next = $el.next();
            if ($next.hasClass('open')) {
                $next.css('height', 0);
                $next.removeClass('open');
                $el.find('.value').removeClass('selected');
                /** closing it, emit start confirm event to restart inactivity timer **/
                DEBUG && console.log('CONFIRM:EMITTING START:' + this.sandbox.ref);
                this.sandbox.emit('startConfirm');

            } else {

                listHeight = $next.data('height');

                this.parent._clearActiveAndOpen();
                //if android, remove the selected option from the list
                if (!$html.hasClass('ios')) {
                    var value = $value.attr('data-value');
                    var anchors = $next.find('anchor').length - 1;
                    var $selected = $next.find('*[data-value="' + value + '"]');
                    listHeight = parseInt($selected.outerHeight(), 10) * anchors;

                    $value.addClass('selected');
                    $selected.hide();

                }
                $next.css('height', parseInt(listHeight, 10));
                $next.addClass('open');
                DEBUG && console.log('CONFIRM:EMITTING STOP:' + this.sandbox.ref);
                this.sandbox.emit('stopConfirm');
                //  $el.addClass('active');
            }
        },
        undo: function() {
            if (this.$originalAccordion) {
                this.$originalAccordion.parent().find('anchor').removeClass('selected');
                this.$originalAccordion.addClass('selected');
            }
        }
    });


    return FormListAccordion;

});
define('extensions/ui/horizontalslider/formlistslider', ['backbone'], function (Backbone) {

    'use strict';


    var $activeItem, $secondLevelNext, $secondLevelPrev, $thirdLevelNext, $thirdLevelPrev, $container;
    var FormListSlider = Backbone.View.extend({
        events: {

        },
        initialize: function (options) {
            _.extend(this, options);
            _.bindAll(this);

            this.currentValue = this.$el.attr('data-picker-key');
            this.isSaveAction = this.$el.attr('save-action');
            this.resetPeekaboo = this.$el.attr('resetPeekaboo');
            this.enableOnSwipe = this.$el.attr('enableOnSwipe');
            this.variableToSave = this.$el.attr('save-variable');
            this.defaultValue = this.activeView.model.get(this.currentValue);
            this.defaultTemp = this.$el.attr('data-temp');
            this.defaultTempValue = this.activeView.model.get(this.defaultTemp);
            if (this.isSaveAction === "yes" && this.$el.find('.tumbler').length === 0) {
                this.setOptions();
                this.create();
            }


        },

        getId: function () {
            return this.currentValue;
        },
        setOptions: function () {
            this.defaultTempValue = this.activeView.model.get(this.defaultTemp);
            var minValue, maxValue;
            if (parseInt(this.defaultTempValue, 10) === 1) {
                minValue = 60;
                maxValue = 85;
            } else if (parseInt(this.defaultTempValue, 10) === 0) {
                minValue = 16;
                maxValue = 29;
            }
            this.minValue =  minValue;
            this.maxValue = maxValue;
            this.symbol = '°';
        },
        /**
         * Logic to add the elements for the slider, it assigns the corresponding class for each element
         */
        create: function () {
            this.updateValues();
            this.tempValues();

        },
        updateValues : function() {
            this.defaultValue = parseInt(this.activeView.model.get(this.currentValue),10);
            this.runValue = parseInt(this.activeView.model.get(this.enableOnSwipe),10);
            if (this.defaultValue > this.maxValue) {
                this.defaultValue = this.maxValue;
            } else if (this.defaultValue < this.minValue) {
                this.defaultValue = this.minValue;
            }
            this.$el = this.activeView.$el;
            this.$el.find(".tempPicker .tempDisplay").text(this.defaultValue + this.symbol);
        },
        tempValues: function () {
            var self = this;
            self.$el = self.activeView.$el;
            var increment = function() {
                if (self.defaultValue == self.maxValue) {
                    self.defaultValue =  self.minValue - 1;
                }
                self.defaultValue++;
                self.$el.find(".tempPicker .tempDisplay").text(self.defaultValue+self.symbol);
                self.activeView.scheduleTemp = self.defaultValue;
                self.setVariable(self.defaultValue);
                return false;
            };
            
            var decrement = function() {
                if (self.defaultValue == self.minValue) {
                    self.defaultValue = self.maxValue + 1;
                }
                self.defaultValue--;
                self.$el.find(".tempPicker .tempDisplay").text(self.defaultValue+self.symbol);

                self.activeView.scheduleTemp = self.defaultValue;
                self.setVariable(self.defaultValue);
                return false;
            };
            
            var timer = null;
            
            var beginIncrementing = function () {
                increment();
                timer = setInterval(increment, 250);
            };
            
            var endIncrementing = function () {
                clearInterval(timer);
            };
            
            var beginDecrementing = function () {
                decrement();
                timer = setInterval(decrement, 250);
            };
            
            var endDecrementing = function () {
                clearInterval(timer);
            };
            
            this.$el.find('.tempPicker .plusBtn').hammer().on('touchstart', beginIncrementing);
            this.$el.find('.tempPicker .plusBtn').hammer().on('touchend', endIncrementing);
            this.$el.find('.tempPicker .plusBtn').hammer().on('touchcancel', endIncrementing);

            this.$el.find(".tempPicker .minusBtn").hammer().on('touchstart', beginDecrementing);
            this.$el.find(".tempPicker .minusBtn").hammer().on('touchend', endDecrementing);
            this.$el.find(".tempPicker .minusBtn").hammer().on('touchcancel', endDecrementing);
        },
        /**
         * Sets the active value to the model
         */
        setVariable: function (value) {
            var self = this;
            clearTimeout(this.action);
            this.action = setTimeout(function() {

                if (self.isSaveAction === "yes") {
                    var validateValue = self.activeView.model.validateTempUnit(value, 'set');
                    self.activeView.model.set('lastTemperature', validateValue);
                    self.activeView.model.set(self.variableToSave, validateValue);
                    self.activeView.model.saveAction([self.variableToSave]);
                } else {
                    self.activeView.model.set(self.currentValue, value);
                }
            }, 1500);
        },
        /**
         * Checks the new value for the variable of the model
         */
        onChange: function () {
            var value = this.activeView.model.get(this.currentValue);
        }

    });


    return FormListSlider;

});

define('extensions/views/backbone.processedview', ['Cache', 'extensions/ui/timers/formlistselect', 'extensions/ui/formlistaccordion', 'extensions/ui/horizontalslider/formlistslider'], function(Backbone, FormListSelect, FormListAccordion, FormListSlider) {
    'use strict';



    /** the goal of processedView is to automate certain pieces of the application, such as creating specific types of pickers and stuff **/

    //
    /** add new tags here as needed for automated processing **/
    var arrayTagsToProcess = ['form-list-accordion', 'form-list-select', 'form-list-slider'];


    function getFunctionName(name) {
        var str = name.split('-');
        str.forEach(function(value, index) {
            str[index] = value[0].toUpperCase() + value.substring(1, value.length);
        });
        var funcName = str.join('');
        return funcName;
    }

    var ProcessedView = Backbone.View.extend({

        initialize: function(options) {

            var self = this;
            this.sandbox = options.sandbox;
            this.activeView = options.activeView;
            this.$el = options.$el;
            this.findTagsToProcess();




            /** undo is found in the cancel event of the view */
            this.sandbox.off('undo');
            this.sandbox.on('undo', function() {
                self._undo();
            });

        },
        findTagsToProcess: function() {

            var self = this;

            this.$el.each(function() {

                for (var i = 0; i < arrayTagsToProcess.length; i++) {
                    var $tag = $(this).find('.' + arrayTagsToProcess[i]);
                    if ($tag.length > 0) {

                        var funcName = getFunctionName(arrayTagsToProcess[i]);
                        self['process' + funcName]($tag);
                    }
                }
            });
        },
        processFormListAccordion: function($tag) {

            var self = this;

            if (!this.sandbox.formListAccordion) {
                this.sandbox.formListAccordion = {};
            }

            $tag.each(function() {

                var el = this;
                var id = _.size(self.sandbox.formListAccordion) + 1;

                if (!self.sandbox.formListAccordion[id]) {
                    self.sandbox.formListAccordion[id] = new FormListAccordion({
                        el: el,
                        sandbox: self.sandbox,
                        parent: self,
                        activeView: self.activeView
                    });
                }
            });


        },
        processFormListSelect: function($tag) {
//
//            var self = this;
//
//
//
//            if (!this.sandbox.formListSelect) {
//                this.sandbox.formListSelect = {};
//            }
//
//            $tag.each(function() {
//                var selectType;
//                if ($(this).attr('data-picker-type').match(/countuptimer/gi)) {
//                    selectType = 'MinuteCountUpTimer';
//                }
//                if ($(this).attr('data-picker-type').match(/timeselector/gi)) {
//                    selectType = 'TimeSelector';
//                }
//                if ($(this).attr('data-picker-type').match(/mintimer/gi)) {
//                    selectType = 'CustomMinTimer';
//                }
//
//                var el = this;
//                var id = _.size(self.sandbox.formListSelect) + 1;
//                console.log('ACTIVEVIEW', self.activeView);
//                self.sandbox.formListSelect[id] = new FormListSelect[selectType]({
//                    el: el,
//                    sandbox: self.sandbox,
//                    parent: self,
//                    activeView: self.activeView
//                });
//            });
        },
        processFormListSlider: function($tag) {
            var self = this;
            if (!this.sandbox.formListSlider) {
                this.sandbox.formListSlider = {};
            }
            $tag.each(function() {
                var el = this;
                var id = _.size(self.sandbox.formListSlider) + 1;
                if (!self.sandbox.formListSlider[id]) {
                    self.sandbox.formListSlider[id] = new FormListSlider({
                        el: el,
                        sandbox: self.sandbox,
                        parent: self,
                        activeView: self.activeView
                    });
                }
            });

        },

        _clearActiveAndOpen: function() {
            var self = this;
            this.$el.find('anchor').show();
            this.$el.find('.selected').each(function() {
                var $this = $(this);
                var clear = true;
                if (self.sandbox.device.os !== 'ios' && $this.parent().attr('data-visibility') && $this.parent().attr('data-visibility') === 'alwaysOpen') {
                    clear = false;
                }
                if (clear) {
                    $(this).removeClass('selected');
                }
            });
            this.$el.find('.active').removeClass('active');
            this.$el.find('.open').css('height', 0).removeClass('open');
        },
        _undo: function() {
            this.undoFormListAccordion();
            this._clearActiveAndOpen();
        }
    });

    Backbone.ProcessedView = ProcessedView;

    //empty init, since we're adding it to backbone.
    return {
        initialize: function() {}
    };


});

define('extensions/views/backbone.drawerMaster', ['Cache', 'libs/pouchInterface'], function(Backbone, pouchInterface) {

    'use strict';

    var aura;

    Backbone.DrawerMasterView = Backbone.View.extend({
        tagName: 'div',
        /**
         * adds event binding to elements, clicks are converted to pointerup events
         */
        events: {},
        drawerIsOpen: false,
        /**
         * runs the first time the view is created. Only runs once, unless the widget is destroyed
         * @param options {object}
         */
        initialize: function(options) {
            var self = this;
            this.options = options || {};
            if (this.options.sandbox) {
                this.sandbox = this.options.sandbox;
                this.model = this.sandbox.model;
            } else {
                throw ('you need to pass the sandbox to any child views');
            }

            _.bindAll(this);

            _.each(this.loadedViews, function(value, index) {
                self.loadedViews[index].hasRendered = false;
            });

            this.pastView = '';
            this.childViews = {};

            this.$el.addClass('smart-drawer');
            this.$el.attr('id', this.cid);
            this.listen();
            this.render();

            if (this.changeViewListener) {
                this.changeViewListener();
            }
        },
        /**
         * if this is a group, add the list of grouped items when the drawer is opened
         * @param  {DOM Fragment} $grouplist the list of grouped items
         */
        renderGroupList: function($grouplist) {
            this.$grouplist = $grouplist;
            this.sandbox.view.drawerView.$('section.content').append(this.$grouplist);
        },
        /**
         * put non-DOM event listeners here. These need to be removed when no longer necessary to free up memory (this.stopListening())
         */
        listen: function() {
            var self = this;

            this._rev = this.model.get('_rev');

            this.sandbox.on('renderGroupList', this.renderGroupList);
            this.sandbox.on('widgetTemplate', this.setWidgetTemplate);
            this.sandbox.on('drawer.open', function() {
                self.sandbox.emit('global.drawer:open');
                self.drawerIsOpen = true;
                self._makeScrollable();
                self.openListen();
                //self.render();
            });

            this.sandbox.on('drawer.close', function() {
                //need to alert the list so we know when it is safe to update the list. cannot update the list while the drawer is open.
                //why global? because this is generic.
                //drawer.close events are specific to the sandbox and we probably don't want them to happen whenever ANY drawer closes.
//                self.sandbox.emit('drawer.finishClose');
                self.sandbox.emit('global.drawer:close');
                self.drawerIsOpen = false;
                self.stopListen();
            });

//            this.sandbox.on('drawer.finishClose', function() {
//                self.drawerIsOpen = false;
//                self.currentView = null;
//                if (self.$groupList) {
//                    self.$grouplist.detach(); //preserve the events, since this isnt recreated.
//                }
//            });
        },
        openListen: function() {
            var self = this;
            //var changeView = _.throttle(self.changeView, 300);
            this.listenTo(this.model, 'syncFromCache', this.sync);
            this.listenTo(this.model, 'syncFromSubscription', this.sync);
            this.listenTo(this.model, 'syncDeviceAndStatus', this.sync);
            this.listenTo(this.model, 'save', this.sync);
            this.sandbox.on('changeView', this.changeView);
            this.sandbox.on('resetTimer', this.resetTimer);
        },
        stopListen: function() {
            this.sandbox.off('changeView', this.changeView);
            this.sandbox.off('widgetTemplate', this.setWidgetTemplate);
            this.sandbox.off('resetTimer', this.resetTimer);
            this.stopListening(this.model);
        },
        setWidgetTemplate: function(options) {
            var self = this;
            options.activeView = self.activeView;
            self.sandbox.processedView = new Backbone.ProcessedView(options);
        },
        resetTimer: function() {
            var self = this;
            self.sandbox.isTimerSet = false;
            if (self.drawerIsOpen) {
                self.render();
            }
        },
        /**
         * gets the data
         */
        fetch: function() {
            //this.model.fetchFromCache();
        },
        /**
         * is called whenever a fetch completes, to handle the incoming data
         */
        sync: function() {
//            if (this.needToChangeView) {
                var self = this;
                if (this.drawerIsOpen) {
                    this.render();
                }
                this.sandbox.emit('drawer.change');
//            }

        },
        destroyDrawers: function() {
            delete this.childViews;
            this.childViews = {};
        },
        /**
         * ui logic, changes the visible view in the app drawer. only changes if the view has changed?
         * start listening again, stop listening to past view.
         * @param view {Backbone.view}
         */
        changeView: function(view) {
            var self = this;
            var newView = false;
            var options = {
                sandbox: this.sandbox,
                parentView: this
            };

            if (this.activeView && this.activeView.stopView) {
                this.activeView.isDrawerOpen = false;
                this.activeView.stopView();
            }

            if (view !== this.currentView) {

                if (!this.childViews[view]) {
                    this.childViews[view] = new this.loadedViews[view].view(options);
                    this.childViews[view].parentView = this;
                    newView = true;
                }

                this.activeView = this.childViews[view];

                if (this.loadedViews[view].viewType === 'overlay') {
                    this.childViews[view].initialRender();
                    this.childViews[view].open();
                    this.childViews[view].$el.resizeElement();
                } else {
                    this.$el.empty().append(this.childViews[view].$el);
                    this.childViews[view].initialRender(view);

                    if (this.childViews[view].renderOnce) {
                        this.childViews[view].renderOnce();
                    }

                    this.childViews[view].render();
                    setTimeout(function() {
                        self.childViews[view]._makeScrollable();
                    }, 100);
                    this.currentView = view;
                }
            }

            if (this.childViews[view].startView) {
                this.childViews[view].startView();
            }
        }
    });

    return {
        initialize: function(app) {
            aura = app;
        }
    };
});

define('extensions/views/backbone.drawerBase', ['Cache', 'libs/pouchInterface'], function(Backbone, pouchInterface) {

    'use strict';

    var aura;

    Backbone.DrawerBaseView = Backbone.View.extend({
        /**
         * run the first time the view is created
         * @param options
         */
        type: 'drawer',
        initialize: function(options) {
            var self = this;
            _.bindAll(this);
            this.options = options || {};
            if (this.options.sandbox) {
                this.sandbox = this.options.sandbox;
                this.model = this.sandbox.model;
            } else {
                throw ('you need to pass the sandbox to any child views');
            }

            this.sandbox.emit('drawer.change');
        },
        initialRender: function(viewName) {
            DEBUG && console.log('DRAWER:TIMER: turning on sync');
            if (!this.$el.html()) {
                viewName = viewName.replace(/\s/gi, '');
                this.$el.addClass(viewName);
                var html = this.i18n(this.template);
                this.$el.html(html);
            }
        },
        /**
         * put non-DOM event listeners here. These need to be removed when no longer necessary to free up memory (this.stopListening())
         */
        startListening: function() {
            var self = this;

//            this.stopListening();
            self.delegateEvents();

            this.sandbox.on('drawer.open', function(){
                self.checkRules();
                if (self.rulesSync) {
                    self.rulesSync();
                }
            });

            if (this.listen) {
                this.listen();
            }

            this.sandbox.on('drawer.close', this.stopView);

        },
        closeCallback: function() {
            this.stopView();
        },
        /**
         * gets the data
         */
        fetch: function() {
            this.model.fetchFromCache();
        },
        startView: function() {
            DEBUG && console.log('startview:' + this.cid);

            this.sandbox.globalsettings.checkForChanges();
            this.startListening();
            this.stickit();
            this.delegateEvents();
        },
        stopView: function() {
            DEBUG && console.log('stopview:' + this.cid);
//            this.undelegateEvents();
//            this.unstickit();
//            this.stopListening();
            this.sandbox.off('drawer.close', this.closeCallback);
            this.removeBackButtonCommand(); //remove any potential back button commands for this view
            if (this.rulesEngine) {
                this.rulesEngine.collection.off('sync', this.rulesSync);
            }
            if (this.stop) {
                this.stop();
            }
        },
        /**
         * overridden in specific widgets that need it. take action when drawer is closed.
         */
        onClose: function() {}
    });

    return {
        initialize: function(app) {
            aura = app;
        }
    };
});
define('extensions/utils/converters', [], function() {

    'use strict';

    var bitArray = ["1", "10", "11", "0001", "0010", "0011", "01"];

    function Converter() {

    }

    function removeFromArray(array, callback) {
        var index = -1,
            length = array ? array.length : 0,
            result = [];


        while (++index < length) {
            var value = array[index];
            if (callback(value, index, array)) {
                result.push(value);
                array.splice.call(array, index--, 1);
                length--;
            }
        }
        return result;
    }

    Converter.prototype = {
        temperature: function(unit, value) {
            if (unit === 'C') {
                value = Math.round((value - 32) * 5 / 9);
            } else {
                value = Math.round((value * 9 / 5) + 32);
            }
            return value;
        },
        hextobinbase: function(n, to, from) {
            return parseInt(n, from || 10).toString(to);
        },
        bitToString: function(numberArray, number, bitMessage) {
            bitMessage = bitMessage.toString().split('');
            bitMessage = bitMessage.reverse();
            bitMessage = bitMessage.join("");

            if (_.indexOf(bitArray, bitMessage) != -1) {
                if (number >= 8 && number <= 11) {
                    return 'batteryLevel';
                } else if (number >= 12 && number <= 15) {
                    return 'signalStrength';
                }
            }
        }
    };


    return {
        initialize: function(app) {
            app.core.util.converter = new Converter();
            app.core.util.removeFromArray = removeFromArray;
        }
    };
});
define('extensions/utils/transitionend',[],function() {

    'use strict';

    function whichTransitionEvent(){
        var t;
        var el = document.createElement('fakeelement');
        var transitions = {
            'transition':'transitionend',
            'OTransition':'oTransitionEnd',
            'MozTransition':'transitionend',
            'WebkitTransition':'webkitTransitionEnd'
        };

        for(t in transitions){
            if( el.style[t] !== undefined ){
                return transitions[t];
            }
        }
    }

    function getVendorPropertyName(prop) {
        // Handle unprefixed versions (FF16+, for example)
        if (prop in div.style) return prop;

        var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
        var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

        if (prop in div.style) { return prop; }

        for (var i=0; i<prefixes.length; ++i) {
            var vendorProp = prefixes[i] + prop_;
            if (vendorProp in div.style) { return vendorProp; }
        }
    }

    // Helper function to check if transform3D is supported.
    // Should return true for Webkits and Firefox 10+.
    function checkTransform3dSupport() {
        div.style[support.transform] = '';
        div.style[support.transform] = 'rotateY(90deg)';
        return div.style[support.transform] !== '';
    }

    var div = document.createElement('div');
    var support = {};
    var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

    support.transition      = getVendorPropertyName('transition');
    support.transitionDelay = getVendorPropertyName('transitionDelay');
    support.transform       = getVendorPropertyName('transform');
    support.transformOrigin = getVendorPropertyName('transformOrigin');
    support.transform3d     = checkTransform3dSupport();

    // Check for the browser's transitions support.


    return{
        initialize: function (app) {
            app.core.dom.transitionevent = whichTransitionEvent();
            app.core.dom.transition      = support.transition;
            app.core.dom.transitionDelay = support.transitionDelay;
            app.core.dom.transform       = support.transform;
            app.core.dom.transformOrigin = support.transformOrigin;
            app.core.dom.transform3d     = support.transform3d;
        }
    };
});
define('features/alert/notIos',['backbone'], function(Backbone) {
    'use strict';

    var defaults = {
        type: 'alert',
        message: 'Uh-Oh',
        title: 'Alert',
        popupClass: null,
        buttonLabels: 'OK',
        buttonDown: null,
        view: null,
        confirmCallback: function() {

        },
        cancelCallback: function() {

        }
    };

    var Alert = function(options) {
        options = options || {};


        _.extend(this, defaults, options);

        this.alert();

    };


    Alert.prototype = {
        constructor: Alert,
        //baseTemplate : '<div class="popup"><div class="notification actionable"><div class="notification_inner"><div class="header"></div><div class="message"></div><div class="buttons"><table><tr></tr></table></div></div></div></div>',
        baseTemplate: '<div class="popup smartPopup"><div class="notification actionable"><div class="notification_inner"><div class="header"></div><div class="message"></div><div class="buttons"><table><tr></tr></table></div></div></div></div>',
        alert: function() {
            var self = this;
            this.$template = $(this.baseTemplate);
            this.translate();
            this.events();

            $('body').append(this.$template);

            if (this.id) {
                this.$template.addClass(this.id);
            }
            this.$template.show();
            if (this.$template.resizeElement) {
                this.$template.resizeElement();
            }

            $('.popup').addClass('on');
            window.sessionStorage.setItem("sfwPopupOpen", "true");
            setTimeout(function() {
                self.$template.find('.actionable').addClass('on');
            }, 20);

            DEBUG && console.log('ALERTS1:MODEL:add');

            var stamp = Date.now();
            this.key = 'alert' + stamp;

            var command = new CustomEvent("addBackButtonCommand", {
                detail: {
                    key: this.key, //a unique id for this back button command
                    callback: function() {
                        self.clear();
                    }

                }
            });

            document.dispatchEvent(command);

        },
        clear: function(isCancelling) {
            var self = this;
            this.$template.find('.actionable').removeClass('on');
            this.$template.on('webkitTransitionEnd', function() {
                self.$template.off('webkitTransitionEnd');
                if (this.view) {
                    this.$template.find(this.view.$el).detach();
                }
                self.$template.remove();
                window.sessionStorage.setItem("sfwPopupOpen", "false");

                if (isCancelling && self.cancelCallback) {
                    self.cancelCallback();
                }

            });

            DEBUG && console.log('ALERTS1:MODEL:clear');
            var command = new CustomEvent("removeBackButtonCommand", {
                detail: {
                    key: 'alert'
                }

            });

            document.dispatchEvent(command);
        },
        translate: function() {
            //insert correct translations of text
            this.$template.find('.header').html(this.title);
            this.$template.find('.notification').addClass(this.popupClass);
            if (this.view) {
                this.$template.find('.message').append(this.view.$el);
            } else {
                this.$template.find('.message').html(this.message);
            }


            if (this.buttonUp) {
                this.buttonUpName = this.buttonUp.split(',');
                if (this.buttonUpName.length > 1) {
                    this.$template.find('.message').after('<div class="optionButton opt1"><anchor class="confirm">' + this.buttonUpName[1] + '</div>');
                    this.$template.find('.message').after('<div class="optionButton opt2"><anchor class="confirm">' + $.trim(this.buttonUpName[0]) + '</div>');
                } else if (this.buttonUpName.length === 1) {
                    this.$template.find('.message').after('<div class="optionButton opt1"><anchor class="confirm">' + this.buttonUpName[0] + '</div>');
                }
            }

            this.buttonName = this.buttonLabels.split(',');
            if (this.buttonName.length > 1) {
                this.$template.find('.buttons tr').append('<td width="50%"><anchor class="cancel passiveBtn">' + this.buttonName[1] + '</anchor></td>');
                this.$template.find('.buttons tr').append('<td width="50%"><anchor class="confirm actionBtn">' + $.trim(this.buttonName[0]) + '</anchor></td>');
            } else if (this.buttonName.length === 1) {
                this.$template.find('.buttons tr').append('<td width="100%"><anchor class="confirm passiveBtn">' + this.buttonName[0] + '</anchor></td>');
            }



        },
        events: function() {
            var self = this;
            this.$template.find('.cancel').on('pointerup', function() {
                self.cancel();

            });

            this.$template.find('.confirm').on('pointerup', function() {
                self.confirm();
            });

            /*     this.$template.find('.notification_overlay').on('pointerup',function(){
             self.cancel();
             });  */
        },
        confirm: function() {
            if (this.confirmCallback) {
                this.confirmCallback();
            }

            this.clear();
        },
        cancel: function() {

            this.clear(true);
        }
    };

    window.smartAlert = Alert;

    return Alert;

});
define('extensions/ui/alert', ['backbone', 'feature!alert', 'plugins/jquery.transit'], function(Backbone, Alert) {

    'use strict';

    var aura;

    /**
     * throws a modal alert when there is a data error.
     * @param resp
     */
    var handleDataError = function(resp) {
        var self = this;

        var alert = new Alert({
            title: aura.sandbox.i18n.t('translation:errors.title'),
            message: aura.sandbox.i18n.t('translation:errors.message'),
            buttonLabels: aura.sandbox.i18n.t('translation:buttons.okay')
        });
    }

    return {
        initialize: function(app) {
            aura = app;
            app.core.dom.Alert = Alert;

            window.app.events.on('error', function(resp) {
                handleDataError(resp);
            });

        }
    };
});
define('features/customalert/notIos',['backbone'], function(Backbone) {
    'use strict';

    var defaults = {
        type: 'customalert',
        message: 'Uh-Oh',
        title: 'CustomAlert',
        popupClass: null,
        buttons: {},
        view: null
    };

    var CustomAlert = function(options) {
        options = options || {};

        _.extend(this, defaults, options);

        this.customalert();

    };


    CustomAlert.prototype = {
        constructor: CustomAlert,
        baseTemplate: '<div class="customPopup popup smartPopup"><div class="notification actionable" role="alertdialog"><div class="notification_inner"><div class="header"></div><div class="message"></div><div class="buttons"></div></div></div></div>',
        customalert: function() {
            var self = this;
            this.$template = $(this.baseTemplate);
            this.translate();
            this.events();

            $('body').append(this.$template);

            if (this.id) {
                this.$template.addClass(this.id);
            }

            this.$template.show();
            if (this.$template.resizeElement) {
                this.$template.resizeElement();
            }
            window.appEvents.emit('popup:open');

            $('.popup').addClass('on');
            window.sessionStorage.setItem("sfwPopupOpen", "true");

            setTimeout(function() {
                self.$template.find('.actionable').addClass('on');
            }, 20);

            window.appEvents.on('closePopups', function(){
                self.clear();
            });
        },
        clear: function(isCancelling) {
            var self = this;
            this.$template.find('.actionable').removeClass('on');
            this.$template.on('webkitTransitionEnd', function() {
                self.$template.off('webkitTransitionEnd');
                if (this.view) {
                    this.$template.find(this.view.$el).detach();
                }
                self.$template.remove();
                window.appEvents.emit('popup:close');
                if (isCancelling && self.cancelCallback) {
                    self.cancelCallback();
                }
                window.sessionStorage.setItem("sfwPopupOpen", "false");
            });
        },
        translate: function() {
            //insert correct translations of text
            this.$template.find('.header').html(this.title);
            this.$template.find('.notification').addClass(this.popupClass);
            if (this.view) {
                this.$template.find('.message').append(this.view.$el);
            } else {
                this.$template.find('.message').html(this.message);
            }
            var styles;
            for (var k in this.buttons) {
                if (this.buttons[k]['width'])
                    styles = this.buttons[k]['width'];
                else
                    styles = '100%';
                this.$template.find('.buttons').append('<anchor role="button" aria-label="' + this.buttons[k]['text'] + '"  style="width:' + styles + '" class="' + this.buttons[k]['extraClass'] + ' button-' + k + '">' + this.buttons[k]['text'] + '</anchor>');
            }
            this.$template.find('.buttons').append('<div style="clear:both;"></div>');

        },
        events: function() {
            var self = this;
            for (var k in this.buttons) {
                if (self.buttons[k]['events']) {
                    for (var h in self.buttons[k]['events']) {
                        for (var i in self.buttons[k]['events'][h]) {
                            Hammer(this.$template.find('.button-' + k)).on(i, self.buttons[k]['events'][h][i]);
                        }

                    }
                }

                this.$template.find('.button-' + k).on('pointerup', function() {
                    self.clear();
                });
            }

        }
    };


    window.smartCustomAlert = CustomAlert;

    return CustomAlert;

});
define('extensions/ui/customalert', ['backbone', 'feature!customalert', 'plugins/jquery.transit'], function(Backbone, CustomAlert) {

    'use strict';

    var aura;

    /**
     * throws a modal customalert when there is a data error.
     * @param resp
     */
    var handleDataError = function(resp) {
        var self = this;

        var customalert = new CustomAlert({
            title: aura.sandbox.i18n.t('translation:errors.title'),
            message: aura.sandbox.i18n.t('translation:errors.message'),
            buttonLabels: aura.sandbox.i18n.t('translation:buttons.okay')
        });
    }

    return {
        initialize: function(app) {
            aura = app;
            app.core.dom.CustomAlert = CustomAlert;

            window.app.events.on('error', function(resp) {
                handleDataError(resp);
            });

        }
    };
});
define('extensions/ui/custommodal', ['backbone', 'features/customalert/notIos', 'plugins/jquery.transit'], function(Backbone, CustomModal) {

    'use strict';


    return {
        initialize: function(app) {

            app.core.dom.CustomModal = CustomModal;

        }
    };
});
define('extensions/ui/modal', ['backbone', 'features/alert/notIos', 'plugins/jquery.transit'], function(Backbone, Modal) {

    'use strict';


    return {
        initialize: function(app) {

            app.core.dom.Modal = Modal;

        }
    };
});
Backbone.Validation = (function(_) {
    'use strict';

    // Default options
    // ---------------

    var defaultOptions = {
        forceUpdate: false,
        selector: 'name',
        labelFormatter: 'sentenceCase',
        valid: Function.prototype,
        invalid: Function.prototype
    };


    // Helper functions
    // ----------------

    // Formatting functions used for formatting error messages
    var formatFunctions = {
        // Uses the configured label formatter to format the attribute name
        // to make it more readable for the user
        formatLabel: function(attrName, model) {
            return defaultLabelFormatters[defaultOptions.labelFormatter](attrName, model);
        },

        // Replaces nummeric placeholders like {0} in a string with arguments
        // passed to the function
        format: function() {
            var args = Array.prototype.slice.call(arguments),
                text = args.shift();
            return text.replace(/\{(\d+)\}/g, function(match, number) {
                return typeof args[number] !== 'undefined' ? args[number] : match;
            });
        }
    };

    // Flattens an object
    // eg:
    //
    //     var o = {
    //       address: {
    //         street: 'Street',
    //         zip: 1234
    //       }
    //     };
    //
    // becomes:
    //
    //     var o = {
    //       'address.street': 'Street',
    //       'address.zip': 1234
    //     };
    var flatten = function(obj, into, prefix) {
        into = into || {};
        prefix = prefix || '';

        _.each(obj, function(val, key) {
            if (obj.hasOwnProperty(key)) {
                if (val && typeof val === 'object' && !(
                    val instanceof Array ||
                    val instanceof Date ||
                    val instanceof RegExp ||
                    val instanceof Backbone.Model ||
                    val instanceof Backbone.Collection)) {
                    flatten(val, into, prefix + key + '.');
                } else {
                    into[prefix + key] = val;
                }
            }
        });

        return into;
    };

    // Validation
    // ----------

    var Validation = (function() {

        // Returns an object with undefined properties for all
        // attributes on the model that has defined one or more
        // validation rules.
        var getValidatedAttrs = function(model) {
            return _.reduce(_.keys(_.result(model, 'validation') || {}), function(memo, key) {
                memo[key] = void 0;
                return memo;
            }, {});
        };

        // Looks on the model for validations for a specified
        // attribute. Returns an array of any validators defined,
        // or an empty array if none is defined.
        var getValidators = function(model, attr) {
            var attrValidationSet = model.validation ? _.result(model, 'validation')[attr] || {} : {};

            // If the validator is a function or a string, wrap it in a function validator
            if (_.isFunction(attrValidationSet) || _.isString(attrValidationSet)) {
                attrValidationSet = {
                    fn: attrValidationSet
                };
            }

            // Stick the validator object into an array
            if (!_.isArray(attrValidationSet)) {
                attrValidationSet = [attrValidationSet];
            }

            // Reduces the array of validators into a new array with objects
            // with a validation method to call, the value to validate against
            // and the specified error message, if any
            return _.reduce(attrValidationSet, function(memo, attrValidation) {
                _.each(_.without(_.keys(attrValidation), 'msg'), function(validator) {
                    memo.push({
                        fn: defaultValidators[validator],
                        val: attrValidation[validator],
                        msg: attrValidation.msg
                    });
                });
                return memo;
            }, []);
        };

        // Validates an attribute against all validators defined
        // for that attribute. If one or more errors are found,
        // the first error message is returned.
        // If the attribute is valid, an empty string is returned.
        var validateAttr = function(model, attr, value, computed) {
            // Reduces the array of validators to an error message by
            // applying all the validators and returning the first error
            // message, if any.
            return _.reduce(getValidators(model, attr), function(memo, validator) {
                // Pass the format functions plus the default
                // validators as the context to the validator
                var ctx = _.extend({}, formatFunctions, defaultValidators),
                    result = validator.fn.call(ctx, value, attr, validator.val, model, computed);

                if (result === false || memo === false) {
                    return false;
                }
                if (result && !memo) {
                    return _.result(validator, 'msg') || result;
                }
                return memo;
            }, '');
        };

        // Loops through the model's attributes and validates them all.
        // Returns and object containing names of invalid attributes
        // as well as error messages.
        var validateModel = function(model, attrs) {
            var error,
                invalidAttrs = {},
                isValid = true,
                computed = _.clone(attrs),
                flattened = flatten(attrs);

            _.each(flattened, function(val, attr) {
                error = validateAttr(model, attr, val, computed);
                if (error) {
                    invalidAttrs[attr] = error;
                    isValid = false;
                }
            });

            return {
                invalidAttrs: invalidAttrs,
                isValid: isValid
            };
        };

        // Contains the methods that are mixed in on the model when binding
        var mixin = function(view, options) {
            return {

                // Check whether or not a value, or a hash of values
                // passes validation without updating the model
                preValidate: function(attr, value) {
                    var self = this,
                        result = {},
                        error;

                    if (_.isObject(attr)) {
                        _.each(attr, function(value, key) {
                            error = self.preValidate(key, value);
                            if (error) {
                                result[key] = error;
                            }
                        });

                        return _.isEmpty(result) ? undefined : result;
                    } else {
                        return validateAttr(this, attr, value, _.extend({}, this.attributes));
                    }
                },

                // Check to see if an attribute, an array of attributes or the
                // entire model is valid. Passing true will force a validation
                // of the model.
                isValid: function(option) {
                    var flattened = flatten(this.attributes);

                    if (_.isString(option)) {
                        return !validateAttr(this, option, flattened[option], _.extend({}, this.attributes));
                    }
                    if (_.isArray(option)) {
                        return _.reduce(option, function(memo, attr) {
                            return memo && !validateAttr(this, attr, flattened[attr], _.extend({}, this.attributes));
                        }, true, this);
                    }
                    if (option === true) {
                        this.validate();
                    }
                    return this.validation ? this._isValid : true;
                },

                // This is called by Backbone when it needs to perform validation.
                // You can call it manually without any parameters to validate the
                // entire model.
                validate: function(attrs, setOptions) {
                    var model = this,
                        validateAll = !attrs,
                        opt = _.extend({}, options, setOptions),
                        validatedAttrs = getValidatedAttrs(model),
                        allAttrs = _.extend({}, validatedAttrs, model.attributes, attrs),
                        changedAttrs = flatten(attrs || allAttrs),

                        result = validateModel(model, allAttrs);

                    model._isValid = result.isValid;

                    // After validation is performed, loop through all validated attributes
                    // and call the valid callbacks so the view is updated.
                    _.each(validatedAttrs, function(val, attr) {
                        var invalid = result.invalidAttrs.hasOwnProperty(attr);
                        if (!invalid) {
                            opt.valid(view, attr, opt.selector);
                        }
                    });

                    // After validation is performed, loop through all validated and changed attributes
                    // and call the invalid callback so the view is updated.
                    _.each(validatedAttrs, function(val, attr) {
                        var invalid = result.invalidAttrs.hasOwnProperty(attr),
                            changed = changedAttrs.hasOwnProperty(attr);

                        if (invalid && (changed || validateAll)) {
                            opt.invalid(view, attr, result.invalidAttrs[attr], opt.selector);
                        }
                    });

                    // Trigger validated events.
                    // Need to defer this so the model is actually updated before
                    // the event is triggered.
                    _.defer(function() {
                        model.trigger('validated', model._isValid, model, result.invalidAttrs);
                        model.trigger('validated:' + (model._isValid ? 'valid' : 'invalid'), model, result.invalidAttrs);
                    });

                    // Return any error messages to Backbone, unless the forceUpdate flag is set.
                    // Then we do not return anything and fools Backbone to believe the validation was
                    // a success. That way Backbone will update the model regardless.
                    if (!opt.forceUpdate && _.intersection(_.keys(result.invalidAttrs), _.keys(changedAttrs)).length > 0) {
                        return result.invalidAttrs;
                    }
                }
            };
        };

        // Helper to mix in validation on a model
        var bindModel = function(view, model, options) {
            _.extend(model, mixin(view, options));
        };

        // Removes the methods added to a model
        var unbindModel = function(model) {
            delete model.validate;
            delete model.preValidate;
            delete model.isValid;
        };

        // Mix in validation on a model whenever a model is
        // added to a collection
        var collectionAdd = function(model) {
            bindModel(this.view, model, this.options);
        };

        // Remove validation from a model whenever a model is
        // removed from a collection
        var collectionRemove = function(model) {
            unbindModel(model);
        };

        // Returns the public methods on Backbone.Validation
        return {

            // Current version of the library
            version: '0.9.1',

            // Called to configure the default options
            configure: function(options) {
                _.extend(defaultOptions, options);
            },

            // Hooks up validation on a view with a model
            // or collection
            bind: function(view, options) {
                options = _.extend({}, defaultOptions, defaultCallbacks, options);

                var model = options.model || view.model,
                    collection = options.collection || view.collection;

                if (typeof model === 'undefined' && typeof collection === 'undefined') {
                    throw 'Before you execute the binding your view must have a model or a collection.\n' +
                        'See http://thedersen.com/projects/backbone-validation/#using-form-model-validation for more information.';
                }

                if (model) {
                    bindModel(view, model, options);
                } else if (collection) {
                    collection.each(function(model) {
                        bindModel(view, model, options);
                    });
                    collection.bind('add', collectionAdd, {
                        view: view,
                        options: options
                    });
                    collection.bind('remove', collectionRemove);
                }
            },

            // Removes validation from a view with a model
            // or collection
            unbind: function(view, options) {
                options = _.extend({}, options);
                var model = options.model || view.model,
                    collection = options.collection || view.collection;

                if (model) {
                    unbindModel(model);
                } else if (collection) {
                    collection.each(function(model) {
                        unbindModel(model);
                    });
                    collection.unbind('add', collectionAdd);
                    collection.unbind('remove', collectionRemove);
                }
            },

            // Used to extend the Backbone.Model.prototype
            // with validation
            mixin: mixin(null, defaultOptions)
        };
    }());


    // Callbacks
    // ---------

    var defaultCallbacks = Validation.callbacks = {

        // Gets called when a previously invalid field in the
        // view becomes valid. Removes any error message.
        // Should be overridden with custom functionality.
        valid: function(view, attr, selector) {
            view.$('[' + selector + '~="' + attr + '"]')
                .removeClass('invalid')
                .removeAttr('data-error');
        },

        // Gets called when a field in the view becomes invalid.
        // Adds a error message.
        // Should be overridden with custom functionality.
        invalid: function(view, attr, error, selector) {
            view.$('[' + selector + '~="' + attr + '"]')
                .addClass('invalid')
                .attr('data-error', error);
        }
    };


    // Patterns
    // --------

    var defaultPatterns = Validation.patterns = {
        // Matches any digit(s) (i.e. 0-9)
        digits: /^\d+$/,

        // Matches any number (e.g. 100.000)
        number: /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/,

        // Matches a valid email address (e.g. mail@example.com)
        email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,

        // Mathes any valid url (e.g. http://www.xample.com)
        url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    };


    // Error messages
    // --------------

    // Error message for the build in validators.
    // {x} gets swapped out with arguments form the validator.
    var defaultMessages = Validation.messages = {
        required: '{0} is required',
        acceptance: '{0} must be accepted',
        min: '{0} must be greater than or equal to {1}',
        max: '{0} must be less than or equal to {1}',
        range: '{0} must be between {1} and {2}',
        length: '{0} must be {1} characters',
        minLength: '{0} must be at least {1} characters',
        maxLength: '{0} must be at most {1} characters',
        rangeLength: '{0} must be between {1} and {2} characters',
        oneOf: '{0} must be one of: {1}',
        equalTo: '{0} must be the same as {1}',
        digits: '{0} must only contain digits',
        number: '{0} must be a number',
        email: '{0} must be a valid email',
        url: '{0} must be a valid url',
        inlinePattern: '{0} is invalid'
    };

    // Label formatters
    // ----------------

    // Label formatters are used to convert the attribute name
    // to a more human friendly label when using the built in
    // error messages.
    // Configure which one to use with a call to
    //
    //     Backbone.Validation.configure({
    //       labelFormatter: 'label'
    //     });
    var defaultLabelFormatters = Validation.labelFormatters = {

        // Returns the attribute name with applying any formatting
        none: function(attrName) {
            return attrName;
        },

        // Converts attributeName or attribute_name to Attribute name
        sentenceCase: function(attrName) {
            return attrName.replace(/(?:^\w|[A-Z]|\b\w)/g, function(match, index) {
                return index === 0 ? match.toUpperCase() : ' ' + match.toLowerCase();
            }).replace(/_/g, ' ');
        },

        // Looks for a label configured on the model and returns it
        //
        //      var Model = Backbone.Model.extend({
        //        validation: {
        //          someAttribute: {
        //            required: true
        //          }
        //        },
        //
        //        labels: {
        //          someAttribute: 'Custom label'
        //        }
        //      });
        label: function(attrName, model) {
            return (model.labels && model.labels[attrName]) || defaultLabelFormatters.sentenceCase(attrName, model);
        }
    };


    // Built in validators
    // -------------------

    var defaultValidators = Validation.validators = (function() {
        // Use native trim when defined
        var trim = String.prototype.trim ?
            function(text) {
                return text === null ? '' : String.prototype.trim.call(text);
            } :
            function(text) {
                var trimLeft = /^\s+/,
                    trimRight = /\s+$/;

                return text === null ? '' : text.toString().replace(trimLeft, '').replace(trimRight, '');
            };

        // Determines whether or not a value is a number
        var isNumber = function(value) {
            return _.isNumber(value) || (_.isString(value) && value.match(defaultPatterns.number));
        };

        // Determines whether or not a value is empty
        var hasValue = function(value) {
            return !(_.isNull(value) || _.isUndefined(value) || (_.isString(value) && trim(value) === '') || (_.isArray(value) && _.isEmpty(value)));
        };

        return {
            // Function validator
            // Lets you implement a custom function used for validation
            fn: function(value, attr, fn, model, computed) {
                if (_.isString(fn)) {
                    fn = model[fn];
                }
                return fn.call(model, value, attr, computed);
            },

            // Required validator
            // Validates if the attribute is required or not
            // This can be specified as either a boolean value or a function that returns a boolean value
            required: function(value, attr, required, model, computed) {
                var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;
                if (!isRequired && !hasValue(value)) {
                    return false; // overrides all other validators
                }
                if (isRequired && !hasValue(value)) {
                    return this.format(defaultMessages.required, this.formatLabel(attr, model));
                }
            },

            // Acceptance validator
            // Validates that something has to be accepted, e.g. terms of use
            // `true` or 'true' are valid
            acceptance: function(value, attr, accept, model) {
                if (value !== 'true' && (!_.isBoolean(value) || value === false)) {
                    return this.format(defaultMessages.acceptance, this.formatLabel(attr, model));
                }
            },

            // Min validator
            // Validates that the value has to be a number and equal to or greater than
            // the min value specified
            min: function(value, attr, minValue, model) {
                if (!isNumber(value) || value < minValue) {
                    return this.format(defaultMessages.min, this.formatLabel(attr, model), minValue);
                }
            },

            // Max validator
            // Validates that the value has to be a number and equal to or less than
            // the max value specified
            max: function(value, attr, maxValue, model) {
                if (!isNumber(value) || value > maxValue) {
                    return this.format(defaultMessages.max, this.formatLabel(attr, model), maxValue);
                }
            },

            // Range validator
            // Validates that the value has to be a number and equal to or between
            // the two numbers specified
            range: function(value, attr, range, model) {
                if (!isNumber(value) || value < range[0] || value > range[1]) {
                    return this.format(defaultMessages.range, this.formatLabel(attr, model), range[0], range[1]);
                }
            },

            // Length validator
            // Validates that the value has to be a string with length equal to
            // the length value specified
            length: function(value, attr, length, model) {
                if (!_.isString(value) || value.length !== length) {
                    return this.format(defaultMessages.length, this.formatLabel(attr, model), length);
                }
            },

            // Min length validator
            // Validates that the value has to be a string with length equal to or greater than
            // the min length value specified
            minLength: function(value, attr, minLength, model) {
                if (!_.isString(value) || value.length < minLength) {
                    return this.format(defaultMessages.minLength, this.formatLabel(attr, model), minLength);
                }
            },

            // Max length validator
            // Validates that the value has to be a string with length equal to or less than
            // the max length value specified
            maxLength: function(value, attr, maxLength, model) {
                if (!_.isString(value) || value.length > maxLength) {
                    return this.format(defaultMessages.maxLength, this.formatLabel(attr, model), maxLength);
                }
            },

            // Range length validator
            // Validates that the value has to be a string and equal to or between
            // the two numbers specified
            rangeLength: function(value, attr, range, model) {
                if (!_.isString(value) || value.length < range[0] || value.length > range[1]) {
                    return this.format(defaultMessages.rangeLength, this.formatLabel(attr, model), range[0], range[1]);
                }
            },

            // One of validator
            // Validates that the value has to be equal to one of the elements in
            // the specified array. Case sensitive matching
            oneOf: function(value, attr, values, model) {
                if (!_.include(values, value)) {
                    return this.format(defaultMessages.oneOf, this.formatLabel(attr, model), values.join(', '));
                }
            },

            // Equal to validator
            // Validates that the value has to be equal to the value of the attribute
            // with the name specified
            equalTo: function(value, attr, equalTo, model, computed) {
                if (value !== computed[equalTo]) {
                    return this.format(defaultMessages.equalTo, this.formatLabel(attr, model), this.formatLabel(equalTo, model));
                }
            },

            // Pattern validator
            // Validates that the value has to match the pattern specified.
            // Can be a regular expression or the name of one of the built in patterns
            pattern: function(value, attr, pattern, model) {
                if (!hasValue(value) || !value.toString().match(defaultPatterns[pattern] || pattern)) {
                    return this.format(defaultMessages[pattern] || defaultMessages.inlinePattern, this.formatLabel(attr, model), pattern);
                }
            }
        };
    }());

    // Set the correct context for all validators
    // when used from within a method validator
    _.each(defaultValidators, function(validator, key) {
        defaultValidators[key] = _.bind(defaultValidators[key], _.extend({}, formatFunctions, defaultValidators));
    });

    return Validation;
}(_));
define("backboneValidation", function(){});

define('extensions/ui/formvalidation', ['Cache', 'backboneValidation'], function() {

    'use strict';

    var aura;

    _.extend(Backbone.Model.prototype, Backbone.Validation.mixin);

    var FormValidation = function() {
        _.bindAll(this);
    };

    FormValidation.prototype = {
        /**
         * attach the form to the validation class
         * @param  {Backbone View} view    this view that contains the form
         * @param  {JSON} options configuration options for the validation
         * @param  {options} valid override existing valid handler with view specific handler
         * @param  {options} invalid override existing invalid handler with view specific handler
         * @param  {options} noPreValidation do not prevalidate fields on this form
         */
        bind: function(view, options, type) {

            var options = options || {};

            _.extend(this, options);

            this.view = view;
            this.model = view.model || options.model;
            this.type = type;

            Backbone.Validation.bind(view, {
                valid: this.valid,
                invalid: this.invalid
            });

            if (!this.noPreValidation) {
                if (!this.type || this.type === 1) {
                    this.validateByKeypress();
                } else if (this.type === 2) {
                    this.validateByButton();
                }
            }
        },
        /**
         * what to do when a form is valid on submit - generally use it to turn off all invalid messaging
         * @param  {Backbone View} view     same as this.view
         * @param  {string} attr     the attribute that is valid
         * @param  {[type]} selector the DOM element
         */
        valid: function(view, attr, selector) {
            //close invalid popup, send the changes through API

        },
        /**
         * what to do when a form is invalid on submit
         * @param  {Backbone View} view     same as this.view
         * @param  {string} attr     the attribute that is valid
         * @param  {string} error    the error message
         * @param  {[type]} selector the DOM element
         */
        invalid: function(view, attr, error, selector) {
            //open a popup with error message (move this to a global extension)
            var args = Array.prototype.slice.call(arguments);
            this.defaultInvalid.apply(this, args);
        },
        /**
         * what to do when a form field is invalid during pre-validation
         * @param  {Backbone View} view     same as this.view
         * @param  {string} attr     the attribute that is valid
         * @param  {string} error    the error message
         * @param  {[type]} selector the DOM element
         */
        preValidationInvalid: function(view, attr, error, selector) {
            //open a popup with error message (move this to a global extension)
            var args = Array.prototype.slice.call(arguments);
            this.defaultInvalid.apply(this, args);
        },
        defaultInvalid: function(view, attr, error, selector) {
            if (aura.sandbox.dom.CustomAlert) {
                var customalert = new aura.core.dom.Alert({
                    title: '',
                    message: error
                });
            } else {
                alert(error);
            }
        },
        /**
         * what to do when a form field is valid during pre-validation- generally use it to turn off all invalid messaging
         * @param  {Backbone View} view     same as this.view
         * @param  {string} attr     the attribute that is valid
         * @param  {[type]} selector the DOM element
         */
        preValidationValid: function(view, attr, error, selector) {
            // turn off error messaging

        },
        createFunc: function() {
            var self = this,
                func = function(e) {
                    var $el = $(this);
                    var key = $el.attr('name');
                    var error = self.model.preValidate(key, $el.val());
                    if (error !== '') {
                        self.preValidationInvalid(self, key, error, $el);
                    } else {
                        self.preValidationValid(self, key, error, $el);
                    }
                };
            return func;
        },
        /**
         * method to create event for pre-validation
         */
        validateByKeypress: function() {
            var self = this,
                validation = this.model.validation;

            if (typeof this.model.validation === 'function') {
                validation = this.model.validation();
            }

            _.each(validation, function(value, key) {
                var $elements = self.view.$('*[name="' + key + '"]');
                $elements.each(function() {
                    var $this = $(this);
                    if (!$this.hasClass('isValidating')) {
                        $this.on('keyup', _.debounce(self.createFunc(), 500));
                        $this.addClass('isValidating');
                    }
                });
            });
        },
        validateByButton: function() {
            var self = this,
                validation = this.model.validation;

            if (typeof this.model.validation === 'function') {
                validation = this.model.validation();
            }

            _.each(validation, function(value, key) {
                var $elements = self.view.$('*[name="' + key + '"]');
                $elements.each(function() {
                    var $this = self.view.$('.validation-btn');
                    if (!$this.hasClass('isValidating')) {
                        $this.on('click', _.debounce(self.createFunc(), 500));
                        $this.addClass('isValidating');
                    }
                });
            });
        },
        /**
         * facade for this.model.validate
         * @return {JSON} any errors that were found in validation
         */
        validate: function() {
            return this.model.validate();
        }
    };

    return {
        initialize: function(app) {
            aura = app;
            app.sandbox.FormValidation = FormValidation;
        }
    };
});
define('features/loadExtensions/wemo',[
    'extensions/i18next',
    'extensions/backbone',
    'extensions/handlebars',
    'extensions/storage',
    'extensions/utils/css',
    'extensions/ui/accordion2',
    'extensions/ui/peekaboo',
    'extensions/ui/pickers',
    'extensions/dataInterface',
    'extensions/globalsettings',
    'extensions/uiInterface',
    'extensions/rulesEngine',
    'extensions/serializationTracking',
    'extensions/views/backbone.tileBase',
    'extensions/views/backbone.tileanddrawer',
    'extensions/models/backbone.wemodevicemodel',
    'extensions/views/backbone.overlay',
    'extensions/views/backbone.processedview',
    'extensions/views/backbone.drawerMaster',
    'extensions/views/backbone.drawerBase',
    'extensions/utils/converters',
    'extensions/utils/transitionend',
    'extensions/ui/alert',
    'extensions/ui/customalert',
    'extensions/ui/custommodal',
    'extensions/ui/modal',
    'extensions/ui/formvalidation'

], function() {

    'use strict';

    return [
        'extensions/i18next',
        'extensions/backbone',
        'extensions/handlebars',
        'extensions/storage',
        'extensions/utils/css',
        'extensions/ui/accordion2',
        'extensions/ui/peekaboo',
        'extensions/ui/pickers',
        'extensions/dataInterface',
        'extensions/globalsettings',
        'extensions/uiInterface',
        'extensions/rulesEngine',
        'extensions/serializationTracking',
        'extensions/views/backbone.tileBase',
        'extensions/views/backbone.tileanddrawer',
        'extensions/models/backbone.wemodevicemodel',
        'extensions/views/backbone.overlay',
        'extensions/views/backbone.processedview',
        'extensions/views/backbone.drawerMaster',
        'extensions/views/backbone.drawerBase',
        'extensions/utils/converters',
        'extensions/utils/transitionend',
        'extensions/ui/alert',
        'extensions/ui/customalert',
        'extensions/ui/custommodal',
        'extensions/ui/modal',
        'extensions/ui/formvalidation'
    ];

});
/**
 * use this file to load demo devices into android. The fields here match the fields returned by the UPNP response
 */
(function (definition) {

    /* jshint strict: false */


    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

        // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

        // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define('features/demoDevices/noop',definition);
    } else {
        window.demoDevices = definition();
    }

})(function () {
    return null;
});
(function() {
    var DB_STATE_INIT, DB_STATE_OPEN, READ_ONLY_REGEX, SQLiteFactory, SQLitePlugin, SQLitePluginTransaction, argsArray, dblocations, newSQLError, nextTick, root, txLocks;

    root = this;

    READ_ONLY_REGEX = /^\s*(?:drop|delete|insert|update|create)\s/i;

    DB_STATE_INIT = "INIT";

    DB_STATE_OPEN = "OPEN";

    txLocks = {};

    newSQLError = function (error, code) {
        var sqlError;
        sqlError = error;
        if (!code) {
            code = 0;
        }
        if (!sqlError) {
            sqlError = new Error("a plugin had an error but provided no response");
            sqlError.code = code;
        }
        if (typeof sqlError === "string") {
            sqlError = new Error(error);
            sqlError.code = code;
        }
        if (!sqlError.code && sqlError.message) {
            sqlError.code = code;
        }
        if (!sqlError.code && !sqlError.message) {
            sqlError = new Error("an unknown error was returned: " + JSON.stringify(sqlError));
            sqlError.code = code;
        }
        return sqlError;
    };

    nextTick = window.setImmediate || function (fun) {
        window.setTimeout(fun, 0);
    };


    /*
     Utility that avoids leaking the arguments object. See
     https://www.npmjs.org/package/argsarray
     */

    argsArray = function (fun) {
        return function () {
            var args, i, len;
            len = arguments.length;
            if (len) {
                args = [];
                i = -1;
                while (++i < len) {
                    args[i] = arguments[i];
                }
                return fun.call(this, args);
            } else {
                return fun.call(this, []);
            }
        };
    };

    SQLitePlugin = function (openargs, openSuccess, openError) {
        var dbname;
        if (!(openargs && openargs['name'])) {
            throw newSQLError("Cannot create a SQLitePlugin db instance without a db name");
        }
        dbname = openargs.name;
        this.openargs = openargs;
        this.dbname = dbname;
        this.openSuccess = openSuccess;
        this.openError = openError;
        this.openSuccess || (this.openSuccess = function () {
            console.log("DB opened: " + dbname);
        });
        this.openError || (this.openError = function (e) {
            console.log(e.message);
        });
        this.open(this.openSuccess, this.openError);
    };

    SQLitePlugin.prototype.databaseFeatures = {
        isSQLitePluginDatabase: true
    };

    SQLitePlugin.prototype.openDBs = {};

    SQLitePlugin.prototype.addTransaction = function (t) {
        if (!txLocks[this.dbname]) {
            txLocks[this.dbname] = {
                queue: [],
                inProgress: false
            };
        }
        txLocks[this.dbname].queue.push(t);
        if (this.dbname in this.openDBs && this.openDBs[this.dbname] !== DB_STATE_INIT) {
            this.startNextTransaction();
        } else {
            if (this.dbname in this.openDBs) {
                console.log('new transaction is waiting for open operation');
            } else {
                console.log('database is closed, new transaction is [stuck] waiting until db is opened again!');
            }
        }
    };

    SQLitePlugin.prototype.transaction = function (fn, error, success) {
        if (!this.openDBs[this.dbname]) {
            error(newSQLError('database not open'));
            return;
        }
        this.addTransaction(new SQLitePluginTransaction(this, fn, error, success, true, false));
    };

    SQLitePlugin.prototype.readTransaction = function (fn, error, success) {
        if (!this.openDBs[this.dbname]) {
            error(newSQLError('database not open'));
            return;
        }
        this.addTransaction(new SQLitePluginTransaction(this, fn, error, success, true, true));
    };

    SQLitePlugin.prototype.startNextTransaction = function () {
        var self;
        self = this;
        nextTick((function (_this) {
            return function () {
                var txLock;
                if (!(_this.dbname in _this.openDBs) || _this.openDBs[_this.dbname] !== DB_STATE_OPEN) {
                    console.log('cannot start next transaction: database not open');
                    return;
                }
                txLock = txLocks[self.dbname];
                if (!txLock) {
                    console.log('cannot start next transaction: database connection is lost');
                    return;
                } else if (txLock.queue.length > 0 && !txLock.inProgress) {
                    txLock.inProgress = true;
                    txLock.queue.shift().start();
                }
            };
        })(this));
    };

    SQLitePlugin.prototype.abortAllPendingTransactions = function () {
        var tx, txLock, _i, _len, _ref;
        txLock = txLocks[this.dbname];
        if (!!txLock && txLock.queue.length > 0) {
            _ref = txLock.queue;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                tx = _ref[_i];
                tx.abortFromQ(newSQLError('Invalid database handle'));
            }
            txLock.queue = [];
            txLock.inProgress = false;
        }
    };

    SQLitePlugin.prototype.open = function (success, error) {
        var openerrorcb, opensuccesscb;
        if (this.dbname in this.openDBs) {
            console.log('database already open: ' + this.dbname);
            nextTick((function (_this) {
                return function () {
                    success(_this);
                };
            })(this));
        } else {
            console.log('OPEN database: ' + this.dbname);
            opensuccesscb = (function (_this) {
                return function () {
                    var txLock;
                    if (!_this.openDBs[_this.dbname]) {
                        console.log('database was closed during open operation');
                    }
                    if (_this.dbname in _this.openDBs) {
                        _this.openDBs[_this.dbname] = DB_STATE_OPEN;
                    }
                    if (!!success) {
                        success(_this);
                    }
                    txLock = txLocks[_this.dbname];
                    if (!!txLock && txLock.queue.length > 0 && !txLock.inProgress) {
                        _this.startNextTransaction();
                    }
                };
            })(this);
            openerrorcb = (function (_this) {
                return function () {
                    console.log('OPEN database: ' + _this.dbname + ' failed, aborting any pending transactions');
                    if (!!error) {
                        error(newSQLError('Could not open database'));
                    }
                    delete _this.openDBs[_this.dbname];
                    _this.abortAllPendingTransactions();
                };
            })(this);
            this.openDBs[this.dbname] = DB_STATE_INIT;
            cordova.exec(opensuccesscb, openerrorcb, "SQLitePlugin", "open", [this.openargs]);
        }
    };

    SQLitePlugin.prototype.close = function (success, error) {
        if (this.dbname in this.openDBs) {
            if (txLocks[this.dbname] && txLocks[this.dbname].inProgress) {
                console.log('cannot close: transaction is in progress');
                error(newSQLError('database cannot be closed while a transaction is in progress'));
                return;
            }
            console.log('CLOSE database: ' + this.dbname);
            delete this.openDBs[this.dbname];
            if (txLocks[this.dbname]) {
                console.log('closing db with transaction queue length: ' + txLocks[this.dbname].queue.length);
            } else {
                console.log('closing db with no transaction lock state');
            }
            cordova.exec(success, error, "SQLitePlugin", "close", [
                {
                    path: this.dbname
                }
            ]);
        } else {
            console.log('cannot close: database is not open');
            if (error) {
                nextTick(function () {
                    return error();
                });
            }
        }
    };

    SQLitePlugin.prototype.executeSql = function (statement, params, success, error) {
        var myerror, myfn, mysuccess;
        mysuccess = function (t, r) {
            if (!!success) {
                return success(r);
            }
        };
        myerror = function (t, e) {
            if (!!error) {
                return error(e);
            }
        };
        myfn = function (tx) {
            tx.addStatement(statement, params, mysuccess, myerror);
        };
        this.addTransaction(new SQLitePluginTransaction(this, myfn, null, null, false, false));
    };

    SQLitePluginTransaction = function (db, fn, error, success, txlock, readOnly) {
        if (typeof fn !== "function") {

            /*
             This is consistent with the implementation in Chrome -- it
             throws if you pass anything other than a function. This also
             prevents us from stalling our txQueue if somebody passes a
             false value for fn.
             */
            throw newSQLError("transaction expected a function");
        }
        this.db = db;
        this.fn = fn;
        this.error = error;
        this.success = success;
        this.txlock = txlock;
        this.readOnly = readOnly;
        this.executes = [];
        if (txlock) {
            this.addStatement("BEGIN", [], null, function (tx, err) {
                throw newSQLError("unable to begin transaction: " + err.message, err.code);
            });
        }
    };

    SQLitePluginTransaction.prototype.start = function () {
        var err;
        try {
            this.fn(this);
            this.run();
        } catch (_error) {
            err = _error;
            txLocks[this.db.dbname].inProgress = false;
            this.db.startNextTransaction();
            if (this.error) {
                this.error(newSQLError(err));
            }
        }
    };

    SQLitePluginTransaction.prototype.executeSql = function (sql, values, success, error) {
        if (this.finalized) {
            throw {
                message: 'InvalidStateError: DOM Exception 11: This transaction is already finalized. Transactions are committed after its success or failure handlers are called. If you are using a Promise to handle callbacks, be aware that implementations following the A+ standard adhere to run-to-completion semantics and so Promise resolution occurs on a subsequent tick and therefore after the transaction commits.',
                code: 11
            };
            return;
        }
        if (this.readOnly && READ_ONLY_REGEX.test(sql)) {
            this.handleStatementFailure(error, {
                message: 'invalid sql for a read-only transaction'
            });
            return;
        }
        this.addStatement(sql, values, success, error);
    };

    SQLitePluginTransaction.prototype.addStatement = function (sql, values, success, error) {
        var params, qid, t, v, _i, _len;
        qid = this.executes.length;
        params = [];
        if (!!values && values.constructor === Array) {
            for (_i = 0, _len = values.length; _i < _len; _i++) {
                v = values[_i];
                t = typeof v;
                params.push((v === null || v === void 0 || t === 'number' || t === 'string' ? v : v instanceof Blob ? v.valueOf() : v.toString()));
            }
        }
        this.executes.push({
            success: success,
            error: error,
            qid: qid,
            sql: sql,
            params: params
        });
    };

    SQLitePluginTransaction.prototype.handleStatementSuccess = function (handler, response) {
        var payload, rows;
        if (!handler) {
            return;
        }
        rows = response.rows || [];
        payload = {
            rows: {
                item: function (i) {
                    return rows[i];
                },
                length: rows.length
            },
            rowsAffected: response.rowsAffected || 0,
            insertId: response.insertId || void 0
        };
        handler(this, payload);
    };

    SQLitePluginTransaction.prototype.handleStatementFailure = function (handler, response) {
        if (!handler) {
            throw newSQLError("a statement with no error handler failed: " + response.message, response.code);
        }
        if (handler(this, response) !== false) {
            throw newSQLError("a statement error callback did not return false: " + response.message, response.code);
        }
    };

    SQLitePluginTransaction.prototype.run = function () {
        var batchExecutes, handlerFor, i, mycb, mycbmap, qid, request, tropts, tx, txFailure, waiting;
        txFailure = null;
        tropts = [];
        batchExecutes = this.executes;
        waiting = batchExecutes.length;
        this.executes = [];
        tx = this;
        handlerFor = function (index, didSucceed) {
            return function (response) {
                var err;
                try {
                    if (didSucceed) {
                        tx.handleStatementSuccess(batchExecutes[index].success, response);
                    } else {
                        tx.handleStatementFailure(batchExecutes[index].error, newSQLError(response));
                    }
                } catch (_error) {
                    err = _error;
                    if (!txFailure) {
                        txFailure = newSQLError(err);
                    }
                }
                if (--waiting === 0) {
                    if (txFailure) {
                        tx.abort(txFailure);
                    } else if (tx.executes.length > 0) {
                        tx.run();
                    } else {
                        tx.finish();
                    }
                }
            };
        };
        i = 0;
        mycbmap = {};
        while (i < batchExecutes.length) {
            request = batchExecutes[i];
            qid = request.qid;
            mycbmap[qid] = {
                success: handlerFor(i, true),
                error: handlerFor(i, false)
            };
            tropts.push({
                qid: qid,
                sql: request.sql,
                params: request.params
            });
            i++;
        }
        mycb = function (result) {
            var q, r, res, type, _i, _len;
            for (_i = 0, _len = result.length; _i < _len; _i++) {
                r = result[_i];
                type = r.type;
                qid = r.qid;
                res = r.result;
                q = mycbmap[qid];
                if (q) {
                    if (q[type]) {
                        q[type](res);
                    }
                }
            }
        };
        cordova.exec(mycb, null, "SQLitePlugin", "backgroundExecuteSqlBatch", [
            {
                dbargs: {
                    dbname: this.db.dbname
                },
                executes: tropts
            }
        ]);
    };

    SQLitePluginTransaction.prototype.abort = function (txFailure) {
        var failed, succeeded, tx;
        if (this.finalized) {
            return;
        }
        tx = this;
        succeeded = function (tx) {
            txLocks[tx.db.dbname].inProgress = false;
            tx.db.startNextTransaction();
            if (tx.error) {
                tx.error(txFailure);
            }
        };
        failed = function (tx, err) {
            txLocks[tx.db.dbname].inProgress = false;
            tx.db.startNextTransaction();
            if (tx.error) {
                tx.error(newSQLError("error while trying to roll back: " + err.message, err.code));
            }
        };
        this.finalized = true;
        if (this.txlock) {
            this.addStatement("ROLLBACK", [], succeeded, failed);
            this.run();
        } else {
            succeeded(tx);
        }
    };

    SQLitePluginTransaction.prototype.finish = function () {
        var failed, succeeded, tx;
        if (this.finalized) {
            return;
        }
        tx = this;
        succeeded = function (tx) {
            txLocks[tx.db.dbname].inProgress = false;
            tx.db.startNextTransaction();
            if (tx.success) {
                tx.success();
            }
        };
        failed = function (tx, err) {
            txLocks[tx.db.dbname].inProgress = false;
            tx.db.startNextTransaction();
            if (tx.error) {
                tx.error(newSQLError("error while trying to commit: " + err.message, err.code));
            }
        };
        this.finalized = true;
        if (this.txlock) {
            this.addStatement("COMMIT", [], succeeded, failed);
            this.run();
        } else {
            succeeded(tx);
        }
    };

    SQLitePluginTransaction.prototype.abortFromQ = function (sqlerror) {
        if (this.error) {
            this.error(sqlerror);
        }
    };

    dblocations = ["docs", "libs", "nosync"];

    SQLiteFactory = {

        /*
         NOTE: this function should NOT be translated from Javascript
         back to CoffeeScript by js2coffee.
         If this function is edited in Javascript then someone will
         have to translate it back to CoffeeScript by hand.
         */
        opendb: argsArray(function (args) {
            var dblocation, errorcb, first, okcb, openargs;
            if (args.length < 1) {
                return null;
            }
            first = args[0];
            openargs = null;
            okcb = null;
            errorcb = null;
            if (first.constructor === String) {
                openargs = {
                    name: first
                };
                if (args.length >= 5) {
                    okcb = args[4];
                    if (args.length > 5) {
                        errorcb = args[5];
                    }
                }
            } else {
                openargs = first;
                if (args.length >= 2) {
                    okcb = args[1];
                    if (args.length > 2) {
                        errorcb = args[2];
                    }
                }
            }
            dblocation = !!openargs.location ? dblocations[openargs.location] : null;
            openargs.dblocation = dblocation || dblocations[0];
            if (!!openargs.createFromLocation && openargs.createFromLocation === 1) {
                openargs.createFromResource = "1";
            }
            //Android N doesn't support sqlite4java anymore, forcing the plugin to always use android.database.sqlite
//        if (!!openargs.androidDatabaseImplementation && openargs.androidDatabaseImplementation === 2) {
            openargs.androidOldDatabaseImplementation = 1;
            // }
            if (!!openargs.androidLockWorkaround && openargs.androidLockWorkaround === 1) {
                openargs.androidBugWorkaround = 1;
            }
            return new SQLitePlugin(openargs, okcb, errorcb);
        }),
        deleteDb: function (first, success, error) {
            var args, dblocation;
            args = {};
            if (first.constructor === String) {
                args.path = first;
                args.dblocation = dblocations[0];
            } else {
                if (!(first && first['name'])) {
                    throw new Error("Please specify db name");
                }
                args.path = first.name;
                dblocation = !!first.location ? dblocations[first.location] : null;
                args.dblocation = dblocation || dblocations[0];
            }
            delete SQLitePlugin.prototype.openDBs[args.path];
            return cordova.exec(success, error, "SQLitePlugin", "delete", [args]);
        }
    };

    /*
     FUTURE TBD GONE: Required for db.executePragmStatement() callback ONLY:
     */

    root.sqlitePlugin = {
        sqliteFeatures: {
            isSQLitePlugin: true
        },
        openDatabase: SQLiteFactory.opendb,
        deleteDatabase: SQLiteFactory.deleteDb
    };

}).call(this);
define("features/sqlitePlugin/SQLitePlugin", function(){});

(function(exports) {
    var MOUSE_ID = 1;

    function Pointer(identifier, type, event) {
        this.screenX = event.screenX || 0;
        this.screenY = event.screenY || 0;
        this.pageX = event.pageX || 0;
        this.pageY = event.pageY || 0;
        this.clientX = event.clientX || 0;
        this.clientY = event.clientY || 0;
        this.tiltX = event.tiltX || 0;
        this.tiltY = event.tiltY || 0;
        this.pressure = event.pressure || 0.0;
        this.hwTimestamp = event.hwTimestamp || 0;
        this.pointerType = type;
        this.identifier = identifier;
    }

    var PointerTypes = {
        TOUCH: 'touch',
        MOUSE: 'mouse',
        PEN: 'pen'
    };

    function setMouse(mouseEvent) {
        mouseEvent.target.mouseEvent = mouseEvent;
    }

    function unsetMouse(mouseEvent) {
        mouseEvent.target.mouseEvent = null;
    }

    function setTouch(touchEvent) {
        touchEvent.target.touchList = touchEvent.targetTouches;
    }

    /**
     * Returns an array of all pointers currently on the screen.
     */
    function getPointerList() {
        // Note: "this" is the element.
        var pointers = [];
        var pointer;
        if (this.touchList) {
            for (var i = 0; i < this.touchList.length; i++) {
                var touch = this.touchList[i];
                // Add 2 to avoid clashing with the mouse identifier.
                pointer = new Pointer(touch.identifier + 2, PointerTypes.TOUCH, touch);
                pointers.push(pointer);
            }
        } else if (this.msPointerList) {
            for (var identifier in this.msPointerList) {
                if (!this.msPointerList.hasOwnProperty(identifier)) continue;
                pointer = this.msPointerList[identifier];
                pointer = new Pointer(identifier, pointer.textPointerType, pointer);
                pointers.push(pointer);
            }
        }
        if (this.mouseEvent) {
            pointers.push(new Pointer(MOUSE_ID, PointerTypes.MOUSE, this.mouseEvent));
        }
        return pointers;
    }

    function createCustomEvent(eventName, target, payload) {
        var event = document.createEvent('Event');
        event.initEvent(eventName, true, true);
        for (var k in payload) {
            event[k] = payload[k];
        }
        if (((eventName === 'pointerup' || eventName === 'pointerdown') && !window.isScrolling) || eventName === 'pointerMove') {
            target.dispatchEvent(event);
        }

    }

    /*************** Mouse event handlers *****************/

    function mouseDownHandler(event) {
        event.preventDefault();
        setMouse(event);
        var payload = {
            pointerType: 'mouse',
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointerdown', event.target, payload);
    }

    function mouseMoveHandler(event) {
        event.preventDefault();
        if (event.target.mouseEvent) {
            setMouse(event);
        }
        var payload = {
            pointerType: 'mouse',
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointermove', event.target, payload);
    }

    function mouseUpHandler(event) {
        event.preventDefault();
        unsetMouse(event);
        var payload = {
            pointerType: 'mouse',
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointerup', event.target, payload);
    }

    /*************** Touch event handlers *****************/

    function touchStartHandler(event) {
        console.log('touchstart');
        event.preventDefault();
        setTouch(event);
        var payload = {
            pointerType: 'touch',
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointerdown', event.target, payload);
    }

    function touchMoveHandler(event) {
        event.preventDefault();
        setTouch(event);
        var payload = {
            pointerType: 'touch',
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointermove', event.target, payload);
    }

    function touchEndHandler(event) {
        event.preventDefault();
        setTouch(event);
        var payload = {
            pointerType: 'touch',
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointerup', event.target, payload);
    }

    function mouseOutHandler(event) {
        if (event.target.mouseEvent) {
            console.log(event);
            event.preventDefault();
            unsetMouse(event);
            var payload = {
                pointerType: 'mouse',
                getPointerList: getPointerList.bind(this),
                originalEvent: event
            };
            createCustomEvent('pointerup', event.target, payload);
        }
    }

    /*************** MSIE Pointer event handlers *****************/

    function pointerDownHandler(event) {
        if (event.pointerType == 2) {
            event.textPointerType = PointerTypes.TOUCH;
        } else if (event.pointerType == 3) {
            event.textPointerType = PointerTypes.PEN;
        } else if (event.pointerType == 4) {
            event.textPointerType = PointerTypes.MOUSE;
        }
        if (event.textPointerType == PointerTypes.MOUSE) {
            event.target.msMouseDown = true;
        }
        if (!event.target.msPointerList) event.target.msPointerList = {};
        event.target.msPointerList[event.pointerId] = event;
        var payload = {
            pointerType: event.textPointerType,
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };

        createCustomEvent('pointerdown', event.target, payload);
    }

    function pointerMoveHandler(event) {
        if (event.pointerType == 2) {
            event.textPointerType = PointerTypes.TOUCH;
        } else if (event.pointerType == 3) {
            event.textPointerType = PointerTypes.PEN;
        } else if (event.pointerType == 4) {
            event.textPointerType = PointerTypes.MOUSE;
        }
        if (event.textPointerType == PointerTypes.MOUSE && !event.target.msMouseDown) {
            return;
        }
        if (!event.target.msPointerList) event.target.msPointerList = {};
        event.target.msPointerList[event.pointerId] = event;
        var payload = {
            pointerType: event.textPointerType,
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointermove', event.target, payload);
    }

    function pointerUpHandler(event) {
        if (event.target.msPointerList) {
            delete event.target.msPointerList[event.pointerId];
        }
        if (event.pointerType == 2) {
            event.textPointerType = PointerTypes.TOUCH;
        } else if (event.pointerType == 3) {
            event.textPointerType = PointerTypes.PEN;
        } else if (event.pointerType == 4) {
            event.textPointerType = PointerTypes.MOUSE;
        }
        if (event.textPointerType == PointerTypes.MOUSE) {
            event.target.msMouseDown = false;
        }
        var payload = {
            pointerType: event.textPointerType,
            getPointerList: getPointerList.bind(this),
            originalEvent: event
        };
        createCustomEvent('pointerup', event.target, payload);
    }

    /**
     * Causes the passed in element to broadcast pointer events instead
     * of mouse/touch/etc events.
     */
    function emitPointers(el) {
        if (!el.isPointerEmitter) {
            // Latch on to all relevant events for this element.
            if (isPointer()) {
                el.addEventListener('pointerdown', pointerDownHandler);
                el.addEventListener('pointermove', pointerMoveHandler);
                el.addEventListener('pointerup', pointerUpHandler);
            } else if (isMSPointer()) {
                el.addEventListener('MSPointerDown', pointerDownHandler);
                el.addEventListener('MSPointerMove', pointerMoveHandler);
                el.addEventListener('MSPointerUp', pointerUpHandler);
            } else {
                if (isTouch()) {
                    el.addEventListener('touchstart', touchStartHandler);
                    el.addEventListener('touchmove', touchMoveHandler);
                    el.addEventListener('touchend', touchEndHandler);
                }
                /** michael forbes - belkin - add else for android.. why no else to begin with? **/
                else {
                    el.addEventListener('mousedown', mouseDownHandler);
                    el.addEventListener('mousemove', mouseMoveHandler);
                    el.addEventListener('mouseup', mouseUpHandler);
                    // Necessary for the edge case that the mouse is down and you drag out of
                    // the area.
                    //    michael forbes - what if we WANT this edge case?
                    //  el.addEventListener('mouseout', mouseOutHandler);
                }
            }

            el.isPointerEmitter = true;
        }
    }

    /**
     * @return {Boolean} Returns true iff this user agent supports touch events.
     */
    function isTouch() {
        if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
            return true;
        } else {
            return false;
        }

    }

    /**
     * @return {Boolean} Returns true iff this user agent supports MSIE pointer
     * events.
     */
    function isMSPointer() {
        return window.navigator.msPointerEnabled;
    }

    /**
     * @return {Boolean} Returns true iff this user agent supports pointer
     * events.
     */
    function isPointer() {
        return window.navigator.pointerEnabled;
    }

    /**
     * Option 1: Require emitPointers call on all pointer event emitters.
     */
    //exports.pointer = {
    //  emitPointers: emitPointers,
    //};

    /**
     * Option 2: Replace addEventListener with a custom version.
     */
    function augmentAddEventListener(baseElementClass, customEventListener) {
        var oldAddEventListener = baseElementClass.prototype.addEventListener;
        baseElementClass.prototype.addEventListener = function(type, listener, useCapture) {
            customEventListener.call(this, type, listener, useCapture);
            oldAddEventListener.call(this, type, listener, useCapture);
        };
    }

    function synthesizePointerEvents(type, listener, useCapture) {
        if (type.indexOf('pointer') === 0) {
            emitPointers(this);
        }
    }

    // Note: Firefox doesn't work like other browsers... overriding HTMLElement
    // doesn't actually affect anything. Special case for Firefox:
    if (navigator.userAgent.match(/Firefox/)) {
        // TODO: fix this for the general case.
        augmentAddEventListener(HTMLDivElement, synthesizePointerEvents);
        augmentAddEventListener(HTMLCanvasElement, synthesizePointerEvents);
    } else {
        augmentAddEventListener(HTMLElement, synthesizePointerEvents);
    }

    exports._createCustomEvent = createCustomEvent;
    exports._augmentAddEventListener = augmentAddEventListener;
    exports.PointerTypes = PointerTypes;
})(window);
(function(exports) {

    function synthesizeGestureEvents(type, listener, useCapture) {
        if (type.indexOf('gesture') === 0) {
            var handler = Gesture._gestureHandlers[type];
            if (handler) {
                handler(this);
            } else {
                console.error('Warning: no handler found for {{evt}}.'
                    .replace('{{evt}}', type));
            }
        }
    }

    // Note: Firefox doesn't work like other browsers... overriding HTMLElement
    // doesn't actually affect anything. Special case for Firefox:
    if (navigator.userAgent.match(/Firefox/)) {
        // TODO: fix this for the general case.
        window._augmentAddEventListener(HTMLDivElement, synthesizeGestureEvents);
        window._augmentAddEventListener(HTMLCanvasElement, synthesizeGestureEvents);
    } else {
        window._augmentAddEventListener(HTMLElement, synthesizeGestureEvents);
    }

    exports.Gesture = exports.Gesture || {};
    exports.Gesture._gestureHandlers = exports.Gesture._gestureHandlers || {};

})(window);
/**
 * Gesture recognizer for the `doubletap` gesture.
 *
 * Taps happen when an element is pressed and then released.
 */
(function(exports) {
    var DOUBLETAP_TIME = 300;
    var WIGGLE_THRESHOLD = 10;

    /**
     * A simple object for storing the position of a pointer.
     */
    function PointerPosition(pointer) {
        this.x = pointer.clientX;
        this.y = pointer.clientY;
    }

    /**
     * calculate the squared distance of the given pointer from this
     * PointerPosition's pointer
     */
    PointerPosition.prototype.calculateSquaredDistance = function(pointer) {
        var dx = this.x - pointer.clientX;
        var dy = this.y - pointer.clientY;
        return dx * dx + dy * dy;
    };

    function pointerDown(e) {
        var pointers = e.getPointerList();
        if (pointers.length != 1) return;
        var now = new Date();
        if (now - this.lastDownTime < DOUBLETAP_TIME && this.lastPosition && this.lastPosition.calculateSquaredDistance(pointers[0]) < WIGGLE_THRESHOLD * WIGGLE_THRESHOLD) {
            this.lastDownTime = 0;
            this.lastPosition = null;
            var payload = {};
            window._createCustomEvent('gesturedoubletap', e.target, payload);
        }
        this.lastPosition = new PointerPosition(pointers[0]);
        this.lastDownTime = now;
    }

    /**
     * Make the specified element create gesturetap events.
     */
    function emitDoubleTaps(el) {
        el.addEventListener('pointerdown', pointerDown);
    }

    exports.Gesture._gestureHandlers.gesturedoubletap = emitDoubleTaps;

})(window);
/**
 * Gesture recognizer for the `longpress` gesture.
 *
 * Longpress happens when pointer is pressed and doesn't get released
 * for a while (without movement).
 */
(function(exports) {
    var LONGPRESS_TIME = 600;
    var WIGGLE_THRESHOLD = 5;

    /**
     * A simple object for storing the position of a pointer.
     */
    function PointerPosition(pointer) {
        this.x = pointer.clientX;
        this.y = pointer.clientY;
    }

    /**
     * calculate the squared distance of the given pointer from this
     * PointerPosition's pointer
     */
    PointerPosition.prototype.calculateSquaredDistance = function(pointer) {
        var dx = this.x - pointer.clientX;
        var dy = this.y - pointer.clientY;
        return dx * dx + dy * dy;
    };


    function pointerDown(e) {

        // Something went down. Clear the last press if there was one.
        clearTimeout(this.longPressTimer);

        var pointers = e.getPointerList();

        // check that we only have one pointer down
        if (pointers.length === 1) {

            // cache the position of the pointer on the target
            e.target.longpressInitPosition = new PointerPosition(pointers[0]);

            // Start a timer.
            this.longPressTimer = setTimeout(function() {
                payload = {};
                window._createCustomEvent('gesturelongpress', e.target, payload);
            }, LONGPRESS_TIME);

        }

    }

    function pointerMove(e) {
        var pointers = e.getPointerList();

        if (e.pointerType === PointerTypes.MOUSE) {
            // if the pointer is a mouse we cancel the longpress
            // as soon as it starts wiggling around
            clearTimeout(this.longPressTimer);
        } else if (pointers.length === 1) {
            // but if the pointer is something else we allow a
            // for a bit of smudge space
            var pos = e.target.longpressInitPosition;

            if (pos && pos.calculateSquaredDistance(pointers[0]) > WIGGLE_THRESHOLD * WIGGLE_THRESHOLD) {
                clearTimeout(this.longPressTimer);
            }
        }

    }

    function pointerUp(e) {
        clearTimeout(this.longPressTimer);
    }

    /**
     * Make the specified element create gesturetap events.
     */
    function emitLongPresses(el) {
        el.addEventListener('pointerdown', pointerDown);
        el.addEventListener('pointermove', pointerMove);
        el.addEventListener('pointerup', pointerUp);
    }

    exports.Gesture._gestureHandlers.gesturelongpress = emitLongPresses;

})(window);
/**
 * Gesture recognizer for the `scale` gesture.
 *
 * Scale happens when two fingers are placed on the screen, and then
 * they move so the the distance between them is greater or less than a
 * certain threshold.
 */
(function(exports) {

    var SCALE_THRESHOLD = 0.2;

    function PointerPair(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
    }

    /**
     * Calculate the center of the two pointers.
     */
    PointerPair.prototype.center = function() {
        return [(this.p1.pageX + this.p2.pageX) / 2, (this.p1.pageY + this.p2.pageY) / 2];
    };

    /**
     * Calculate the distance between the two pointers.
     */
    PointerPair.prototype.span = function() {
        var dx = this.p1.pageX - this.p2.pageX;
        var dy = this.p1.pageY - this.p2.pageY;
        return Math.sqrt(dx * dx + dy * dy);
    };

    /**
     * Given a reference pair, calculate the scale multiplier difference.
     */
    PointerPair.prototype.scaleSince = function(referencePair) {
        var originalSpan = this.span();
        var referenceSpan = referencePair.span();
        if (referenceSpan == 0) return 0;
        else return originalSpan / referenceSpan;
    };

    function pointerDown(e) {
        var pointerList = e.getPointerList();
        // If there are exactly two pointers down,
        if (pointerList.length == 2) {
            // Record the initial pointer pair.
            e.target.scaleReferencePair = new PointerPair(pointerList[0],
                pointerList[1]);
        }
    }

    function pointerMove(e) {
        var pointerList = e.getPointerList();
        // If there are two pointers down, compare to the initial pointer pair.
        if (pointerList.length == 2 && e.target.scaleReferencePair) {
            var pair = new PointerPair(pointerList[0], pointerList[1]);
            // Compute the scaling value according to the difference.
            var scale = pair.scaleSince(e.target.scaleReferencePair);
            // If the movement is drastic enough:
            if (Math.abs(1 - scale) > SCALE_THRESHOLD) {
                // Create the scale event as a result.
                var payload = {
                    scale: scale,
                    centerX: (e.target.scaleReferencePair.p1.clientX + e.target.scaleReferencePair.p2.clientX) / 2,
                    centerY: (e.target.scaleReferencePair.p1.clientY + e.target.scaleReferencePair.p2.clientY) / 2
                };
                window._createCustomEvent('gesturescale', e.target, payload);
            }
        }
    }

    function pointerUp(e) {
        e.target.scaleReferencePair = null;
    }

    /**
     * Make the specified element create gesturetap events.
     */
    function emitScale(el) {
        el.addEventListener('pointerdown', pointerDown);
        el.addEventListener('pointermove', pointerMove);
        el.addEventListener('pointerup', pointerUp);
    }

    exports.Gesture._gestureHandlers.gesturescale = emitScale;



})(window);
define("plugins/pointer", function(){});

/*! jQuery plugin for Hammer.JS - v1.0.0 - 2014-01-02
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license *//*! Hammer.JS - v1.0.6 - 2014-01-02
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
  'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
  return new Hammer.Instance(element, options || {});
};

// default settings
Hammer.defaults = {
  // add styles and attributes to the element to prevent the browser from doing
  // its native behavior. this doesnt prevent the scrolling, but cancels
  // the contextmenu, tap highlighting etc
  // set to false to disable this
  stop_browser_behavior: {
    // this also triggers onselectstart=false for IE
    userSelect       : 'none',
    // this makes the element blocking in IE10 >, you could experiment with the value
    // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
    touchAction      : 'none',
    touchCallout     : 'none',
    contentZooming   : 'none',
    userDrag         : 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }

  //
  // more settings are defined per gesture at gestures.js
  //
};

// detect touchevents
Hammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// direction defines
Hammer.DIRECTION_DOWN = 'down';
Hammer.DIRECTION_LEFT = 'left';
Hammer.DIRECTION_UP = 'up';
Hammer.DIRECTION_RIGHT = 'right';

// pointer type
Hammer.POINTER_MOUSE = 'mouse';
Hammer.POINTER_TOUCH = 'touch';
Hammer.POINTER_PEN = 'pen';

// touch event defines
Hammer.EVENT_START = 'start';
Hammer.EVENT_MOVE = 'move';
Hammer.EVENT_END = 'end';

// hammer document where the base events are added at
Hammer.DOCUMENT = window.document;

// plugins and gestures namespaces
Hammer.plugins = Hammer.plugins || {};
Hammer.gestures = Hammer.gestures || {};

// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
  if(Hammer.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Hammer.event.determineEventTypes();

  // Register all gestures inside Hammer.gestures
  Hammer.utils.each(Hammer.gestures, function(gesture){
    Hammer.detection.register(gesture);
  });

  // Add touch events on the document
  Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
  Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

  // Hammer is ready...!
  Hammer.READY = true;
}

Hammer.utils = {
  /**
   * extend method,
   * also used for cloning when dest is an empty object
   * @param   {Object}    dest
   * @param   {Object}    src
   * @parm  {Boolean}  merge    do a merge
   * @returns {Object}    dest
   */
  extend: function extend(dest, src, merge) {
    for(var key in src) {
      if(dest[key] !== undefined && merge) {
        continue;
      }
      dest[key] = src[key];
    }
    return dest;
  },


  /**
   * for each
   * @param obj
   * @param iterator
   */
  each: function(obj, iterator, context) {
    var i, length;
    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
    }
    // arrays
    else if(obj.length !== undefined) {
      for (i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
    // objects
    else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a node is in the given parent
   * used for event delegation tricks
   * @param   {HTMLElement}   node
   * @param   {HTMLElement}   parent
   * @returns {boolean}       has_parent
   */
  hasParent: function(node, parent) {
    while(node) {
      if(node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },


  /**
   * get the center of all the touches
   * @param   {Array}     touches
   * @returns {Object}    center
   */
  getCenter: function getCenter(touches) {
    var valuesX = [], valuesY = [];

    Hammer.utils.each(touches, function(touch) {
      // I prefer clientX because it ignore the scrolling position
      valuesX.push(typeof touch.clientX !== 'undefined' ? touch.clientX : touch.pageX );
      valuesY.push(typeof touch.clientY !== 'undefined' ? touch.clientY : touch.pageY );
    });

    return {
      pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
      pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
    };
  },


  /**
   * calculate the velocity between two points
   * @param   {Number}    delta_time
   * @param   {Number}    delta_x
   * @param   {Number}    delta_y
   * @returns {Object}    velocity
   */
  getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
    return {
      x: Math.abs(delta_x / delta_time) || 0,
      y: Math.abs(delta_y / delta_time) || 0
    };
  },


  /**
   * calculate the angle between two coordinates
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {Number}    angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var y = touch2.pageY - touch1.pageY,
      x = touch2.pageX - touch1.pageX;
    return Math.atan2(y, x) * 180 / Math.PI;
  },


  /**
   * angle to direction define
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.pageX - touch2.pageX),
      y = Math.abs(touch1.pageY - touch2.pageY);

    if(x >= y) {
      return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
    }
    else {
      return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
    }
  },


  /**
   * calculate the distance between two touches
   * @param   {Touch}     touch1
   * @param   {Touch}     touch2
   * @returns {Number}    distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.pageX - touch1.pageX,
      y = touch2.pageY - touch1.pageY;
    return Math.sqrt((x * x) + (y * y));
  },


  /**
   * calculate the scale factor between two touchLists (fingers)
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param   {Array}     start
   * @param   {Array}     end
   * @returns {Number}    scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if(start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) /
        this.getDistance(start[0], start[1]);
    }
    return 1;
  },


  /**
   * calculate the rotation degrees between two touchLists (fingers)
   * @param   {Array}     start
   * @param   {Array}     end
   * @returns {Number}    rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if(start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) -
        this.getAngle(start[1], start[0]);
    }
    return 0;
  },


  /**
   * boolean if the direction is vertical
   * @param    {String}    direction
   * @returns  {Boolean}   is_vertical
   */
  isVertical: function isVertical(direction) {
    return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
  },


  /**
   * stop browser default behavior with css props
   * @param   {HtmlElement}   element
   * @param   {Object}        css_props
   */
  stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
    if(!css_props || !element || !element.style) {
      return;
    }

    // with css properties for modern browsers
    Hammer.utils.each(['webkit', 'khtml', 'moz', 'Moz', 'ms', 'o', ''], function(vendor) {
      Hammer.utils.each(css_props, function(prop) {
          // vender prefix at the property
          if(vendor) {
            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);
          }
          // set the style
          if(prop in element.style) {
            element.style[prop] = prop;
          }
      });
    });

    // also the disable onselectstart
    if(css_props.userSelect == 'none') {
      element.onselectstart = function() {
        return false;
      };
    }

    // and disable ondragstart
    if(css_props.userDrag == 'none') {
      element.ondragstart = function() {
        return false;
      };
    }
  }
};


/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
  var self = this;

  // setup HammerJS window events and register all gestures
  // this also sets up the default options
  setup();

  this.element = element;

  // start/stop detection option
  this.enabled = true;

  // merge options
  this.options = Hammer.utils.extend(
    Hammer.utils.extend({}, Hammer.defaults),
    options || {});

  // add some css to the element to prevent the browser from doing its native behavoir
  if(this.options.stop_browser_behavior) {
    Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
  }

  // start detection on touchstart
  Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
    if(self.enabled) {
      Hammer.detection.startDetect(self, ev);
    }
  });

  // return instance
  return this;
};


Hammer.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {String}      gesture
   * @param   {Function}    handler
   * @returns {Hammer.Instance}
   */
  on: function onEvent(gesture, handler) {
    var gestures = gesture.split(' ');
    Hammer.utils.each(gestures, function(gesture) {
      this.element.addEventListener(gesture, handler, false);
    }, this);
    return this;
  },


  /**
   * unbind events to the instance
   * @param   {String}      gesture
   * @param   {Function}    handler
   * @returns {Hammer.Instance}
   */
  off: function offEvent(gesture, handler) {
    var gestures = gesture.split(' ');
    Hammer.utils.each(gestures, function(gesture) {
      this.element.removeEventListener(gesture, handler, false);
    }, this);
    return this;
  },


  /**
   * trigger gesture event
   * @param   {String}      gesture
   * @param   {Object}      [eventData]
   * @returns {Hammer.Instance}
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if(!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = Hammer.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if(Hammer.utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },


  /**
   * enable of disable hammer.js detection
   * @param   {Boolean}   state
   * @returns {Hammer.Instance}
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  }
};


/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;


/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;


/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;


Hammer.event = {
  /**
   * simple addEventListener
   * @param   {HTMLElement}   element
   * @param   {String}        type
   * @param   {Function}      handler
   */
  bindDom: function(element, type, handler) {
    var types = type.split(' ');
    Hammer.utils.each(types, function(type){
      element.addEventListener(type, handler, false);
    });
  },


  /**
   * touch events with mouse fallback
   * @param   {HTMLElement}   element
   * @param   {String}        eventType        like Hammer.EVENT_MOVE
   * @param   {Function}      handler
   */
  onTouch: function onTouch(element, eventType, handler) {
    var self = this;

    this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
      var sourceEventType = ev.type.toLowerCase();

      // onmouseup, but when touchend has been fired we do nothing.
      // this is for touchdevices which also fire a mouseup on touchend
      if(sourceEventType.match(/mouse/) && touch_triggered) {
        return;
      }

      // mousebutton must be down or a touch event
      else if(sourceEventType.match(/touch/) ||   // touch events are always on screen
        sourceEventType.match(/pointerdown/) || // pointerevents touch
        (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
        ) {
        enable_detect = true;
      }

      // mouse isn't pressed
      else if(sourceEventType.match(/mouse/) && !ev.which) {
        enable_detect = false;
      }


      // we are in a touch event, set the touch triggered bool to true,
      // this for the conflicts that may occur on ios and android
      if(sourceEventType.match(/touch|pointer/)) {
        touch_triggered = true;
      }

      // count the total touches on the screen
      var count_touches = 0;

      // when touch has been triggered in this detection session
      // and we are now handling a mouse event, we stop that to prevent conflicts
      if(enable_detect) {
        // update pointerevent
        if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
          count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
        }
        // touch
        else if(sourceEventType.match(/touch/)) {
          count_touches = ev.touches.length;
        }
        // mouse
        else if(!touch_triggered) {
          count_touches = sourceEventType.match(/up/) ? 0 : 1;
        }

        // if we are in a end event, but when we remove one touch and
        // we still have enough, set eventType to move
        if(count_touches > 0 && eventType == Hammer.EVENT_END) {
          eventType = Hammer.EVENT_MOVE;
        }
        // no touches, force the end event
        else if(!count_touches) {
          eventType = Hammer.EVENT_END;
        }

        // store the last move event
        if(count_touches || last_move_event === null) {
          last_move_event = ev;
        }

        // trigger the handler
        handler.call(Hammer.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));

        // remove pointerevent from list
        if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
          count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
        }
      }

      // on the end we reset everything
      if(!count_touches) {
        last_move_event = null;
        enable_detect = false;
        touch_triggered = false;
        Hammer.PointerEvent.reset();
      }
    });
  },


  /**
   * we have different events for each device/browser
   * determine what we need and set them in the Hammer.EVENT_TYPES constant
   */
  determineEventTypes: function determineEventTypes() {
    // determine the eventtype we want to set
    var types;

    // pointerEvents magic
    if(Hammer.HAS_POINTEREVENTS) {
      types = Hammer.PointerEvent.getEvents();
    }
    // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
    else if(Hammer.NO_MOUSEEVENTS) {
      types = [
        'touchstart',
        'touchmove',
        'touchend touchcancel'];
    }
    // for non pointer events browsers and mixed browsers,
    // like chrome on windows8 touch laptop
    else {
      types = [
        'touchstart mousedown',
        'touchmove mousemove',
        'touchend touchcancel mouseup'];
    }

    Hammer.EVENT_TYPES[Hammer.EVENT_START] = types[0];
    Hammer.EVENT_TYPES[Hammer.EVENT_MOVE] = types[1];
    Hammer.EVENT_TYPES[Hammer.EVENT_END] = types[2];
  },


  /**
   * create touchlist depending on the event
   * @param   {Object}    ev
   * @param   {String}    eventType   used by the fakemultitouch plugin
   */
  getTouchList: function getTouchList(ev/*, eventType*/) {
    // get the fake pointerEvent touchlist
    if(Hammer.HAS_POINTEREVENTS) {
      return Hammer.PointerEvent.getTouchList();
    }
    // get the touchlist
    else if(ev.touches) {
      return ev.touches;
    }
    // make fake touchlist from mouse position
    else {
      ev.identifier = 1;
      return [ev];
    }
  },


  /**
   * collect event data for Hammer js
   * @param   {HTMLElement}   element
   * @param   {String}        eventType        like Hammer.EVENT_MOVE
   * @param   {Object}        eventData
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = Hammer.POINTER_TOUCH;
    if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
      pointerType = Hammer.POINTER_MOUSE;
    }

    return {
      center     : Hammer.utils.getCenter(touches),
      timeStamp  : new Date().getTime(),
      target     : ev.target,
      touches    : touches,
      eventType  : eventType,
      pointerType: pointerType,
      srcEvent   : ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function() {
        if(this.srcEvent.preventManipulation) {
          this.srcEvent.preventManipulation();
        }

        if(this.srcEvent.preventDefault) {
          this.srcEvent.preventDefault();
        }
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function() {
        return Hammer.detection.stopDetect();
      }
    };
  }
};

Hammer.PointerEvent = {
  /**
   * holds all pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get a list of pointers
   * @returns {Array}     touchlist
   */
  getTouchList: function() {
    var self = this;
    var touchlist = [];

    // we can use forEach since pointerEvents only is in IE10
    Hammer.utils.each(self.pointers, function(pointer){
      touchlist.push(pointer);
    });
    
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param   {String}   type             Hammer.EVENT_END
   * @param   {Object}   pointerEvent
   */
  updatePointer: function(type, pointerEvent) {
    if(type == Hammer.EVENT_END) {
      this.pointers = {};
    }
    else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }

    return Object.keys(this.pointers).length;
  },

  /**
   * check if ev matches pointertype
   * @param   {String}        pointerType     Hammer.POINTER_MOUSE
   * @param   {PointerEvent}  ev
   */
  matchType: function(pointerType, ev) {
    if(!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
      types = {};
    types[Hammer.POINTER_MOUSE] = (pt === ev.MSPOINTER_TYPE_MOUSE || pt === Hammer.POINTER_MOUSE);
    types[Hammer.POINTER_TOUCH] = (pt === ev.MSPOINTER_TYPE_TOUCH || pt === Hammer.POINTER_TOUCH);
    types[Hammer.POINTER_PEN] = (pt === ev.MSPOINTER_TYPE_PEN || pt === Hammer.POINTER_PEN);
    return types[pointerType];
  },


  /**
   * get events
   */
  getEvents: function() {
    return [
      'pointerdown MSPointerDown',
      'pointermove MSPointerMove',
      'pointerup pointercancel MSPointerUp MSPointerCancel'
    ];
  },

  /**
   * reset the list
   */
  reset: function() {
    this.pointers = {};
  }
};


Hammer.detection = {
  // contains all registred Hammer.gestures in the correct order
  gestures: [],

  // data of the current Hammer.gesture detection session
  current : null,

  // the previous Hammer.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped : false,


  /**
   * start Hammer.gesture detection
   * @param   {Hammer.Instance}   inst
   * @param   {Object}            eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a Hammer.gesture detection on an element
    if(this.current) {
      return;
    }

    this.stopped = false;

    this.current = {
      inst      : inst, // reference to HammerInstance we're working for
      startEvent: Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent : false, // last eventData
      name      : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },


  /**
   * Hammer.gesture detection
   * @param   {Object}    eventData
   */
  detect: function detect(eventData) {
    if(!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // instance options
    var inst_options = this.current.inst.options;

    // call Hammer.gesture handlers
    Hammer.utils.each(this.gestures, function(gesture) {
      // only when the instance options have enabled this gesture
      if(!this.stopped && inst_options[gesture.name] !== false) {
        // if a handler returns false, we stop with the detection
        if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
          this.stopDetect();
          return false;
        }
      }
    }, this);

    // store as previous event event
    if(this.current) {
      this.current.lastEvent = eventData;
    }

    // endevent, but not the last touch, so dont stop
    if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length - 1) {
      this.stopDetect();
    }

    return eventData;
  },


  /**
   * clear the Hammer.gesture vars
   * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
   * to stop other Hammer.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Hammer.utils.extend({}, this.current);

    // reset the current
    this.current = null;

    // stopped!
    this.stopped = true;
  },


  /**
   * extend eventData for Hammer.gestures
   * @param   {Object}   ev
   * @returns {Object}   ev
   */
  extendEventData: function extendEventData(ev) {
    var startEv = this.current.startEvent;

    // if the touches change, set the new touches over the startEvent touches
    // this because touchevents don't have all the touches on touchstart, or the
    // user must place his fingers at the EXACT same time on the screen, which is not realistic
    // but, sometimes it happens that both fingers are touching at the EXACT same time
    if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
      // extend 1 level deep to get the touchlist with the touch objects
      startEv.touches = [];
      Hammer.utils.each(ev.touches, function(touch) {
        startEv.touches.push(Hammer.utils.extend({}, touch));
      });
    }

    var delta_time = ev.timeStamp - startEv.timeStamp
      , delta_x = ev.center.pageX - startEv.center.pageX
      , delta_y = ev.center.pageY - startEv.center.pageY
      , velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y)
      , interimAngle
      , interimDirection;

    // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle
    // because the previous event has exactly the same coordinates
    // so for end events, take the previous values of interimDirection & interimAngle
    // instead of recalculating them and getting a spurious '0'
    if(ev.eventType === 'end') {
      interimAngle = this.current.lastEvent && this.current.lastEvent.interimAngle;
      interimDirection = this.current.lastEvent && this.current.lastEvent.interimDirection;
    }
    else {
      interimAngle = this.current.lastEvent && Hammer.utils.getAngle(this.current.lastEvent.center, ev.center);
      interimDirection = this.current.lastEvent && Hammer.utils.getDirection(this.current.lastEvent.center, ev.center);
    }

    Hammer.utils.extend(ev, {
      deltaTime: delta_time,

      deltaX: delta_x,
      deltaY: delta_y,

      velocityX: velocity.x,
      velocityY: velocity.y,

      distance: Hammer.utils.getDistance(startEv.center, ev.center),

      angle: Hammer.utils.getAngle(startEv.center, ev.center),
      interimAngle: interimAngle,

      direction: Hammer.utils.getDirection(startEv.center, ev.center),
      interimDirection: interimDirection,

      scale: Hammer.utils.getScale(startEv.touches, ev.touches),
      rotation: Hammer.utils.getRotation(startEv.touches, ev.touches),

      startEvent: startEv
    });

    return ev;
  },


  /**
   * register new gesture
   * @param   {Object}    gesture object, see gestures.js for documentation
   * @returns {Array}     gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if(options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend Hammer default options with the Hammer.gesture options
    Hammer.utils.extend(Hammer.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add Hammer.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function(a, b) {
      if(a.index < b.index) { return -1; }
      if(a.index > b.index) { return 1; }
      return 0;
    });

    return this.gestures;
  }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
  name     : 'drag',
  index    : 50,
  defaults : {
    drag_min_distance            : 10,
    
    // Set correct_for_drag_min_distance to true to make the starting point of the drag
    // be calculated from where the drag was triggered, not from where the touch started.
    // Useful to avoid a jerk-starting drag, which can make fine-adjustments
    // through dragging difficult, and be visually unappealing.
    correct_for_drag_min_distance: true,
    
    // set 0 for unlimited, but this can conflict with transform
    drag_max_touches             : 1,
    
    // prevent default browser behavior when dragging occurs
    // be careful with it, it makes the element a blocking element
    // when you are using the drag gesture, it is a good practice to set this true
    drag_block_horizontal        : false,
    drag_block_vertical          : false,
    
    // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
    // It disallows vertical directions if the initial direction was horizontal, and vice versa.
    drag_lock_to_axis            : false,
    
    // drag lock only kicks in when distance > drag_lock_min_distance
    // This way, locking occurs only when the distance has become large enough to reliably determine the direction
    drag_lock_min_distance       : 25
  },
  
  triggered: false,
  handler  : function dragGesture(ev, inst) {
    // current gesture isnt drag, but dragged is true
    // this means an other gesture is busy. now call dragend
    if(Hammer.detection.current.name != this.name && this.triggered) {
      inst.trigger(this.name + 'end', ev);
      this.triggered = false;
      return;
    }

    // max touches
    if(inst.options.drag_max_touches > 0 &&
      ev.touches.length > inst.options.drag_max_touches) {
      return;
    }

    switch(ev.eventType) {
      case Hammer.EVENT_START:
        this.triggered = false;
        break;

      case Hammer.EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(ev.distance < inst.options.drag_min_distance &&
          Hammer.detection.current.name != this.name) {
          return;
        }

        // we are dragging!
        if(Hammer.detection.current.name != this.name) {
          Hammer.detection.current.name = this.name;
          if(inst.options.correct_for_drag_min_distance && ev.distance > 0) {
            // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
            Hammer.detection.current.startEvent.center.pageX += ev.deltaX * factor;
            Hammer.detection.current.startEvent.center.pageY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Hammer.detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
          ev.drag_locked_to_axis = true;
        }
        var last_direction = Hammer.detection.current.lastEvent.direction;
        if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
          // keep direction on the axis that the drag gesture started on
          if(Hammer.utils.isVertical(last_direction)) {
            ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
          }
          else {
            ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if(!this.triggered) {
          inst.trigger(this.name + 'start', ev);
          this.triggered = true;
        }

        // trigger normal event
        inst.trigger(this.name, ev);

        // direction event, like dragdown
        inst.trigger(this.name + ev.direction, ev);

        // block the browser events
        if((inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
          (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
          ev.preventDefault();
        }
        break;

      case Hammer.EVENT_END:
        // trigger dragend
        if(this.triggered) {
          inst.trigger(this.name + 'end', ev);
        }

        this.triggered = false;
        break;
    }
  }
};

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
  name    : 'hold',
  index   : 10,
  defaults: {
    hold_timeout  : 500,
    hold_threshold: 1
  },
  timer   : null,
  handler : function holdGesture(ev, inst) {
    switch(ev.eventType) {
      case Hammer.EVENT_START:
        // clear any running timers
        clearTimeout(this.timer);

        // set the gesture so we can check in the timeout if it still is
        Hammer.detection.current.name = this.name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        this.timer = setTimeout(function() {
          if(Hammer.detection.current.name == 'hold') {
            inst.trigger('hold', ev);
          }
        }, inst.options.hold_timeout);
        break;

      // when you move or end we clear the timer
      case Hammer.EVENT_MOVE:
        if(ev.distance > inst.options.hold_threshold) {
          clearTimeout(this.timer);
        }
        break;

      case Hammer.EVENT_END:
        clearTimeout(this.timer);
        break;
    }
  }
};

/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
  name   : 'release',
  index  : Infinity,
  handler: function releaseGesture(ev, inst) {
    if(ev.eventType == Hammer.EVENT_END) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
  name    : 'swipe',
  index   : 40,
  defaults: {
    // set 0 for unlimited, but this can conflict with transform
    swipe_min_touches: 1,
    swipe_max_touches: 1,
    swipe_velocity   : 0.7
  },
  handler : function swipeGesture(ev, inst) {
    if(ev.eventType == Hammer.EVENT_END) {
      // max touches
      if(inst.options.swipe_max_touches > 0 &&
        ev.touches.length < inst.options.swipe_min_touches &&
        ev.touches.length > inst.options.swipe_max_touches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if(ev.velocityX > inst.options.swipe_velocity ||
        ev.velocityY > inst.options.swipe_velocity) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
  name    : 'tap',
  index   : 100,
  defaults: {
    tap_max_touchtime : 250,
    tap_max_distance  : 10,
    tap_always        : true,
    doubletap_distance: 20,
    doubletap_interval: 300
  },
  handler : function tapGesture(ev, inst) {
    if(ev.eventType == Hammer.EVENT_END && ev.srcEvent.type != 'touchcancel') {
      // previous gesture, for the double tap since these are two different gesture detections
      var prev = Hammer.detection.previous,
        did_doubletap = false;

      // when the touchtime is higher then the max touch time
      // or when the moving distance is too much
      if(ev.deltaTime > inst.options.tap_max_touchtime ||
        ev.distance > inst.options.tap_max_distance) {
        return;
      }

      // check if double tap
      if(prev && prev.name == 'tap' &&
        (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
        ev.distance < inst.options.doubletap_distance) {
        inst.trigger('doubletap', ev);
        did_doubletap = true;
      }

      // do a single tap
      if(!did_doubletap || inst.options.tap_always) {
        Hammer.detection.current.name = 'tap';
        inst.trigger(Hammer.detection.current.name, ev);
      }
    }
  }
};

/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
  name    : 'touch',
  index   : -Infinity,
  defaults: {
    // call preventDefault at touchstart, and makes the element blocking by
    // disabling the scrolling of the page, but it improves gestures like
    // transforming and dragging.
    // be careful with using this, it can be very annoying for users to be stuck
    // on the page
    prevent_default    : false,

    // disable mouse events, so only touch (or pen!) input triggers events
    prevent_mouseevents: false
  },
  handler : function touchGesture(ev, inst) {
    if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if(inst.options.prevent_default) {
      ev.preventDefault();
    }

    if(ev.eventType == Hammer.EVENT_START) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
  name     : 'transform',
  index    : 45,
  defaults : {
    // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
    transform_min_scale   : 0.01,
    // rotation in degrees
    transform_min_rotation: 1,
    // prevent default browser behavior when two touches are on the screen
    // but it makes the element a blocking element
    // when you are using the transform gesture, it is a good practice to set this true
    transform_always_block: false
  },
  triggered: false,
  handler  : function transformGesture(ev, inst) {
    // current gesture isnt drag, but dragged is true
    // this means an other gesture is busy. now call dragend
    if(Hammer.detection.current.name != this.name && this.triggered) {
      inst.trigger(this.name + 'end', ev);
      this.triggered = false;
      return;
    }

    // atleast multitouch
    if(ev.touches.length < 2) {
      return;
    }

    // prevent default when two fingers are on the screen
    if(inst.options.transform_always_block) {
      ev.preventDefault();
    }

    switch(ev.eventType) {
      case Hammer.EVENT_START:
        this.triggered = false;
        break;

      case Hammer.EVENT_MOVE:
        var scale_threshold = Math.abs(1 - ev.scale);
        var rotation_threshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if(scale_threshold < inst.options.transform_min_scale &&
          rotation_threshold < inst.options.transform_min_rotation) {
          return;
        }

        // we are transforming!
        Hammer.detection.current.name = this.name;

        // first time, trigger dragstart event
        if(!this.triggered) {
          inst.trigger(this.name + 'start', ev);
          this.triggered = true;
        }

        inst.trigger(this.name, ev); // basic transform event

        // trigger rotate event
        if(rotation_threshold > inst.options.transform_min_rotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if(scale_threshold > inst.options.transform_min_scale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
        }
        break;

      case Hammer.EVENT_END:
        // trigger dragend
        if(this.triggered) {
          inst.trigger(this.name + 'end', ev);
        }

        this.triggered = false;
        break;
    }
  }
};

  // Based off Lo-Dash's excellent UMD wrapper (slightly modified) - https://github.com/bestiejs/lodash/blob/master/lodash.js#L5515-L5543
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  /*if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module
    define(function() {
      return Hammer;
    });
    // check for `exports` after `define` in case a build optimizer adds an `exports` object
  }
  else if(typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = Hammer;
  }
  else {*/
    /** michael forbes - belkin - remove AMD, it isn't working **/
    window.Hammer = Hammer;
  //}
})(this);

/*! jQuery plugin for Hammer.JS - v1.0.0 - 2014-01-02
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */(function(window, undefined) {
  'use strict';

function setup(Hammer, $) {
  /**
   * bind dom events
   * this overwrites addEventListener
   * @param   {HTMLElement}   element
   * @param   {String}        eventTypes
   * @param   {Function}      handler
   */
  Hammer.event.bindDom = function(element, eventTypes, handler) {
    $(element).on(eventTypes, function(ev) {
      var data = ev.originalEvent || ev;

      if(data.pageX === undefined) {
        data.pageX = ev.pageX;
        data.pageY = ev.pageY;
      }

      if(!data.target) {
        data.target = ev.target;
      }

      if(data.which === undefined) {
        data.which = data.button;
      }

      if(!data.preventDefault) {
        data.preventDefault = ev.preventDefault;
      }

      if(!data.stopPropagation) {
        data.stopPropagation = ev.stopPropagation;
      }

      handler.call(this, data);
    });
  };

  /**
   * the methods are called by the instance, but with the jquery plugin
   * we use the jquery event methods instead.
   * @this    {Hammer.Instance}
   * @return  {jQuery}
   */
  Hammer.Instance.prototype.on = function(types, handler) {
    return $(this.element).on(types, handler);
  };
  Hammer.Instance.prototype.off = function(types, handler) {
    return $(this.element).off(types, handler);
  };


  /**
   * trigger events
   * this is called by the gestures to trigger an event like 'tap'
   * @this    {Hammer.Instance}
   * @param   {String}    gesture
   * @param   {Object}    eventData
   * @return  {jQuery}
   */
  Hammer.Instance.prototype.trigger = function(gesture, eventData) {
    var el = $(this.element);
    if(el.has(eventData.target).length) {
      el = $(eventData.target);
    }

    return el.trigger({
      type   : gesture,
      gesture: eventData
    });
  };


  /**
   * jQuery plugin
   * create instance of Hammer and watch for gestures,
   * and when called again you can change the options
   * @param   {Object}    [options={}]
   * @return  {jQuery}
   */
  $.fn.hammer = function(options) {
    return this.each(function() {
      var el = $(this);
      var inst = el.data('hammer');
      // start new hammer instance
      if(!inst) {
        el.data('hammer', new Hammer(this, options || {}));
      }
      // change the options
      else if(inst && options) {
        Hammer.utils.extend(inst.options, options);
      }
    });
  };
}

  // Based off Lo-Dash's excellent UMD wrapper (slightly modified) - https://github.com/bestiejs/lodash/blob/master/lodash.js#L5515-L5543
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
 /* if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module
    define(['hammer', 'jquery'], setup);

  }
  else {
    setup(window.Hammer, window.jQuery || window.Zepto);
  }*/
/** michael forbes, belkin - remove AMD, it isn't working, never calls setup **/
    setup(window.Hammer, window.jQuery || window.Zepto);

})(this);
define("jqueryhammer", function(){});

window.DEBUG = false;

define('features/app/wemo', ['aura/aura', 'feature!appSettings', 'feature!appDependencies', 'libs/pouchInterface', 'feature!demoDevices', 'feature!sqlitePlugin', 'plugins/pointer', 'jqueryhammer'], function(Aura, appSettings, appDependencies, pouchInterface, demoDevices) {

    'use strict';
    // use app here
    // 
    // 
    var app = new Aura();
    if (window.testRunner) {
        window.app = app;
    }


    var thisWidget;

    function loadI18N(lang) {
        return $.Deferred(function(dfd) {
            var root = '../www/locales/',
                root_old = '../locales/';


            lang = lang || app.core.i18n.lng();

            if(lang === "en-GB"){
                lang = "en-UK";
            }

            var i18nPath = root + lang + '/translation.json',
                i18nPath_old = root + lang + '/translation.json';


            DEBUG && console.log('APP:loadI18N:path=' + i18nPath);

            function downloadI18n() {
                DEBUG && console.log('APP:downloadI18n:path=' + i18nPath);
                return $.ajax({
                    url: i18nPath,
                    dataType: 'json',
                    type: 'GET'
                });
            }

            function failI18n(resp) {
                DEBUG && console.log('APP:i18n:failing to default:path=' + i18nPath);
                lang = 'en-US';
                i18nPath = root + lang + '/translation.json';

                DEBUG && console.log('APP:i18n:failing to default:resp=' + JSON.stringify(resp));
                downloadI18n().then(addToApp).fail(function(resp) {
                    DEBUG && console.log('APP:i18n:failed loading default:resp=' + JSON.stringify(resp));
                });
            }

            function addToApp(resp) {
                var i18n = JSON.stringify(resp);
                app.core.util.storage.removeItem(i18nPath_old);
                app.core.util.storage.removeItem(i18nPath);
                app.core.util.storage.setItem(i18nPath, i18n);
                app.core.i18n.addResourceBundle(app.core.i18n.lng(), 'app', resp);
                DEBUG && console.log('APP:i18n:resolving and adding');
                dfd.resolve();
            }


            downloadI18n().then(addToApp).fail(failI18n);



        }).promise();


    }

    app.config.widgets.sources.
    default = '../widgets';

    appDependencies.forEach(function(extension) {
        app.use(extension);
    });


    //jquery.transit setup
    if (!$.support.transition) {
        $.fn.transition = $.fn.animate;
    }


    //global events are processed here.
    var start = function() {


        if (!window.testRunner) {

            if (app.device.os === 'ios') {



                if (window.device && parseInt(window.device.version, 10) === 7) {
                    $('body').addClass('ios7');
                }

                $('body').addClass('ios');


                /*
                //    $.when(window.app.uiInterface.getWidgetPath()).done(function(resp) {

                thisWidget = resp;
                // $('#startWidget').attr('data-aura-widget', resp);

                app.start({
                    widgets: 'body'
                }).then(function() {

                    loadI18N();

                });
                // });
*/



                var sb;

                window.nativeDeviceStatusChanged = function(data) {
                    if (sb._children[0]) {
                        var model = sb._children[0].model;
                        var resp = model.trimResponse(data);
                        model.set(resp);
                    } else {
                        setTimeout(function() {
                            window.nativeDeviceStatusChanged(data);
                        }, 20)
                    }
                };

                window.changeViewFromNative = function(path) {
                    var widget = $('#wemoWidget').attr('data-aura-widget');
                    if (path !== widget) {

                        var $widget = $('<div id="wemoWidget" data-aura-toload="' + path + '" data-aura-widget="' + path + '"></div>');
                        $("#startWidget").empty().append($widget);
                        app.sandbox.stop();
                        sb = app.sandbox.start('#startWidget');
                    }
                };

                app.start({}).then(function() {
                    loadI18N();
                });

            } else {
                /** use to test device api **/
                /*
                 $.when(window.app.uiInterface.getWidgetPath()).done(function(resp){
                 console.log('RESPONSE:'+resp);
                 });
                 */
                var startImmediate = true;
                DEBUG && console.log('EVENT:BEFORE DOME INSERT');
                $('body').addClass('android');
                DEBUG && console.log('EVENT:STARTING APP');
                //get the startWidget and append it
                if (appSettings.startWidget.length > 0) {
                    if (window.location.href.match(/indexdl/) && app.device.os === 'web') {

                    } else if (window.location.href.match(/iostest/) && app.device.os === 'web') {
                        startImmediate = false;
                    } else if (window.location.href.match(/\//) && app.device.os === 'web' && !window.location.href.match(/\?demodevices/)) {
                        var s = window.location.href.split('?');
                        //  $('#startWidget').attr('data-aura-widget', s[1]);
                        $('#startWidget').attr('data-aura-toload', s[1]);
                        $('#startWidget').attr('data-aura-widget', 'bundlemanager');
                    } else if (window.location.href.match(/\?widget/)) {
                        var s = window.location.href.split('=');
                        //  $('#startWidget').attr('data-aura-widget', s[1]);
                        $('#startWidget').attr('data-aura-toload', s[1]);
                        $('#startWidget').attr('data-aura-widget', 'bundlemanager');
                    } else if (window.location.href.match(/\?demodevices/)) {
                        var s = window.location.href.split('=');
                        //  $('#startWidget').attr('data-aura-widget', s[1]);
                        if (demoDevices) {

                            _.each(demoDevices, function(value, index) {

                                var type = value.type;
                                var t = type.split(':');
                                if (!t[3].match(/wemo/)) {
                                    t[3] = 'wemo_' + t[3];
                                }

                                var $device = $('<li data-aura-toload="' + t[3] + '" data-aura-widget="bundlemanager"></li>');
                                $("#startWidget").append($device);
                            });

                            $("#startWidget").append('<li data-aura-widget="wemo_firmwareupdate"></li>');

                        }

                    } else {
                        if (!window.location.href.match(/devices\.html/)) {
                            $('#startWidget').attr('data-aura-widget', appSettings.startWidget);
                        }

                    }

                }
                if (startImmediate) {
                    app.start({
                        widgets: 'body'
                    }).then(function() {
                        loadI18N().then(function() {
                            app.sandbox.start('#startWidget', {
                                parentSandbox: app.sandbox
                            });
                        });
                    });
                } else {

                    var sb;

                    window.nativeDeviceStatusChanged = function(data) {
                        if (sb._children[0]) {
                            var model = sb._children[0].model;
                            var resp = model.trimResponse(data);
                            model.set(resp);
                        } else {
                            setTimeout(function() {
                                window.nativeDeviceStatusChanged(data);
                            }, 20)
                        }
                    };

                    window.changeViewFromNative = function(path) {
                        var widget = $('#wemoWidget').attr('data-aura-widget');
                        if (path !== widget) {

                            var $widget = $('<div id="wemoWidget" data-aura-toload="' + path + '" data-aura-widget="' + path + '"></div>');
                            $("#startWidget").empty().append($widget);
                            app.sandbox.stop();
                            sb = app.sandbox.start('#startWidget');
                        }
                    };

                    app.start({}).then(function() {
                        loadI18N();
                    });
                }

            }
        }
    };

    // window.localStorage.clear();

    return {
        init: function(options) {


            if (this.device) {
                app.device = this.device;
                $('html').addClass(app.device.os);

            }

            $.fn.hasScrollBar = function() {
                return this.get(0).scrollHeight > this.get(0).clientHeight;
            };

            if (app.device.os === 'ios') {
                $.fn.resizeElement = function() {
                    var pxRatio = window.devicePixelRatio,
                        width = Math.min(window.screen.availWidth, window.screen.availHeight),
                        height = Math.max(screen.width, screen.height),
                        aspectRatio = Math.round(height / width, 2),
                        fontSize = (width * 100 / 640).toFixed(2);

                    console.log('pxRatio: ' + pxRatio +
                        ' width: ' + width +
                        ' height: ' + height +
                        ' aspectRatio: ' + aspectRatio +
                        ' fontSize: ' + fontSize);

                    this.css('font-size', fontSize + "%");
                };
            } else {

                $.fn.resizeElement = function() {
                    var fontSize;
                    if (window.isCrosswalk) {
                        fontSize = '50%';
                    } else {
                        var pxRatio = window.devicePixelRatio,
                            width = Math.min(screen.width, screen.height) / pxRatio,
                            height = Math.max(screen.width, screen.height),
                            aspectRatio = Math.round(height / width, 2),
                            fontSize = (width * 100 / 720).toFixed(2);

                        console.log('pxRatio: ' + pxRatio +
                            ' width: ' + width +
                            ' height: ' + height +
                            ' aspectRatio: ' + aspectRatio +
                            ' fontSize: ' + fontSize);

                        fontSize = (width <= 720) ? fontSize + "%" : '56%';

                    }

                    this.css('font-size', fontSize);


                };
            }




            if (!window.isSmartCache) {
                $('#startWidget').resizeElement();
            }
            start();



        }
    };


});
(function() {
    // YOUR ORIGINAL CODE HERE
    // 

    'use strict';

    window.backButtonCommands = {};
    var backButtonKeys = [];

    function backButtonCallback() {
        DEBUG && console.log('BACK BUTTON:android.js:backButtonCallback:should be fired every time back button is pressed');
        var last = _.last(backButtonKeys);
        if (window.backButtonCommands && window.backButtonCommands[last]) {
            window.backButtonCommands[last]();
            setTimeout(function() {
                //window.app.events.emit('removeBackButtonCommand', last);
                var command = new CustomEvent("removeBackButtonCommand", {
                    detail: {
                        key: last
                    }
                });
                // Trigger it!
                document.dispatchEvent(command);

            }, 0);
        } else {
            //no other back button commands.
            DEBUG && console.warn('there are no back button commands.');
        }
    }

    var BackButtonController = function(options) {
        this.initialize(options);
    }

    BackButtonController.prototype = {
        constructor: BackButtonController,
        initialize: function() {
            _.bindAll(this);

            this.listen();
        },
        listen: function() {
            var self = this;
            document.addEventListener('addBackButtonCommand', self.addBackButtonCommand);
            document.addEventListener('removeBackButtonCommand', self.removeBackButtonCommand);

            document.addEventListener('backbutton', function(e) {
                DEBUG && console.log('BACK BUTTON:android.js:added event listener');
                backButtonCallback();
            }, false);
        },
        addBackButtonCommand: function(data) {

            if (data.detail) {
                data = data.detail;
            }

            //see if it is  already there.
            if (_.indexOf(backButtonKeys, data.key) === -1) {
                backButtonKeys.push(data.key);
                backButtonCommands[data.key] = data.callback;
                DEBUG && console.log('BACK BUTTON:android.js:setupBackButton:addBackButtonCommand:backButtonKeys=' + JSON.stringify(backButtonKeys));
            }
            // if it is, delete the existing one and use this one as last in
            else {
                this.removeBackButtonCommand(data.key);
                this.addBackButtonCommand(data);
            }

        },
        removeBackButtonCommand: function(resp) {
            var key;
            if (typeof(resp) !== 'string') {
                key = resp.detail.key;
            } else {
                key = resp;
            }

            DEBUG && console.log('BACK BUTTON:android.js:setupBackButton:removeBackButtonCommand:key=' + key);
            var keyA = key.split('-');

            if (keyA[2] != '') {
                delete backButtonCommands[key];
                backButtonKeys = _.without(backButtonKeys, key);
            } else {
                var keysToDelete = [];
                var expression = new RegExp(key);
                backButtonKeys.forEach(function(value) {

                    if (value && value.match(expression)) {
                        keysToDelete.push(value);
                    }
                });

                if (keysToDelete.length > 0) {

                    keysToDelete.forEach(function(value) {
                        delete backButtonCommands[value];
                    });
                    backButtonKeys = _.difference(backButtonKeys, keysToDelete);

                }
            }
        }
    }

    if (typeof define === 'function' && define.amd) {
        define('libs/backButtonController',['underscore'], function(_) {
            return BackButtonController;
        });
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = BackButtonController;

        // Or maybe: module.exports.Foo = Foo;
        // It's up to you really.
    } else {
        this.backButtonController = new BackButtonController();
    }
}.call(this));
define('android',[ /*'cordova/android-cordova-2.7.0',*/ 'feature!app', 'libs/backButtonController'], function( /*cordova,*/ app, BackButtonController) {
    'use strict';

    //need to make this window for integration with existing app.

    var initCount = 0;

    var mobileApp = {
        // Application Constructor
        initialize: function() {
            this.bindEvents();
        },
        // Bind Event Listeners
        //
        // Bind any events that are required on startup. Common events are:
        // 'load', 'deviceready', 'offline', and 'online'.
        bindEvents: function() {
            var self = this;
            document.addEventListener('deviceready', this.onDeviceReady, false);
            this.onDeviceReady();

        },
        // deviceready Event Handler
        //
        // The scope of 'this' is the event. In order to call the 'receivedEvent'
        // function, we must explicity call 'app.receivedEvent(...);'
        onDeviceReady: function() {
            if (!initCount) {
                initCount++;
                mobileApp.receivedEvent('deviceready');

                mobileApp.setupBackButton();

                app.device = {
                    os: 'android'
                };
                app.init();
            }
        },
        // Update DOM on a Received Event
        receivedEvent: function(id) {

        },
        setupBackButton: function() {
            this.backButtonController = new BackButtonController();
        }
    };


    return {
        init: function() {
            mobileApp.initialize();
        }
    }

});
define('target',['feature!target'], function (target) {
    'use strict';

    target.init();

});
require.config({
    deps: ['target', 'jquery', 'Cache', /* 'DeepModel',*/ 'backboneModelBinder'],
    paths: {
        locales: '../locales',
        extensions: '../extensions',
        components: '../components',
        pep: '../components/jquery.pep.js-master/src/jquery.pep',
        pouchDB: '../scripts/libs/pouchdb',
        lawnchair: '../scripts/libs/lawnchair',
        basketjs: '../components/basketjs/lib/basket',
        rsvp: '../components/rsvp/rsvp',
        css: '../components/require-css/css',
        normalize: '../components/require-css/normalize',
        aura: '../components/aura/lib',
        cordova: '../components/cordova',
        jquery: '../components/jquery/jquery',
        jqueryhammer: '../components/jquery-hammerjs/jquery.hammer',
        backboneBase: '../components/backbone/backbone',
        backbone: 'plugins/backbone.overrides',
        backboneValidation: '../components/backbone-validation/src/backbone-validation',
        underscore: '../components/lodash/dist/lodash.underscore',
        eventemitter: '../components/eventemitter2/lib/eventemitter2',
        plugins: '../scripts/plugins',
        mixins: '../scripts/mixins',
        Cache: 'plugins/backbone.deep-model',
        backboneModelBinder: 'plugins/backbone.stickit',
        implementations: '../scripts/features/features',
        handlebars: '../components/require-handlebars-plugin/Handlebars',
        hbs: '../components/require-handlebars-plugin/hbs',
        i18nprecompile: '../components/require-handlebars-plugin/hbs/i18nprecompile',
        json2: '../components/require-handlebars-plugin/hbs/json2',
        i18next: '../components/i18next/release/i18next.amd.withJQuery-1.8.0',
        mobiscroll: 'plugins/mobiscroll',
        shifty: '../components/shifty/shifty'

    },
    hbs: {
        disableI18n: true,
        disableHelpers: true,
        templateExtension: 'html'
    },
    shim: {
        underscore: {
            exports: '_'
        },
        jquery: {
            exports: '$'
        },
        backboneBase: {
            deps: ['jquery', 'underscore', 'plugins/jquery.cookie'],
            exports: 'Backbone'
        },
        backbone: {
            deps: ['backboneBase'],
            exports: 'Backbone'
        },
        'backboneModelBinder': {
            deps: ['backbone'],
            exports: 'Backbone'
        },
        /*  Cache:{
            deps:['DeepModel'],
            exports: 'Backbone'
        },*/
        Cache: {
            deps: ['backboneModelBinder', 'underscore', 'plugins/underscore.mixin.deepExtend'],
            exports: 'Backbone'
        },
        'aura/aura': {
            deps: [
                'aura/ext/mediator',
                'aura/ext/widgets',
                'aura/ext/debug',
                //   'css',
                'hbs',
                'text'
            ],
            exports: 'Aura'
        },

        //  'plugins/jquery.offcanvas':['plugins/jquery.transit'],
        'plugins/backbone.validation': ['backbone'],
        'plugins/underscore.mixin.deepExtend': ['underscore']
    }
});
define("main", function(){});
}());